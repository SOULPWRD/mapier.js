
        <!DOCTYPE HTML>
        <html>
            <body>
                <div id="root"></div>
                <script type="module" data-app="application">var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class BaseEvent {
  /**
   * @param {string} type Type.
   */
  constructor(type) {
    this.propagationStopped;
    this.defaultPrevented;
    this.type = type;
    this.target = null;
  }
  /**
   * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
   * will be fired.
   * @api
   */
  preventDefault() {
    this.defaultPrevented = true;
  }
  /**
   * Stop event propagation.
   * @api
   */
  stopPropagation() {
    this.propagationStopped = true;
  }
}
const ObjectEventType = {
  /**
   * Triggered when a property is changed.
   * @event module:ol/Object.ObjectEvent#propertychange
   * @api
   */
  PROPERTYCHANGE: "propertychange"
};
class Disposable {
  constructor() {
    this.disposed = false;
  }
  /**
   * Clean up.
   */
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      this.disposeInternal();
    }
  }
  /**
   * Extension point for disposable objects.
   * @protected
   */
  disposeInternal() {
  }
}
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function extend$2(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function equals$2(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || res === 0);
  });
}
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!lastArgs || this !== lastThis || !equals$2(nextArgs, lastArgs)) {
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty$1(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
class Target extends Disposable {
  /**
   * @param {*} [target] Default event target for dispatched events.
   */
  constructor(target) {
    super();
    this.eventTarget_ = target;
    this.pendingRemovals_ = null;
    this.dispatching_ = null;
    this.listeners_ = null;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  addEventListener(type, listener) {
    if (!type || !listener) {
      return;
    }
    const listeners = this.listeners_ || (this.listeners_ = {});
    const listenersForType = listeners[type] || (listeners[type] = []);
    if (!listenersForType.includes(listener)) {
      listenersForType.push(listener);
    }
  }
  /**
   * Dispatches an event and calls all listeners listening for events
   * of this type. The event parameter can either be a string or an
   * Object with a `type` property.
   *
   * @param {import("./Event.js").default|string} event Event object.
   * @return {boolean|undefined} `false` if anyone called preventDefault on the
   *     event object or if any of the listeners returned false.
   * @api
   */
  dispatchEvent(event) {
    const isString = typeof event === "string";
    const type = isString ? event : event.type;
    const listeners = this.listeners_ && this.listeners_[type];
    if (!listeners) {
      return;
    }
    const evt = isString ? new BaseEvent(event) : (
      /** @type {Event} */
      event
    );
    if (!evt.target) {
      evt.target = this.eventTarget_ || this;
    }
    const dispatching = this.dispatching_ || (this.dispatching_ = {});
    const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
    if (!(type in dispatching)) {
      dispatching[type] = 0;
      pendingRemovals[type] = 0;
    }
    ++dispatching[type];
    let propagate;
    for (let i = 0, ii = listeners.length; i < ii; ++i) {
      if ("handleEvent" in listeners[i]) {
        propagate = /** @type {import("../events.js").ListenerObject} */
        listeners[i].handleEvent(evt);
      } else {
        propagate = /** @type {import("../events.js").ListenerFunction} */
        listeners[i].call(this, evt);
      }
      if (propagate === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    if (--dispatching[type] === 0) {
      let pr = pendingRemovals[type];
      delete pendingRemovals[type];
      while (pr--) {
        this.removeEventListener(type, VOID);
      }
      delete dispatching[type];
    }
    return propagate;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.listeners_ && clear(this.listeners_);
  }
  /**
   * Get the listeners for a specified event type. Listeners are returned in the
   * order that they will be called in.
   *
   * @param {string} type Type.
   * @return {Array<import("../events.js").Listener>|undefined} Listeners.
   */
  getListeners(type) {
    return this.listeners_ && this.listeners_[type] || void 0;
  }
  /**
   * @param {string} [type] Type. If not provided,
   *     `true` will be returned if this event target has any listeners.
   * @return {boolean} Has listeners.
   */
  hasListener(type) {
    if (!this.listeners_) {
      return false;
    }
    return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
  }
  /**
   * @param {string} type Type.
   * @param {import("../events.js").Listener} listener Listener.
   */
  removeEventListener(type, listener) {
    if (!this.listeners_) {
      return;
    }
    const listeners = this.listeners_[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      if (this.pendingRemovals_ && type in this.pendingRemovals_) {
        listeners[index] = VOID;
        ++this.pendingRemovals_[type];
      } else {
        listeners.splice(index, 1);
        if (listeners.length === 0) {
          delete this.listeners_[type];
        }
      }
    }
  }
}
const EventType = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event module:ol/events/Event~BaseEvent#change
   * @api
   */
  CHANGE: "change",
  /**
   * Generic error event. Triggered when an error occurs.
   * @event module:ol/events/Event~BaseEvent#error
   * @api
   */
  ERROR: "error",
  BLUR: "blur",
  CLEAR: "clear",
  CONTEXTMENU: "contextmenu",
  CLICK: "click",
  DBLCLICK: "dblclick",
  DRAGENTER: "dragenter",
  DRAGOVER: "dragover",
  DROP: "drop",
  FOCUS: "focus",
  KEYDOWN: "keydown",
  KEYPRESS: "keypress",
  LOAD: "load",
  RESIZE: "resize",
  TOUCHMOVE: "touchmove",
  WHEEL: "wheel"
};
function listen(target, type, listener, thisArg, once) {
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(thisArg ?? this, arguments);
    };
  } else if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
class Observable extends Target {
  constructor() {
    super();
    this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onInternal;
    this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
    this.onceInternal;
    this.un = /** @type {ObservableOnSignature<void>} */
    this.unInternal;
    this.revision_ = 0;
  }
  /**
   * Increases the revision counter and dispatches a 'change' event.
   * @api
   */
  changed() {
    ++this.revision_;
    this.dispatchEvent(EventType.CHANGE);
  }
  /**
   * Get the version number for this object.  Each time the object is modified,
   * its version number will be incremented.
   * @return {number} Revision.
   * @api
   */
  getRevision() {
    return this.revision_;
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onInternal(type, listener) {
    if (Array.isArray(type)) {
      const len = type.length;
      const keys = new Array(len);
      for (let i = 0; i < len; ++i) {
        keys[i] = listen(this, type[i], listener);
      }
      return keys;
    }
    return listen(
      this,
      /** @type {string} */
      type,
      listener
    );
  }
  /**
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
   * @protected
   */
  onceInternal(type, listener) {
    let key;
    if (Array.isArray(type)) {
      const len = type.length;
      key = new Array(len);
      for (let i = 0; i < len; ++i) {
        key[i] = listenOnce(this, type[i], listener);
      }
    } else {
      key = listenOnce(
        this,
        /** @type {string} */
        type,
        listener
      );
    }
    listener.ol_key = key;
    return key;
  }
  /**
   * Unlisten for a certain type of event.
   * @param {string|Array<string>} type Type.
   * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
   * @protected
   */
  unInternal(type, listener) {
    const key = (
      /** @type {Object} */
      listener.ol_key
    );
    if (key) {
      unByKey(key);
    } else if (Array.isArray(type)) {
      for (let i = 0, ii = type.length; i < ii; ++i) {
        this.removeEventListener(type[i], listener);
      }
    } else {
      this.removeEventListener(type, listener);
    }
  }
}
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
let uidCounter_ = 0;
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
class ObjectEvent extends BaseEvent {
  /**
   * @param {string} type The event type.
   * @param {string} key The property name.
   * @param {*} oldValue The old value for `key`.
   */
  constructor(type, key, oldValue) {
    super(type);
    this.key = key;
    this.oldValue = oldValue;
  }
}
class BaseObject extends Observable {
  /**
   * @param {Object<string, *>} [values] An object with key-value pairs.
   */
  constructor(values) {
    super();
    this.on;
    this.once;
    this.un;
    getUid(this);
    this.values_ = null;
    if (values !== void 0) {
      this.setProperties(values);
    }
  }
  /**
   * Gets a value.
   * @param {string} key Key name.
   * @return {*} Value.
   * @api
   */
  get(key) {
    let value;
    if (this.values_ && this.values_.hasOwnProperty(key)) {
      value = this.values_[key];
    }
    return value;
  }
  /**
   * Get a list of object property names.
   * @return {Array<string>} List of property names.
   * @api
   */
  getKeys() {
    return this.values_ && Object.keys(this.values_) || [];
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>} Object.
   * @api
   */
  getProperties() {
    return this.values_ && Object.assign({}, this.values_) || {};
  }
  /**
   * Get an object of all property names and values.
   * @return {Object<string, *>?} Object.
   */
  getPropertiesInternal() {
    return this.values_;
  }
  /**
   * @return {boolean} The object has properties.
   */
  hasProperties() {
    return !!this.values_;
  }
  /**
   * @param {string} key Key name.
   * @param {*} oldValue Old value.
   */
  notify(key, oldValue) {
    let eventType;
    eventType = `change:${key}`;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
    eventType = ObjectEventType.PROPERTYCHANGE;
    if (this.hasListener(eventType)) {
      this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
    }
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  addChangeListener(key, listener) {
    this.addEventListener(`change:${key}`, listener);
  }
  /**
   * @param {string} key Key name.
   * @param {import("./events.js").Listener} listener Listener.
   */
  removeChangeListener(key, listener) {
    this.removeEventListener(`change:${key}`, listener);
  }
  /**
   * Sets a value.
   * @param {string} key Key name.
   * @param {*} value Value.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  set(key, value, silent) {
    const values = this.values_ || (this.values_ = {});
    if (silent) {
      values[key] = value;
    } else {
      const oldValue = values[key];
      values[key] = value;
      if (oldValue !== value) {
        this.notify(key, oldValue);
      }
    }
  }
  /**
   * Sets a collection of key-value pairs.  Note that this changes any existing
   * properties and adds new ones (it does not remove any existing properties).
   * @param {Object<string, *>} values Values.
   * @param {boolean} [silent] Update without triggering an event.
   * @api
   */
  setProperties(values, silent) {
    for (const key in values) {
      this.set(key, values[key], silent);
    }
  }
  /**
   * Apply any properties from another object without triggering events.
   * @param {BaseObject} source The source object.
   * @protected
   */
  applyProperties(source) {
    if (!source.values_) {
      return;
    }
    Object.assign(this.values_ || (this.values_ = {}), source.values_);
  }
  /**
   * Unsets a property.
   * @param {string} key Key name.
   * @param {boolean} [silent] Unset without triggering an event.
   * @api
   */
  unset(key, silent) {
    if (this.values_ && key in this.values_) {
      const oldValue = this.values_[key];
      delete this.values_[key];
      if (isEmpty$1(this.values_)) {
        this.values_ = null;
      }
      if (!silent) {
        this.notify(key, oldValue);
      }
    }
  }
}
const CollectionEventType = {
  /**
   * Triggered when an item is added to the collection.
   * @event module:ol/Collection.CollectionEvent#add
   * @api
   */
  ADD: "add",
  /**
   * Triggered when an item is removed from the collection.
   * @event module:ol/Collection.CollectionEvent#remove
   * @api
   */
  REMOVE: "remove"
};
const Property$2 = {
  LENGTH: "length"
};
class CollectionEvent extends BaseEvent {
  /**
   * @param {import("./CollectionEventType.js").default} type Type.
   * @param {T} element Element.
   * @param {number} index The index of the added or removed element.
   */
  constructor(type, element, index) {
    super(type);
    this.element = element;
    this.index = index;
  }
}
class Collection extends BaseObject {
  /**
   * @param {Array<T>} [array] Array.
   * @param {Options} [options] Collection options.
   */
  constructor(array, options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options || {};
    this.unique_ = !!options.unique;
    this.array_ = array ? array : [];
    if (this.unique_) {
      for (let i = 0, ii = this.array_.length; i < ii; ++i) {
        this.assertUnique_(this.array_[i], i);
      }
    }
    this.updateLength_();
  }
  /**
   * Remove all elements from the collection.
   * @api
   */
  clear() {
    while (this.getLength() > 0) {
      this.pop();
    }
  }
  /**
   * Add elements to the collection.  This pushes each item in the provided array
   * to the end of the collection.
   * @param {!Array<T>} arr Array.
   * @return {Collection<T>} This collection.
   * @api
   */
  extend(arr) {
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      this.push(arr[i]);
    }
    return this;
  }
  /**
   * Iterate over each element, calling the provided callback.
   * @param {function(T, number, Array<T>): *} f The function to call
   *     for every element. This function takes 3 arguments (the element, the
   *     index and the array). The return value is ignored.
   * @api
   */
  forEach(f) {
    const array = this.array_;
    for (let i = 0, ii = array.length; i < ii; ++i) {
      f(array[i], i, array);
    }
  }
  /**
   * Get a reference to the underlying Array object. Warning: if the array
   * is mutated, no events will be dispatched by the collection, and the
   * collection's "length" property won't be in sync with the actual length
   * of the array.
   * @return {!Array<T>} Array.
   * @api
   */
  getArray() {
    return this.array_;
  }
  /**
   * Get the element at the provided index.
   * @param {number} index Index.
   * @return {T} Element.
   * @api
   */
  item(index) {
    return this.array_[index];
  }
  /**
   * Get the length of this collection.
   * @return {number} The length of the array.
   * @observable
   * @api
   */
  getLength() {
    return this.get(Property$2.LENGTH);
  }
  /**
   * Insert an element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  insertAt(index, elem) {
    if (index < 0 || index > this.getLength()) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    this.array_.splice(index, 0, elem);
    this.updateLength_();
    this.dispatchEvent(
      new CollectionEvent(CollectionEventType.ADD, elem, index)
    );
  }
  /**
   * Remove the last element of the collection and return it.
   * Return `undefined` if the collection is empty.
   * @return {T|undefined} Element.
   * @api
   */
  pop() {
    return this.removeAt(this.getLength() - 1);
  }
  /**
   * Insert the provided element at the end of the collection.
   * @param {T} elem Element.
   * @return {number} New length of the collection.
   * @api
   */
  push(elem) {
    if (this.unique_) {
      this.assertUnique_(elem);
    }
    const n = this.getLength();
    this.insertAt(n, elem);
    return this.getLength();
  }
  /**
   * Remove the first occurrence of an element from the collection.
   * @param {T} elem Element.
   * @return {T|undefined} The removed element or undefined if none found.
   * @api
   */
  remove(elem) {
    const arr = this.array_;
    for (let i = 0, ii = arr.length; i < ii; ++i) {
      if (arr[i] === elem) {
        return this.removeAt(i);
      }
    }
    return void 0;
  }
  /**
   * Remove the element at the provided index and return it.
   * Return `undefined` if the collection does not contain this index.
   * @param {number} index Index.
   * @return {T|undefined} Value.
   * @api
   */
  removeAt(index) {
    if (index < 0 || index >= this.getLength()) {
      return void 0;
    }
    const prev = this.array_[index];
    this.array_.splice(index, 1);
    this.updateLength_();
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType.REMOVE, prev, index)
    );
    return prev;
  }
  /**
   * Set the element at the provided index.
   * @param {number} index Index.
   * @param {T} elem Element.
   * @api
   */
  setAt(index, elem) {
    const n = this.getLength();
    if (index >= n) {
      this.insertAt(index, elem);
      return;
    }
    if (index < 0) {
      throw new Error("Index out of bounds: " + index);
    }
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    const prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType.REMOVE, prev, index)
    );
    this.dispatchEvent(
      /** @type {CollectionEvent<T>} */
      new CollectionEvent(CollectionEventType.ADD, elem, index)
    );
  }
  /**
   * @private
   */
  updateLength_() {
    this.set(Property$2.LENGTH, this.array_.length);
  }
  /**
   * @private
   * @param {T} elem Element.
   * @param {number} [except] Optional index to ignore.
   */
  assertUnique_(elem, except) {
    for (let i = 0, ii = this.array_.length; i < ii; ++i) {
      if (this.array_[i] === elem && i !== except) {
        throw new Error("Duplicate item added to a unique collection");
      }
    }
  }
}
const LayerProperty = {
  OPACITY: "opacity",
  VISIBLE: "visible",
  EXTENT: "extent",
  Z_INDEX: "zIndex",
  MAX_RESOLUTION: "maxResolution",
  MIN_RESOLUTION: "minResolution",
  MAX_ZOOM: "maxZoom",
  MIN_ZOOM: "minZoom",
  SOURCE: "source",
  MAP: "map"
};
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}
class BaseLayer extends BaseObject {
  /**
   * @param {Options} options Layer options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    this.background_ = options.background;
    const properties = Object.assign({}, options);
    if (typeof options.properties === "object") {
      delete properties.properties;
      Object.assign(properties, options.properties);
    }
    properties[LayerProperty.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
    assert(
      typeof properties[LayerProperty.OPACITY] === "number",
      "Layer opacity must be a number"
    );
    properties[LayerProperty.VISIBLE] = options.visible !== void 0 ? options.visible : true;
    properties[LayerProperty.Z_INDEX] = options.zIndex;
    properties[LayerProperty.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
    properties[LayerProperty.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
    properties[LayerProperty.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
    properties[LayerProperty.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
    this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
    delete properties.className;
    this.setProperties(properties);
    this.state_ = null;
  }
  /**
   * Get the background for this layer.
   * @return {BackgroundColor|false} Layer background.
   */
  getBackground() {
    return this.background_;
  }
  /**
   * @return {string} CSS class name.
   */
  getClassName() {
    return this.className_;
  }
  /**
   * This method is not meant to be called by layers or layer renderers because the state
   * is incorrect if the layer is included in a layer group.
   *
   * @param {boolean} [managed] Layer is managed.
   * @return {import("./Layer.js").State} Layer state.
   */
  getLayerState(managed) {
    const state = this.state_ || /** @type {?} */
    {
      layer: this,
      managed: managed === void 0 ? true : managed
    };
    const zIndex = this.getZIndex();
    state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
    state.visible = this.getVisible();
    state.extent = this.getExtent();
    state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
    state.maxResolution = this.getMaxResolution();
    state.minResolution = Math.max(this.getMinResolution(), 0);
    state.minZoom = this.getMinZoom();
    state.maxZoom = this.getMaxZoom();
    this.state_ = state;
    return state;
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
   *     modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    return abstract();
  }
  /**
   * @abstract
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
   *     states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(states) {
    return abstract();
  }
  /**
   * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
   * will be visible regardless of extent.
   * @return {import("../extent.js").Extent|undefined} The layer extent.
   * @observable
   * @api
   */
  getExtent() {
    return (
      /** @type {import("../extent.js").Extent|undefined} */
      this.get(LayerProperty.EXTENT)
    );
  }
  /**
   * Return the maximum resolution of the layer. Returns Infinity if
   * the layer has no maximum resolution set.
   * @return {number} The maximum resolution of the layer.
   * @observable
   * @api
   */
  getMaxResolution() {
    return (
      /** @type {number} */
      this.get(LayerProperty.MAX_RESOLUTION)
    );
  }
  /**
   * Return the minimum resolution of the layer. Returns 0 if
   * the layer has no minimum resolution set.
   * @return {number} The minimum resolution of the layer.
   * @observable
   * @api
   */
  getMinResolution() {
    return (
      /** @type {number} */
      this.get(LayerProperty.MIN_RESOLUTION)
    );
  }
  /**
   * Return the minimum zoom level of the layer. Returns -Infinity if
   * the layer has no minimum zoom set.
   * @return {number} The minimum zoom level of the layer.
   * @observable
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.get(LayerProperty.MIN_ZOOM)
    );
  }
  /**
   * Return the maximum zoom level of the layer. Returns Infinity if
   * the layer has no maximum zoom set.
   * @return {number} The maximum zoom level of the layer.
   * @observable
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.get(LayerProperty.MAX_ZOOM)
    );
  }
  /**
   * Return the opacity of the layer (between 0 and 1).
   * @return {number} The opacity of the layer.
   * @observable
   * @api
   */
  getOpacity() {
    return (
      /** @type {number} */
      this.get(LayerProperty.OPACITY)
    );
  }
  /**
   * @abstract
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return abstract();
  }
  /**
   * Return the value of this layer's `visible` property. To find out whether the layer
   * is visible on a map, use `isVisible()` instead.
   * @return {boolean} The value of the `visible` property of the layer.
   * @observable
   * @api
   */
  getVisible() {
    return (
      /** @type {boolean} */
      this.get(LayerProperty.VISIBLE)
    );
  }
  /**
   * Return the Z-index of the layer, which is used to order layers before
   * rendering. Returns undefined if the layer is unmanaged.
   * @return {number|undefined} The Z-index of the layer.
   * @observable
   * @api
   */
  getZIndex() {
    return (
      /** @type {number|undefined} */
      this.get(LayerProperty.Z_INDEX)
    );
  }
  /**
   * Sets the background color.
   * @param {BackgroundColor} [background] Background color.
   */
  setBackground(background) {
    this.background_ = background;
    this.changed();
  }
  /**
   * Set the extent at which the layer is visible.  If `undefined`, the layer
   * will be visible at all extents.
   * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
   * @observable
   * @api
   */
  setExtent(extent) {
    this.set(LayerProperty.EXTENT, extent);
  }
  /**
   * Set the maximum resolution at which the layer is visible.
   * @param {number} maxResolution The maximum resolution of the layer.
   * @observable
   * @api
   */
  setMaxResolution(maxResolution) {
    this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
  }
  /**
   * Set the minimum resolution at which the layer is visible.
   * @param {number} minResolution The minimum resolution of the layer.
   * @observable
   * @api
   */
  setMinResolution(minResolution) {
    this.set(LayerProperty.MIN_RESOLUTION, minResolution);
  }
  /**
   * Set the maximum zoom (exclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} maxZoom The maximum zoom of the layer.
   * @observable
   * @api
   */
  setMaxZoom(maxZoom) {
    this.set(LayerProperty.MAX_ZOOM, maxZoom);
  }
  /**
   * Set the minimum zoom (inclusive) at which the layer is visible.
   * Note that the zoom levels for layer visibility are based on the
   * view zoom level, which may be different from a tile source zoom level.
   * @param {number} minZoom The minimum zoom of the layer.
   * @observable
   * @api
   */
  setMinZoom(minZoom) {
    this.set(LayerProperty.MIN_ZOOM, minZoom);
  }
  /**
   * Set the opacity of the layer, allowed values range from 0 to 1.
   * @param {number} opacity The opacity of the layer.
   * @observable
   * @api
   */
  setOpacity(opacity) {
    assert(typeof opacity === "number", "Layer opacity must be a number");
    this.set(LayerProperty.OPACITY, opacity);
  }
  /**
   * Set the visibility of the layer (`true` or `false`).
   * @param {boolean} visible The visibility of the layer.
   * @observable
   * @api
   */
  setVisible(visible) {
    this.set(LayerProperty.VISIBLE, visible);
  }
  /**
   * Set Z-index of the layer, which is used to order layers before rendering.
   * The default Z-index is 0.
   * @param {number} zindex The z-index of the layer.
   * @observable
   * @api
   */
  setZIndex(zindex) {
    this.set(LayerProperty.Z_INDEX, zindex);
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.state_) {
      this.state_.layer = null;
      this.state_ = null;
    }
    super.disposeInternal();
  }
}
const RenderEventType = {
  /**
   * Triggered before a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#prerender
   * @api
   */
  PRERENDER: "prerender",
  /**
   * Triggered after a layer is rendered.
   * @event module:ol/render/Event~RenderEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered before layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#precompose
   * @api
   */
  PRECOMPOSE: "precompose",
  /**
   * Triggered after layers are composed.  When dispatched by the map, the event object will not have
   * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
   * WebGL layers currently dispatch this event.
   * @event module:ol/render/Event~RenderEvent#postcompose
   * @api
   */
  POSTCOMPOSE: "postcompose",
  /**
   * Triggered when rendering is complete, i.e. all sources and tiles have
   * finished loading for the current viewport, and all tiles are faded in.
   * The event object will not have a `context` set.
   * @event module:ol/render/Event~RenderEvent#rendercomplete
   * @api
   */
  RENDERCOMPLETE: "rendercomplete"
};
const ViewHint = {
  ANIMATING: 0,
  INTERACTING: 1
};
const ViewProperty = {
  CENTER: "center",
  RESOLUTION: "resolution",
  ROTATION: "rotation"
};
const DEFAULT_MAX_ZOOM = 42;
const DEFAULT_TILE_SIZE = 256;
const METERS_PER_UNIT$1 = {
  // use the radius of the Normal sphere
  "radians": 6370997 / (2 * Math.PI),
  "degrees": 2 * Math.PI * 6370997 / 360,
  "ft": 0.3048,
  "m": 1,
  "us-ft": 1200 / 3937
};
class Projection {
  /**
   * @param {Options} options Projection options.
   */
  constructor(options) {
    this.code_ = options.code;
    this.units_ = /** @type {import("./Units.js").Units} */
    options.units;
    this.extent_ = options.extent !== void 0 ? options.extent : null;
    this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
    this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
    this.global_ = options.global !== void 0 ? options.global : false;
    this.canWrapX_ = !!(this.global_ && this.extent_);
    this.getPointResolutionFunc_ = options.getPointResolution;
    this.defaultTileGrid_ = null;
    this.metersPerUnit_ = options.metersPerUnit;
  }
  /**
   * @return {boolean} The projection is suitable for wrapping the x-axis
   */
  canWrapX() {
    return this.canWrapX_;
  }
  /**
   * Get the code for this projection, e.g. 'EPSG:4326'.
   * @return {string} Code.
   * @api
   */
  getCode() {
    return this.code_;
  }
  /**
   * Get the validity extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the units of this projection.
   * @return {import("./Units.js").Units} Units.
   * @api
   */
  getUnits() {
    return this.units_;
  }
  /**
   * Get the amount of meters per unit of this projection.  If the projection is
   * not configured with `metersPerUnit` or a units identifier, the return is
   * `undefined`.
   * @return {number|undefined} Meters.
   * @api
   */
  getMetersPerUnit() {
    return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_];
  }
  /**
   * Get the world extent for this projection.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getWorldExtent() {
    return this.worldExtent_;
  }
  /**
   * Get the axis orientation of this projection.
   * Example values are:
   * enu - the default easting, northing, elevation.
   * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
   *     or south orientated transverse mercator.
   * wnu - westing, northing, up - some planetary coordinate systems have
   *     "west positive" coordinate systems
   * @return {string} Axis orientation.
   * @api
   */
  getAxisOrientation() {
    return this.axisOrientation_;
  }
  /**
   * Is this projection a global projection which spans the whole world?
   * @return {boolean} Whether the projection is global.
   * @api
   */
  isGlobal() {
    return this.global_;
  }
  /**
   * Set if the projection is a global projection which spans the whole world
   * @param {boolean} global Whether the projection is global.
   * @api
   */
  setGlobal(global) {
    this.global_ = global;
    this.canWrapX_ = !!(global && this.extent_);
  }
  /**
   * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
   */
  getDefaultTileGrid() {
    return this.defaultTileGrid_;
  }
  /**
   * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
   */
  setDefaultTileGrid(tileGrid) {
    this.defaultTileGrid_ = tileGrid;
  }
  /**
   * Set the validity extent for this projection.
   * @param {import("../extent.js").Extent} extent Extent.
   * @api
   */
  setExtent(extent) {
    this.extent_ = extent;
    this.canWrapX_ = !!(this.global_ && extent);
  }
  /**
   * Set the world extent for this projection.
   * @param {import("../extent.js").Extent} worldExtent World extent
   *     [minlon, minlat, maxlon, maxlat].
   * @api
   */
  setWorldExtent(worldExtent) {
    this.worldExtent_ = worldExtent;
  }
  /**
   * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
   * for this projection.
   * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
   * @api
   */
  setGetPointResolution(func) {
    this.getPointResolutionFunc_ = func;
  }
  /**
   * Get the custom point resolution function for this projection (if set).
   * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
   * resolution function (if set).
   */
  getPointResolutionFunc() {
    return this.getPointResolutionFunc_;
  }
}
const RADIUS$1 = 6378137;
const HALF_SIZE = Math.PI * RADIUS$1;
const EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
const WORLD_EXTENT = [-180, -85, 180, 85];
const MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
class EPSG3857Projection extends Projection {
  /**
   * @param {string} code Code.
   */
  constructor(code) {
    super({
      code,
      units: "m",
      extent: EXTENT$1,
      global: true,
      worldExtent: WORLD_EXTENT,
      getPointResolution: function(resolution, point) {
        return resolution / Math.cosh(point[1] / RADIUS$1);
      }
    });
  }
}
const PROJECTIONS$1 = [
  new EPSG3857Projection("EPSG:3857"),
  new EPSG3857Projection("EPSG:102100"),
  new EPSG3857Projection("EPSG:102113"),
  new EPSG3857Projection("EPSG:900913"),
  new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
  new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
];
function fromEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS$1 * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension, stride) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  stride = stride ?? dimension;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += stride) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS$1)) / Math.PI - 90;
  }
  return output;
}
const RADIUS = 6378137;
const EXTENT = [-180, -90, 180, 90];
const METERS_PER_UNIT = Math.PI * RADIUS / 180;
class EPSG4326Projection extends Projection {
  /**
   * @param {string} code Code.
   * @param {string} [axisOrientation] Axis orientation.
   */
  constructor(code, axisOrientation) {
    super({
      code,
      units: "degrees",
      extent: EXTENT,
      axisOrientation,
      global: true,
      metersPerUnit: METERS_PER_UNIT,
      worldExtent: EXTENT
    });
  }
}
const PROJECTIONS = [
  new EPSG4326Projection("CRS:84"),
  new EPSG4326Projection("EPSG:4326", "neu"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
  new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
  new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
  new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
];
let cache$1 = {};
function get$3(code) {
  return cache$1[code] || cache$1[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add$2(code, projection) {
  cache$1[code] = projection;
}
let transforms = {};
function add$1(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function get$2(sourceCode, destinationCode) {
  let transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}
const Relationship = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship.ABOVE;
  }
  if (relationship === Relationship.UNKNOWN) {
    relationship = Relationship.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate$2(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate$2(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate$2(x, y, x, y, dest);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
}
function equals$1(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function extend$1(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate$2(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects$1(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects$1(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function intersectsSegment(extent, start, end) {
  let intersects2 = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship.INTERSECTING || endRel === Relationship.INTERSECTING) {
    intersects2 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.RIGHT) && !(startRel & Relationship.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
    if (!intersects2 && !!(endRel & Relationship.BELOW) && !(startRel & Relationship.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects2 = x >= minX && x <= maxX;
    }
    if (!intersects2 && !!(endRel & Relationship.LEFT) && !(startRel & Relationship.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects2 = y >= minY && y <= maxY;
    }
  }
  return intersects2;
}
function wrapX$2(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset = worldsAway * worldWidth;
    extent[0] -= offset;
    extent[2] -= offset;
  }
  return extent;
}
function wrapAndSliceX(extent, projection, multiWorld) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX$2(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth && !multiWorld) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}
function add(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function equals(coordinate1, coordinate2) {
  let equals2 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals2 = false;
      break;
    }
  }
  return equals2;
}
function rotate$1(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
function scale$2(coordinate, scale2) {
  coordinate[0] *= scale2;
  coordinate[1] *= scale2;
  return coordinate;
}
function wrapX$1(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}
const DEFAULT_RADIUS = 63710088e-1;
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function warn(...args) {
  console.warn(...args);
}
let showCoordinateWarning = true;
function disableCoordinateWarning(disable2) {
  const hide = true;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output) {
  if (output !== void 0 && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add$2(projection.getCode(), projection);
  add$1(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get$1(projectionLike) {
  return typeof projectionLike === "string" ? get$3(
    /** @type {string} */
    projectionLike
  ) : (
    /** @type {Projection} */
    projectionLike || null
  );
}
function getPointResolution(projection, resolution, point, units) {
  projection = get$1(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get$1("EPSG:4326")
      );
      if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add$1(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add$1(projection1, projection2, forwardTransform);
      add$1(projection2, projection1, inverseTransform);
    });
  });
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get$1(defaultCode);
  }
  if (typeof projection === "string") {
    return get$1(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get$2(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  const sourceProjection = get$1(source);
  const destinationProjection = get$1(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function toUserCoordinate(coordinate, sourceProjection) {
  {
    return coordinate;
  }
}
function fromUserCoordinate(coordinate, destProjection) {
  {
    if (showCoordinateWarning && !equals(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
}
function toUserExtent(extent, sourceProjection) {
  {
    return extent;
  }
}
function fromUserExtent(extent, destProjection) {
  {
    return extent;
  }
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS$1);
  addEquivalentProjections(PROJECTIONS);
  addEquivalentTransforms(
    PROJECTIONS,
    PROJECTIONS$1,
    fromEPSG4326,
    toEPSG4326
  );
}
addCommon();
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none$1(center) {
  return center;
}
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t = toRadians(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
  return t;
}
new Array(6);
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function apply(transform2, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
const matrixPrecision = [1e6, 1e6, 1e6, 1e6, 2, 2];
function toString$1(mat) {
  const transformString = "matrix(" + mat.map(
    (value, i) => Math.round(value * matrixPrecision[i]) / matrixPrecision[i]
  ).join(", ") + ")";
  return transformString;
}
function transform2D(flatCoordinates, offset, end, stride, transform2, dest, destinationStride) {
  dest = dest ? dest : [];
  destinationStride = destinationStride ? destinationStride : 2;
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
    for (let k = 2; k < destinationStride; k++) {
      dest[i++] = flatCoordinates[j + k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate(flatCoordinates, offset, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale$1(flatCoordinates, offset, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
const tmpTransform = create();
class Geometry extends BaseObject {
  constructor() {
    super();
    this.extent_ = createEmpty();
    this.extentRevision_ = -1;
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = 0;
    this.simplifyTransformedInternal = memoizeOne(
      (revision, squaredTolerance, transform2) => {
        if (!transform2) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        const clone2 = this.clone();
        clone2.applyTransform(transform2);
        return clone2.getSimplifiedGeometry(squaredTolerance);
      }
    );
  }
  /**
   * Get a transformed and simplified version of the geometry.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
   * @return {Geometry} Simplified geometry.
   */
  simplifyTransformed(squaredTolerance, transform2) {
    return this.simplifyTransformedInternal(
      this.getRevision(),
      squaredTolerance,
      transform2
    );
  }
  /**
   * Make a complete copy of the geometry.
   * @abstract
   * @return {!Geometry} Clone.
   */
  clone() {
    return abstract();
  }
  /**
   * @abstract
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    return abstract();
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  containsXY(x, y) {
    const coord = this.getClosestPoint([x, y]);
    return coord[0] === x && coord[1] === y;
  }
  /**
   * Return the closest point of the geometry to the passed point as
   * {@link module:ol/coordinate~Coordinate coordinate}.
   * @param {import("../coordinate.js").Coordinate} point Point.
   * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
   * @return {import("../coordinate.js").Coordinate} Closest point.
   * @api
   */
  getClosestPoint(point, closestPoint) {
    closestPoint = closestPoint ? closestPoint : [NaN, NaN];
    this.closestPointXY(point[0], point[1], closestPoint, Infinity);
    return closestPoint;
  }
  /**
   * Returns true if this geometry includes the specified coordinate. If the
   * coordinate is on the boundary of the geometry, returns false.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} Contains coordinate.
   * @api
   */
  intersectsCoordinate(coordinate) {
    return this.containsXY(coordinate[0], coordinate[1]);
  }
  /**
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   */
  computeExtent(extent) {
    return abstract();
  }
  /**
   * Get the extent of the geometry.
   * @param {import("../extent.js").Extent} [extent] Extent.
   * @return {import("../extent.js").Extent} extent Extent.
   * @api
   */
  getExtent(extent) {
    if (this.extentRevision_ != this.getRevision()) {
      const extent2 = this.computeExtent(this.extent_);
      if (isNaN(extent2[0]) || isNaN(extent2[1])) {
        createOrUpdateEmpty(extent2);
      }
      this.extentRevision_ = this.getRevision();
    }
    return returnOrUpdate(this.extent_, extent);
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} angle Rotation angle in radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   */
  rotate(angle, anchor) {
    abstract();
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @abstract
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   */
  scale(sx, sy, anchor) {
    abstract();
  }
  /**
   * Create a simplified version of this geometry.  For linestrings, this uses
   * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
   * algorithm.  For polygons, a quantization-based
   * simplification is used to preserve topology.
   * @param {number} tolerance The tolerance distance for simplification.
   * @return {Geometry} A new, simplified version of the original geometry.
   * @api
   */
  simplify(tolerance) {
    return this.getSimplifiedGeometry(tolerance * tolerance);
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker
   * algorithm.
   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
   * @abstract
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Geometry} Simplified geometry.
   */
  getSimplifiedGeometry(squaredTolerance) {
    return abstract();
  }
  /**
   * Get the type of this geometry.
   * @abstract
   * @return {Type} Geometry type.
   */
  getType() {
    return abstract();
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @abstract
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   */
  applyTransform(transformFn) {
    abstract();
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @abstract
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   */
  intersectsExtent(extent) {
    return abstract();
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @abstract
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   */
  translate(deltaX, deltaY) {
    abstract();
  }
  /**
   * Transform each coordinate of the geometry from one coordinate reference
   * system to another. The geometry is modified in place.
   * For example, a line will be transformed to a line and a circle to a circle.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   *
   * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
   * @return {this} This geometry.  Note that original geometry is
   *     modified in place.
   * @api
   */
  transform(source, destination) {
    const sourceProj = get$1(source);
    const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
      const pixelExtent = sourceProj.getExtent();
      const projectedExtent = sourceProj.getWorldExtent();
      const scale2 = getHeight(projectedExtent) / getHeight(pixelExtent);
      compose(
        tmpTransform,
        projectedExtent[0],
        projectedExtent[3],
        scale2,
        -scale2,
        0,
        0,
        0
      );
      transform2D(
        inCoordinates,
        0,
        inCoordinates.length,
        stride,
        tmpTransform,
        outCoordinates
      );
      return getTransform(sourceProj, destination)(
        inCoordinates,
        outCoordinates,
        stride
      );
    } : getTransform(sourceProj, destination);
    this.applyTransform(transformFn);
    return this;
  }
}
class SimpleGeometry extends Geometry {
  constructor() {
    super();
    this.layout = "XY";
    this.stride = 2;
    this.flatCoordinates;
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return createOrUpdateFromFlatCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      extent
    );
  }
  /**
   * @abstract
   * @return {Array<*> | null} Coordinates.
   */
  getCoordinates() {
    return abstract();
  }
  /**
   * Return the first coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} First coordinate.
   * @api
   */
  getFirstCoordinate() {
    return this.flatCoordinates.slice(0, this.stride);
  }
  /**
   * @return {Array<number>} Flat coordinates.
   */
  getFlatCoordinates() {
    return this.flatCoordinates;
  }
  /**
   * Return the last coordinate of the geometry.
   * @return {import("../coordinate.js").Coordinate} Last point.
   * @api
   */
  getLastCoordinate() {
    return this.flatCoordinates.slice(
      this.flatCoordinates.length - this.stride
    );
  }
  /**
   * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
   * @return {import("./Geometry.js").GeometryLayout} Layout.
   * @api
   */
  getLayout() {
    return this.layout;
  }
  /**
   * Create a simplified version of this geometry using the Douglas Peucker algorithm.
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @override
   */
  getSimplifiedGeometry(squaredTolerance) {
    if (this.simplifiedGeometryRevision !== this.getRevision()) {
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = this.getRevision();
    }
    if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
      return this;
    }
    const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      return simplifiedGeometry;
    }
    this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
    return this;
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {SimpleGeometry} Simplified geometry.
   * @protected
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    return this;
  }
  /**
   * @return {number} Stride.
   */
  getStride() {
    return this.stride;
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout} layout Layout.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   */
  setFlatCoordinates(layout, flatCoordinates) {
    this.stride = getStrideForLayout(layout);
    this.layout = layout;
    this.flatCoordinates = flatCoordinates;
  }
  /**
   * @abstract
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  setCoordinates(coordinates2, layout) {
    abstract();
  }
  /**
   * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
   * @param {Array<*>} coordinates Coordinates.
   * @param {number} nesting Nesting.
   * @protected
   */
  setLayout(layout, coordinates2, nesting) {
    let stride;
    if (layout) {
      stride = getStrideForLayout(layout);
    } else {
      for (let i = 0; i < nesting; ++i) {
        if (coordinates2.length === 0) {
          this.layout = "XY";
          this.stride = 2;
          return;
        }
        coordinates2 = /** @type {Array<unknown>} */
        coordinates2[0];
      }
      stride = coordinates2.length;
      layout = getLayoutForStride(stride);
    }
    this.layout = layout;
    this.stride = stride;
  }
  /**
   * Apply a transform function to the coordinates of the geometry.
   * The geometry is modified in place.
   * If you do not want the geometry modified in place, first `clone()` it and
   * then use this function on the clone.
   * @param {import("../proj.js").TransformFunction} transformFn Transform function.
   * Called with a flat array of geometry coordinates.
   * @api
   * @override
   */
  applyTransform(transformFn) {
    if (this.flatCoordinates) {
      transformFn(
        this.flatCoordinates,
        this.flatCoordinates,
        this.layout.startsWith("XYZ") ? 3 : 2,
        this.stride
      );
      this.changed();
    }
  }
  /**
   * Rotate the geometry around a given coordinate. This modifies the geometry
   * coordinates in place.
   * @param {number} angle Rotation angle in counter-clockwise radians.
   * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
   * @api
   * @override
   */
  rotate(angle, anchor) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      rotate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        angle,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Scale the geometry (with an optional origin).  This modifies the geometry
   * coordinates in place.
   * @param {number} sx The scaling factor in the x-direction.
   * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
   * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
   *     of the geometry extent).
   * @api
   * @override
   */
  scale(sx, sy, anchor) {
    if (sy === void 0) {
      sy = sx;
    }
    if (!anchor) {
      anchor = getCenter(this.getExtent());
    }
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      scale$1(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        sx,
        sy,
        anchor,
        flatCoordinates
      );
      this.changed();
    }
  }
  /**
   * Translate the geometry.  This modifies the geometry coordinates in place.  If
   * instead you want a new geometry, first `clone()` this geometry.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @api
   * @override
   */
  translate(deltaX, deltaY) {
    const flatCoordinates = this.getFlatCoordinates();
    if (flatCoordinates) {
      const stride = this.getStride();
      translate(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        deltaX,
        deltaY,
        flatCoordinates
      );
      this.changed();
    }
  }
}
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
  let x1 = flatCoordinates[offset];
  let y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
    offset = end;
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance$1;
  if (maxDelta === 0) {
    squaredDistance$1 = squaredDistance(
      x,
      y,
      flatCoordinates[offset],
      flatCoordinates[offset + 1]
    );
    if (squaredDistance$1 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance$1;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance$1 < minSquaredDistance) {
      minSquaredDistance = squaredDistance$1;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance$1) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance$1 < minSquaredDistance) {
      minSquaredDistance = squaredDistance$1;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset = end;
  }
  return minSquaredDistance;
}
function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
}
function deflateCoordinates(flatCoordinates, offset, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
}
function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
}
function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance2 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance2 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance2;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset], tolerance);
  let y1 = snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset], tolerance);
    y2 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    const x3 = snap(flatCoordinates[offset], tolerance);
    const y3 = snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
}
function inflateCoordinates(flatCoordinates, offset, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset,
      end,
      stride,
      coordinatess[i]
    );
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function linearRing(flatCoordinates, offset, end, stride) {
  let twiceArea = 0;
  const x0 = flatCoordinates[end - stride];
  const y0 = flatCoordinates[end - stride + 1];
  let dx1 = 0;
  let dy1 = 0;
  for (; offset < end; offset += stride) {
    const dx2 = flatCoordinates[offset] - x0;
    const dy2 = flatCoordinates[offset + 1] - y0;
    twiceArea += dy1 * dx2 - dx1 * dy2;
    dx1 = dx2;
    dy1 = dy2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
}
class LinearRing extends SimpleGeometry {
  /**
   * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
   *     For internal use, flat coordinates in combination with `layout` are also accepted.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
    } else {
      this.setCoordinates(
        /** @type {Array<import("../coordinate.js").Coordinate>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!LinearRing} Clone.
   * @api
   * @override
   */
  clone() {
    return new LinearRing(this.flatCoordinates.slice(), this.layout);
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        maxSquaredDelta(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestPoint(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * Return the area of the linear ring on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRing(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * Return the coordinates of the linear ring.
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return inflateCoordinates(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {LinearRing} Simplified LinearRing.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    simplifiedFlatCoordinates.length = douglasPeucker(
      this.flatCoordinates,
      0,
      this.flatCoordinates.length,
      this.stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    return new LinearRing(simplifiedFlatCoordinates, "XY");
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "LinearRing";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return false;
  }
  /**
   * Set the coordinates of the linear ring.
   * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinates(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
}
class Point extends SimpleGeometry {
  /**
   * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   */
  constructor(coordinates2, layout) {
    super();
    this.setCoordinates(coordinates2, layout);
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Point} Clone.
   * @api
   * @override
   */
  clone() {
    const point = new Point(this.flatCoordinates.slice(), this.layout);
    point.applyProperties(this);
    return point;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    const flatCoordinates = this.flatCoordinates;
    const squaredDistance$1 = squaredDistance(
      x,
      y,
      flatCoordinates[0],
      flatCoordinates[1]
    );
    if (squaredDistance$1 < minSquaredDistance) {
      const stride = this.stride;
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[i];
      }
      closestPoint.length = stride;
      return squaredDistance$1;
    }
    return minSquaredDistance;
  }
  /**
   * Return the coordinate of the point.
   * @return {import("../coordinate.js").Coordinate} Coordinates.
   * @api
   * @override
   */
  getCoordinates() {
    return this.flatCoordinates.slice();
  }
  /**
   * @param {import("../extent.js").Extent} extent Extent.
   * @protected
   * @return {import("../extent.js").Extent} extent Extent.
   * @override
   */
  computeExtent(extent) {
    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Point";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
  }
  /**
   * @param {!Array<*>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflateCoordinate(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride
    );
    this.changed();
  }
}
function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}
function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  return [pointX, y, maxSegmentLength];
}
function forEach(flatCoordinates, offset, end, stride, callback) {
  let ret;
  offset += stride;
  for (; offset < end; offset += stride) {
    ret = callback(
      flatCoordinates.slice(offset - stride, offset),
      flatCoordinates.slice(offset, offset + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}
function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
  const coordinatesExtent = extendFlatCoordinates(
    createEmpty(),
    flatCoordinates,
    offset,
    end,
    stride
  );
  if (!intersects$1(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}
function coordinates(flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
}
function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    const x2 = flatCoordinates[offset];
    const y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
}
class Polygon extends SimpleGeometry {
  /**
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
   *     Array of linear rings that define the polygon. The first linear ring of the
   *     array defines the outer-boundary or surface of the polygon. Each subsequent
   *     linear ring defines a hole in the surface of the polygon. A linear ring is
   *     an array of vertices' coordinates where the first coordinate and the last are
   *     equivalent. (For internal use, flat coordinates in combination with
   *     `layout` and `ends` are also accepted.)
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
   */
  constructor(coordinates2, layout, ends) {
    super();
    this.ends_ = [];
    this.flatInteriorPointRevision_ = -1;
    this.flatInteriorPoint_ = null;
    this.maxDelta_ = -1;
    this.maxDeltaRevision_ = -1;
    this.orientedRevision_ = -1;
    this.orientedFlatCoordinates_ = null;
    if (layout !== void 0 && ends) {
      this.setFlatCoordinates(
        layout,
        /** @type {Array<number>} */
        coordinates2
      );
      this.ends_ = ends;
    } else {
      this.setCoordinates(
        /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
        coordinates2,
        layout
      );
    }
  }
  /**
   * Append the passed linear ring to this polygon.
   * @param {LinearRing} linearRing Linear ring.
   * @api
   */
  appendLinearRing(linearRing2) {
    if (!this.flatCoordinates) {
      this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
    } else {
      extend$2(this.flatCoordinates, linearRing2.getFlatCoordinates());
    }
    this.ends_.push(this.flatCoordinates.length);
    this.changed();
  }
  /**
   * Make a complete copy of the geometry.
   * @return {!Polygon} Clone.
   * @api
   * @override
   */
  clone() {
    const polygon = new Polygon(
      this.flatCoordinates.slice(),
      this.layout,
      this.ends_.slice()
    );
    polygon.applyProperties(this);
    return polygon;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @return {number} Minimum squared distance.
   * @override
   */
  closestPointXY(x, y, closestPoint, minSquaredDistance) {
    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
      return minSquaredDistance;
    }
    if (this.maxDeltaRevision_ != this.getRevision()) {
      this.maxDelta_ = Math.sqrt(
        arrayMaxSquaredDelta(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          0
        )
      );
      this.maxDeltaRevision_ = this.getRevision();
    }
    return assignClosestArrayPoint(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      this.maxDelta_,
      true,
      x,
      y,
      closestPoint,
      minSquaredDistance
    );
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   * @override
   */
  containsXY(x, y) {
    return linearRingsContainsXY(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      x,
      y
    );
  }
  /**
   * Return the area of the polygon on projected plane.
   * @return {number} Area (on projected plane).
   * @api
   */
  getArea() {
    return linearRings(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride
    );
  }
  /**
   * Get the coordinate array for this geometry.  This array has the structure
   * of a GeoJSON coordinate array for polygons.
   *
   * @param {boolean} [right] Orient coordinates according to the right-hand
   *     rule (counter-clockwise for exterior and clockwise for interior rings).
   *     If `false`, coordinates will be oriented according to the left-hand rule
   *     (clockwise for exterior and counter-clockwise for interior rings).
   *     By default, coordinate orientation will depend on how the geometry was
   *     constructed.
   * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
   * @api
   * @override
   */
  getCoordinates(right) {
    let flatCoordinates;
    if (right !== void 0) {
      flatCoordinates = this.getOrientedFlatCoordinates().slice();
      orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
    } else {
      flatCoordinates = this.flatCoordinates;
    }
    return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
  }
  /**
   * @return {Array<number>} Ends.
   */
  getEnds() {
    return this.ends_;
  }
  /**
   * @return {Array<number>} Interior point.
   */
  getFlatInteriorPoint() {
    if (this.flatInteriorPointRevision_ != this.getRevision()) {
      const flatCenter = getCenter(this.getExtent());
      this.flatInteriorPoint_ = getInteriorPointOfArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        flatCenter,
        0
      );
      this.flatInteriorPointRevision_ = this.getRevision();
    }
    return (
      /** @type {import("../coordinate.js").Coordinate} */
      this.flatInteriorPoint_
    );
  }
  /**
   * Return an interior point of the polygon.
   * @return {Point} Interior point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   * @api
   */
  getInteriorPoint() {
    return new Point(this.getFlatInteriorPoint(), "XYM");
  }
  /**
   * Return the number of rings of the polygon,  this includes the exterior
   * ring and any interior rings.
   *
   * @return {number} Number of rings.
   * @api
   */
  getLinearRingCount() {
    return this.ends_.length;
  }
  /**
   * Return the Nth linear ring of the polygon geometry. Return `null` if the
   * given index is out of range.
   * The exterior linear ring is available at index `0` and the interior rings
   * at index `1` and beyond.
   *
   * @param {number} index Index.
   * @return {LinearRing|null} Linear ring.
   * @api
   */
  getLinearRing(index) {
    if (index < 0 || this.ends_.length <= index) {
      return null;
    }
    return new LinearRing(
      this.flatCoordinates.slice(
        index === 0 ? 0 : this.ends_[index - 1],
        this.ends_[index]
      ),
      this.layout
    );
  }
  /**
   * Return the linear rings of the polygon.
   * @return {Array<LinearRing>} Linear rings.
   * @api
   */
  getLinearRings() {
    const layout = this.layout;
    const flatCoordinates = this.flatCoordinates;
    const ends = this.ends_;
    const linearRings2 = [];
    let offset = 0;
    for (let i = 0, ii = ends.length; i < ii; ++i) {
      const end = ends[i];
      const linearRing2 = new LinearRing(
        flatCoordinates.slice(offset, end),
        layout
      );
      linearRings2.push(linearRing2);
      offset = end;
    }
    return linearRings2;
  }
  /**
   * @return {Array<number>} Oriented flat coordinates.
   */
  getOrientedFlatCoordinates() {
    if (this.orientedRevision_ != this.getRevision()) {
      const flatCoordinates = this.flatCoordinates;
      if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
        this.orientedFlatCoordinates_ = flatCoordinates;
      } else {
        this.orientedFlatCoordinates_ = flatCoordinates.slice();
        this.orientedFlatCoordinates_.length = orientLinearRings(
          this.orientedFlatCoordinates_,
          0,
          this.ends_,
          this.stride
        );
      }
      this.orientedRevision_ = this.getRevision();
    }
    return (
      /** @type {Array<number>} */
      this.orientedFlatCoordinates_
    );
  }
  /**
   * @param {number} squaredTolerance Squared tolerance.
   * @return {Polygon} Simplified Polygon.
   * @protected
   * @override
   */
  getSimplifiedGeometryInternal(squaredTolerance) {
    const simplifiedFlatCoordinates = [];
    const simplifiedEnds = [];
    simplifiedFlatCoordinates.length = quantizeArray(
      this.flatCoordinates,
      0,
      this.ends_,
      this.stride,
      Math.sqrt(squaredTolerance),
      simplifiedFlatCoordinates,
      0,
      simplifiedEnds
    );
    return new Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
  }
  /**
   * Get the type of this geometry.
   * @return {import("./Geometry.js").Type} Geometry type.
   * @api
   * @override
   */
  getType() {
    return "Polygon";
  }
  /**
   * Test if the geometry and the passed extent intersect.
   * @param {import("../extent.js").Extent} extent Extent.
   * @return {boolean} `true` if the geometry and the extent intersect.
   * @api
   * @override
   */
  intersectsExtent(extent) {
    return intersectsLinearRingArray(
      this.getOrientedFlatCoordinates(),
      0,
      this.ends_,
      this.stride,
      extent
    );
  }
  /**
   * Set the coordinates of the polygon.
   * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
   * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
   * @api
   * @override
   */
  setCoordinates(coordinates2, layout) {
    this.setLayout(layout, coordinates2, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    const ends = deflateCoordinatesArray(
      this.flatCoordinates,
      0,
      coordinates2,
      this.stride,
      this.ends_
    );
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
}
function fromExtent(extent) {
  if (isEmpty(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
const DEFAULT_MIN_ZOOM = 0;
class View extends BaseObject {
  /**
   * @param {ViewOptions} [options] View options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = Object.assign({}, options);
    this.hints_ = [0, 0];
    this.animations_ = [];
    this.updateAnimationKey_;
    this.projection_ = createProjection(options.projection, "EPSG:3857");
    this.viewportSize_ = [100, 100];
    this.targetCenter_ = null;
    this.targetResolution_;
    this.targetRotation_;
    this.nextCenter_ = null;
    this.nextResolution_;
    this.nextRotation_;
    this.cancelAnchor_ = void 0;
    if (options.projection) {
      disableCoordinateWarning();
    }
    if (options.center) {
      options.center = fromUserCoordinate(options.center, this.projection_);
    }
    if (options.extent) {
      options.extent = fromUserExtent(options.extent, this.projection_);
    }
    this.applyOptions_(options);
  }
  /**
   * Set up the view with the given options.
   * @param {ViewOptions} options View options.
   */
  applyOptions_(options) {
    const properties = Object.assign({}, options);
    for (const key in ViewProperty) {
      delete properties[key];
    }
    this.setProperties(properties, true);
    const resolutionConstraintInfo = createResolutionConstraint(options);
    this.maxResolution_ = resolutionConstraintInfo.maxResolution;
    this.minResolution_ = resolutionConstraintInfo.minResolution;
    this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
    this.resolutions_ = options.resolutions;
    this.padding_ = options.padding;
    this.minZoom_ = resolutionConstraintInfo.minZoom;
    const centerConstraint = createCenterConstraint(options);
    const resolutionConstraint = resolutionConstraintInfo.constraint;
    const rotationConstraint = createRotationConstraint(options);
    this.constraints_ = {
      center: centerConstraint,
      resolution: resolutionConstraint,
      rotation: rotationConstraint
    };
    this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
    this.setCenterInternal(
      options.center !== void 0 ? options.center : null
    );
    if (options.resolution !== void 0) {
      this.setResolution(options.resolution);
    } else if (options.zoom !== void 0) {
      this.setZoom(options.zoom);
    }
  }
  /**
   * Padding (in css pixels).
   * If the map viewport is partially covered with other content (overlays) along
   * its edges, this setting allows to shift the center of the viewport away from that
   * content. The order of the values in the array is top, right, bottom, left.
   * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
   * @type {Array<number>|undefined}
   * @api
   */
  get padding() {
    return this.padding_;
  }
  set padding(padding) {
    let oldPadding = this.padding_;
    this.padding_ = padding;
    const center = this.getCenterInternal();
    if (center) {
      const newPadding = padding || [0, 0, 0, 0];
      oldPadding = oldPadding || [0, 0, 0, 0];
      const resolution = this.getResolution();
      const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
      const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
      this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
    }
  }
  /**
   * Get an updated version of the view options used to construct the view.  The
   * current resolution (or zoom), center, and rotation are applied to any stored
   * options.  The provided options can be used to apply new min/max zoom or
   * resolution limits.
   * @param {ViewOptions} newOptions New options to be applied.
   * @return {ViewOptions} New options updated with the current view state.
   */
  getUpdatedOptions_(newOptions) {
    const options = this.getProperties();
    if (options.resolution !== void 0) {
      options.resolution = this.getResolution();
    } else {
      options.zoom = this.getZoom();
    }
    options.center = this.getCenterInternal();
    options.rotation = this.getRotation();
    return Object.assign({}, options, newOptions);
  }
  /**
   * Animate the view.  The view's center, zoom (or resolution), and rotation
   * can be animated for smooth transitions between view states.  For example,
   * to animate the view to a new zoom level:
   *
   *     view.animate({zoom: view.getZoom() + 1});
   *
   * By default, the animation lasts one second and uses in-and-out easing.  You
   * can customize this behavior by including `duration` (in milliseconds) and
   * `easing` options (see {@link module:ol/easing}).
   *
   * To chain together multiple animations, call the method with multiple
   * animation objects.  For example, to first zoom and then pan:
   *
   *     view.animate({zoom: 10}, {center: [0, 0]});
   *
   * If you provide a function as the last argument to the animate method, it
   * will get called at the end of an animation series.  The callback will be
   * called with `true` if the animation series completed on its own or `false`
   * if it was cancelled.
   *
   * Animations are cancelled by user interactions (e.g. dragging the map) or by
   * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
   * (or another method that calls one of these).
   *
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
   *     options.  Multiple animations can be run in series by passing multiple
   *     options objects.  To run multiple animations in parallel, call the method
   *     multiple times.  An optional callback can be provided as a final
   *     argument.  The callback will be called with a boolean indicating whether
   *     the animation completed without being cancelled.
   * @api
   */
  animate(var_args) {
    if (this.isDef() && !this.getAnimating()) {
      this.resolveConstraints(0);
    }
    const args = new Array(arguments.length);
    for (let i = 0; i < args.length; ++i) {
      let options = arguments[i];
      if (options.center) {
        options = Object.assign({}, options);
        options.center = fromUserCoordinate(
          options.center,
          this.getProjection()
        );
      }
      if (options.anchor) {
        options = Object.assign({}, options);
        options.anchor = fromUserCoordinate(
          options.anchor,
          this.getProjection()
        );
      }
      args[i] = options;
    }
    this.animateInternal.apply(this, args);
  }
  /**
   * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
   */
  animateInternal(var_args) {
    let animationCount = arguments.length;
    let callback;
    if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
      callback = arguments[animationCount - 1];
      --animationCount;
    }
    let i = 0;
    for (; i < animationCount && !this.isDef(); ++i) {
      const state = arguments[i];
      if (state.center) {
        this.setCenterInternal(state.center);
      }
      if (state.zoom !== void 0) {
        this.setZoom(state.zoom);
      } else if (state.resolution) {
        this.setResolution(state.resolution);
      }
      if (state.rotation !== void 0) {
        this.setRotation(state.rotation);
      }
    }
    if (i === animationCount) {
      if (callback) {
        animationCallback(callback, true);
      }
      return;
    }
    let start = Date.now();
    let center = this.targetCenter_.slice();
    let resolution = this.targetResolution_;
    let rotation = this.targetRotation_;
    const series = [];
    for (; i < animationCount; ++i) {
      const options = (
        /** @type {AnimationOptions} */
        arguments[i]
      );
      const animation = {
        start,
        complete: false,
        anchor: options.anchor,
        duration: options.duration !== void 0 ? options.duration : 1e3,
        easing: options.easing || inAndOut,
        callback
      };
      if (options.center) {
        animation.sourceCenter = center;
        animation.targetCenter = options.center.slice();
        center = animation.targetCenter;
      }
      if (options.zoom !== void 0) {
        animation.sourceResolution = resolution;
        animation.targetResolution = this.getResolutionForZoom(options.zoom);
        resolution = animation.targetResolution;
      } else if (options.resolution) {
        animation.sourceResolution = resolution;
        animation.targetResolution = options.resolution;
        resolution = animation.targetResolution;
      }
      if (options.rotation !== void 0) {
        animation.sourceRotation = rotation;
        const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
        animation.targetRotation = rotation + delta;
        rotation = animation.targetRotation;
      }
      if (isNoopAnimation(animation)) {
        animation.complete = true;
      } else {
        start += animation.duration;
      }
      series.push(animation);
    }
    this.animations_.push(series);
    this.setHint(ViewHint.ANIMATING, 1);
    this.updateAnimations_();
  }
  /**
   * Determine if the view is being animated.
   * @return {boolean} The view is being animated.
   * @api
   */
  getAnimating() {
    return this.hints_[ViewHint.ANIMATING] > 0;
  }
  /**
   * Determine if the user is interacting with the view, such as panning or zooming.
   * @return {boolean} The view is being interacted with.
   * @api
   */
  getInteracting() {
    return this.hints_[ViewHint.INTERACTING] > 0;
  }
  /**
   * Cancel any ongoing animations.
   * @api
   */
  cancelAnimations() {
    this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
    let anchor;
    for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
      const series = this.animations_[i];
      if (series[0].callback) {
        animationCallback(series[0].callback, false);
      }
      if (!anchor) {
        for (let j = 0, jj = series.length; j < jj; ++j) {
          const animation = series[j];
          if (!animation.complete) {
            anchor = animation.anchor;
            break;
          }
        }
      }
    }
    this.animations_.length = 0;
    this.cancelAnchor_ = anchor;
    this.nextCenter_ = null;
    this.nextResolution_ = NaN;
    this.nextRotation_ = NaN;
  }
  /**
   * Update all animations.
   */
  updateAnimations_() {
    if (this.updateAnimationKey_ !== void 0) {
      cancelAnimationFrame(this.updateAnimationKey_);
      this.updateAnimationKey_ = void 0;
    }
    if (!this.getAnimating()) {
      return;
    }
    const now = Date.now();
    let more = false;
    for (let i = this.animations_.length - 1; i >= 0; --i) {
      const series = this.animations_[i];
      let seriesComplete = true;
      for (let j = 0, jj = series.length; j < jj; ++j) {
        const animation = series[j];
        if (animation.complete) {
          continue;
        }
        const elapsed = now - animation.start;
        let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
        if (fraction >= 1) {
          animation.complete = true;
          fraction = 1;
        } else {
          seriesComplete = false;
        }
        const progress = animation.easing(fraction);
        if (animation.sourceCenter) {
          const x0 = animation.sourceCenter[0];
          const y0 = animation.sourceCenter[1];
          const x1 = animation.targetCenter[0];
          const y1 = animation.targetCenter[1];
          this.nextCenter_ = animation.targetCenter;
          const x = x0 + progress * (x1 - x0);
          const y = y0 + progress * (y1 - y0);
          this.targetCenter_ = [x, y];
        }
        if (animation.sourceResolution && animation.targetResolution) {
          const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
          if (animation.anchor) {
            const size = this.getViewportSize_(this.getRotation());
            const constrainedResolution = this.constraints_.resolution(
              resolution,
              0,
              size,
              true
            );
            this.targetCenter_ = this.calculateCenterZoom(
              constrainedResolution,
              animation.anchor
            );
          }
          this.nextResolution_ = animation.targetResolution;
          this.targetResolution_ = resolution;
          this.applyTargetState_(true);
        }
        if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
          const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
          if (animation.anchor) {
            const constrainedRotation = this.constraints_.rotation(
              rotation,
              true
            );
            this.targetCenter_ = this.calculateCenterRotate(
              constrainedRotation,
              animation.anchor
            );
          }
          this.nextRotation_ = animation.targetRotation;
          this.targetRotation_ = rotation;
        }
        this.applyTargetState_(true);
        more = true;
        if (!animation.complete) {
          break;
        }
      }
      if (seriesComplete) {
        this.animations_[i] = null;
        this.setHint(ViewHint.ANIMATING, -1);
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
        const callback = series[0].callback;
        if (callback) {
          animationCallback(callback, true);
        }
      }
    }
    this.animations_ = this.animations_.filter(Boolean);
    if (more && this.updateAnimationKey_ === void 0) {
      this.updateAnimationKey_ = requestAnimationFrame(
        this.updateAnimations_.bind(this)
      );
    }
  }
  /**
   * @param {number} rotation Target rotation.
   * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
   */
  calculateCenterRotate(rotation, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    if (currentCenter !== void 0) {
      center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
      rotate$1(center, rotation - this.getRotation());
      add(center, anchor);
    }
    return center;
  }
  /**
   * @param {number} resolution Target resolution.
   * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
   * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
   */
  calculateCenterZoom(resolution, anchor) {
    let center;
    const currentCenter = this.getCenterInternal();
    const currentResolution = this.getResolution();
    if (currentCenter !== void 0 && currentResolution !== void 0) {
      const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
      const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
      center = [x, y];
    }
    return center;
  }
  /**
   * Returns the current viewport size.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
   */
  getViewportSize_(rotation) {
    const size = this.viewportSize_;
    if (rotation) {
      const w = size[0];
      const h = size[1];
      return [
        Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
        Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
      ];
    }
    return size;
  }
  /**
   * Stores the viewport size on the view. The viewport size is not read every time from the DOM
   * to avoid performance hit and layout reflow.
   * This should be done on map size change.
   * Note: the constraints are not resolved during an animation to avoid stopping it
   * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
   */
  setViewportSize(size) {
    this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
    if (!this.getAnimating()) {
      this.resolveConstraints(0);
    }
  }
  /**
   * Get the view center.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   * @observable
   * @api
   */
  getCenter() {
    const center = this.getCenterInternal();
    if (!center) {
      return center;
    }
    return toUserCoordinate(center, this.getProjection());
  }
  /**
   * Get the view center without transforming to user projection.
   * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
   */
  getCenterInternal() {
    return (
      /** @type {import("./coordinate.js").Coordinate|undefined} */
      this.get(ViewProperty.CENTER)
    );
  }
  /**
   * @return {Constraints} Constraints.
   */
  getConstraints() {
    return this.constraints_;
  }
  /**
   * @return {boolean} Resolution constraint is set
   */
  getConstrainResolution() {
    return this.get("constrainResolution");
  }
  /**
   * @param {Array<number>} [hints] Destination array.
   * @return {Array<number>} Hint.
   */
  getHints(hints) {
    if (hints !== void 0) {
      hints[0] = this.hints_[0];
      hints[1] = this.hints_[1];
      return hints;
    }
    return this.hints_.slice();
  }
  /**
   * Calculate the extent for the current view state and the passed box size.
   * @param {import("./size.js").Size} [size] The pixel dimensions of the box
   * into which the calculated extent should fit. Defaults to the size of the
   * map the view is associated with.
   * If no map or multiple maps are connected to the view, provide the desired
   * box size (e.g. `map.getSize()`).
   * @return {import("./extent.js").Extent} Extent.
   * @api
   */
  calculateExtent(size) {
    const extent = this.calculateExtentInternal(size);
    return toUserExtent(extent, this.getProjection());
  }
  /**
   * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
   * the map's last known viewport size will be used.
   * @return {import("./extent.js").Extent} Extent.
   */
  calculateExtentInternal(size) {
    size = size || this.getViewportSizeMinusPadding_();
    const center = (
      /** @type {!import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    assert(center, "The view center is not defined");
    const resolution = (
      /** @type {!number} */
      this.getResolution()
    );
    assert(resolution !== void 0, "The view resolution is not defined");
    const rotation = (
      /** @type {!number} */
      this.getRotation()
    );
    assert(rotation !== void 0, "The view rotation is not defined");
    return getForViewAndSize(center, resolution, rotation, size);
  }
  /**
   * Get the maximum resolution of the view.
   * @return {number} The maximum resolution of the view.
   * @api
   */
  getMaxResolution() {
    return this.maxResolution_;
  }
  /**
   * Get the minimum resolution of the view.
   * @return {number} The minimum resolution of the view.
   * @api
   */
  getMinResolution() {
    return this.minResolution_;
  }
  /**
   * Get the maximum zoom level for the view.
   * @return {number} The maximum zoom level.
   * @api
   */
  getMaxZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.minResolution_)
    );
  }
  /**
   * Set a new maximum zoom level for the view.
   * @param {number} zoom The maximum zoom level.
   * @api
   */
  setMaxZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
  }
  /**
   * Get the minimum zoom level for the view.
   * @return {number} The minimum zoom level.
   * @api
   */
  getMinZoom() {
    return (
      /** @type {number} */
      this.getZoomForResolution(this.maxResolution_)
    );
  }
  /**
   * Set a new minimum zoom level for the view.
   * @param {number} zoom The minimum zoom level.
   * @api
   */
  setMinZoom(zoom) {
    this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
  }
  /**
   * Set whether the view should allow intermediary zoom levels.
   * @param {boolean} enabled Whether the resolution is constrained.
   * @api
   */
  setConstrainResolution(enabled) {
    this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
  }
  /**
   * Get the view projection.
   * @return {import("./proj/Projection.js").default} The projection of the view.
   * @api
   */
  getProjection() {
    return this.projection_;
  }
  /**
   * Get the view resolution.
   * @return {number|undefined} The resolution of the view.
   * @observable
   * @api
   */
  getResolution() {
    return (
      /** @type {number|undefined} */
      this.get(ViewProperty.RESOLUTION)
    );
  }
  /**
   * Get the resolutions for the view. This returns the array of resolutions
   * passed to the constructor of the View, or undefined if none were given.
   * @return {Array<number>|undefined} The resolutions of the view.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   * @api
   */
  getResolutionForExtent(extent, size) {
    return this.getResolutionForExtentInternal(
      fromUserExtent(extent, this.getProjection()),
      size
    );
  }
  /**
   * Get the resolution for a provided extent (in map units) and size (in pixels).
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {import("./size.js").Size} [size] Box pixel size.
   * @return {number} The resolution at which the provided extent will render at
   *     the given size.
   */
  getResolutionForExtentInternal(extent, size) {
    size = size || this.getViewportSizeMinusPadding_();
    const xResolution = getWidth(extent) / size[0];
    const yResolution = getHeight(extent) / size[1];
    return Math.max(xResolution, yResolution);
  }
  /**
   * Return a function that returns a value between 0 and 1 for a
   * resolution. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Resolution for value function.
   */
  getResolutionForValueFunction(power) {
    power = power || 2;
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / Math.log(power);
    return (
      /**
       * @param {number} value Value.
       * @return {number} Resolution.
       */
      function(value) {
        const resolution = maxResolution / Math.pow(power, value * max);
        return resolution;
      }
    );
  }
  /**
   * Get the view rotation.
   * @return {number} The rotation of the view in radians.
   * @observable
   * @api
   */
  getRotation() {
    return (
      /** @type {number} */
      this.get(ViewProperty.ROTATION)
    );
  }
  /**
   * Return a function that returns a resolution for a value between
   * 0 and 1. Exponential scaling is assumed.
   * @param {number} [power] Power.
   * @return {function(number): number} Value for resolution function.
   */
  getValueForResolutionFunction(power) {
    const logPower = Math.log(power || 2);
    const maxResolution = this.getConstrainedResolution(this.maxResolution_);
    const minResolution = this.minResolution_;
    const max = Math.log(maxResolution / minResolution) / logPower;
    return (
      /**
       * @param {number} resolution Resolution.
       * @return {number} Value.
       */
      function(resolution) {
        const value = Math.log(maxResolution / resolution) / logPower / max;
        return value;
      }
    );
  }
  /**
   * Returns the size of the viewport minus padding.
   * @private
   * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
   * @return {import("./size.js").Size} Viewport size reduced by the padding.
   */
  getViewportSizeMinusPadding_(rotation) {
    let size = this.getViewportSize_(rotation);
    const padding = this.padding_;
    if (padding) {
      size = [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ];
    }
    return size;
  }
  /**
   * @return {State} View state.
   */
  getState() {
    const projection = this.getProjection();
    const resolution = this.getResolution();
    const rotation = this.getRotation();
    let center = (
      /** @type {import("./coordinate.js").Coordinate} */
      this.getCenterInternal()
    );
    const padding = this.padding_;
    if (padding) {
      const reducedSize = this.getViewportSizeMinusPadding_();
      center = calculateCenterOn(
        center,
        this.getViewportSize_(),
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
    }
    return {
      center: center.slice(0),
      projection: projection !== void 0 ? projection : null,
      resolution,
      nextCenter: this.nextCenter_,
      nextResolution: this.nextResolution_,
      nextRotation: this.nextRotation_,
      rotation,
      zoom: this.getZoom()
    };
  }
  /**
   * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
   */
  getViewStateAndExtent() {
    return {
      viewState: this.getState(),
      extent: this.calculateExtent()
    };
  }
  /**
   * Get the current zoom level. This method may return non-integer zoom levels
   * if the view does not constrain the resolution, or if an interaction or
   * animation is underway.
   * @return {number|undefined} Zoom.
   * @api
   */
  getZoom() {
    let zoom;
    const resolution = this.getResolution();
    if (resolution !== void 0) {
      zoom = this.getZoomForResolution(resolution);
    }
    return zoom;
  }
  /**
   * Get the zoom level for a resolution.
   * @param {number} resolution The resolution.
   * @return {number|undefined} The zoom level for the provided resolution.
   * @api
   */
  getZoomForResolution(resolution) {
    let offset = this.minZoom_ || 0;
    let max, zoomFactor;
    if (this.resolutions_) {
      const nearest = linearFindNearest(this.resolutions_, resolution, 1);
      offset = nearest;
      max = this.resolutions_[nearest];
      if (nearest == this.resolutions_.length - 1) {
        zoomFactor = 2;
      } else {
        zoomFactor = max / this.resolutions_[nearest + 1];
      }
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    return offset + Math.log(max / resolution) / Math.log(zoomFactor);
  }
  /**
   * Get the resolution for a zoom level.
   * @param {number} zoom Zoom level.
   * @return {number} The view resolution for the provided zoom level.
   * @api
   */
  getResolutionForZoom(zoom) {
    var _a;
    if ((_a = this.resolutions_) == null ? void 0 : _a.length) {
      if (this.resolutions_.length === 1) {
        return this.resolutions_[0];
      }
      const baseLevel = clamp(
        Math.floor(zoom),
        0,
        this.resolutions_.length - 2
      );
      const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
      return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
    }
    return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
  }
  /**
   * Fit the given geometry or extent based on the given map size and border.
   * The size is pixel dimensions of the box to fit the extent into.
   * In most cases you will want to use the map size, that is `map.getSize()`.
   * Takes care of the map angle.
   * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
   *     extent to fit the view to.
   * @param {FitOptions} [options] Options.
   * @api
   */
  fit(geometryOrExtent, options) {
    let geometry;
    assert(
      Array.isArray(geometryOrExtent) || typeof /** @type {?} */
      geometryOrExtent.getSimplifiedGeometry === "function",
      "Invalid extent or geometry provided as `geometry`"
    );
    if (Array.isArray(geometryOrExtent)) {
      assert(
        !isEmpty(geometryOrExtent),
        "Cannot fit empty extent provided as `geometry`"
      );
      const extent = fromUserExtent(geometryOrExtent, this.getProjection());
      geometry = fromExtent(extent);
    } else if (geometryOrExtent.getType() === "Circle") {
      const extent = fromUserExtent(
        geometryOrExtent.getExtent(),
        this.getProjection()
      );
      geometry = fromExtent(extent);
      geometry.rotate(this.getRotation(), getCenter(extent));
    } else {
      {
        geometry = geometryOrExtent;
      }
    }
    this.fitInternal(geometry, options);
  }
  /**
   * Calculate rotated extent
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @return {import("./extent").Extent} The rotated extent for the geometry.
   */
  rotatedExtentForGeometry(geometry) {
    const rotation = this.getRotation();
    const cosAngle = Math.cos(rotation);
    const sinAngle = Math.sin(-rotation);
    const coords = geometry.getFlatCoordinates();
    const stride = geometry.getStride();
    let minRotX = Infinity;
    let minRotY = Infinity;
    let maxRotX = -Infinity;
    let maxRotY = -Infinity;
    for (let i = 0, ii = coords.length; i < ii; i += stride) {
      const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
      const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
      minRotX = Math.min(minRotX, rotX);
      minRotY = Math.min(minRotY, rotY);
      maxRotX = Math.max(maxRotX, rotX);
      maxRotY = Math.max(maxRotY, rotY);
    }
    return [minRotX, minRotY, maxRotX, maxRotY];
  }
  /**
   * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
   * @param {FitOptions} [options] Options.
   */
  fitInternal(geometry, options) {
    options = options || {};
    let size = options.size;
    if (!size) {
      size = this.getViewportSizeMinusPadding_();
    }
    const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
    const nearest = options.nearest !== void 0 ? options.nearest : false;
    let minResolution;
    if (options.minResolution !== void 0) {
      minResolution = options.minResolution;
    } else if (options.maxZoom !== void 0) {
      minResolution = this.getResolutionForZoom(options.maxZoom);
    } else {
      minResolution = 0;
    }
    const rotatedExtent = this.rotatedExtentForGeometry(geometry);
    let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
      size[0] - padding[1] - padding[3],
      size[1] - padding[0] - padding[2]
    ]);
    resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
    resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
    const rotation = this.getRotation();
    const sinAngle = Math.sin(rotation);
    const cosAngle = Math.cos(rotation);
    const centerRot = getCenter(rotatedExtent);
    centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
    centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
    const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
    const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
    const center = this.getConstrainedCenter([centerX, centerY], resolution);
    const callback = options.callback ? options.callback : VOID;
    if (options.duration !== void 0) {
      this.animateInternal(
        {
          resolution,
          center,
          duration: options.duration,
          easing: options.easing
        },
        callback
      );
    } else {
      this.targetResolution_ = resolution;
      this.targetCenter_ = center;
      this.applyTargetState_(false, true);
      animationCallback(callback, true);
    }
  }
  /**
   * Center on coordinate and view position.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   * @api
   */
  centerOn(coordinate, size, position) {
    this.centerOnInternal(
      fromUserCoordinate(coordinate, this.getProjection()),
      size,
      position
    );
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("./size.js").Size} size Box pixel size.
   * @param {import("./pixel.js").Pixel} position Position on the view to center on.
   */
  centerOnInternal(coordinate, size, position) {
    this.setCenterInternal(
      calculateCenterOn(
        coordinate,
        size,
        position,
        this.getResolution(),
        this.getRotation()
      )
    );
  }
  /**
   * Calculates the shift between map and viewport center.
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @return {Array<number>|undefined} Center shift.
   */
  calculateCenterShift(center, resolution, rotation, size) {
    let centerShift;
    const padding = this.padding_;
    if (padding && center) {
      const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
      const shiftedCenter = calculateCenterOn(
        center,
        size,
        [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
        resolution,
        rotation
      );
      centerShift = [
        center[0] - shiftedCenter[0],
        center[1] - shiftedCenter[1]
      ];
    }
    return centerShift;
  }
  /**
   * @return {boolean} Is defined.
   */
  isDef() {
    return !!this.getCenterInternal() && this.getResolution() !== void 0;
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   * @api
   */
  adjustCenter(deltaCoordinates) {
    const center = toUserCoordinate(this.targetCenter_, this.getProjection());
    this.setCenter([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Adds relative coordinates to the center of the view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
   */
  adjustCenterInternal(deltaCoordinates) {
    const center = this.targetCenter_;
    this.setCenterInternal([
      center[0] + deltaCoordinates[0],
      center[1] + deltaCoordinates[1]
    ]);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustResolution(ratio, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.adjustResolutionInternal(ratio, anchor);
  }
  /**
   * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} ratio The ratio to apply on the view resolution.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  adjustResolutionInternal(ratio, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const size = this.getViewportSize_(this.getRotation());
    const newResolution = this.constraints_.resolution(
      this.targetResolution_ * ratio,
      0,
      size,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
    }
    this.targetResolution_ *= ratio;
    this.applyTargetState_();
  }
  /**
   * Adds a value to the view zoom level, optionally using an anchor. Any resolution
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom level.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  adjustZoom(delta, anchor) {
    this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
  }
  /**
   * Adds a value to the view rotation, optionally using an anchor. Any rotation
   * constraint will apply.
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   * @api
   */
  adjustRotation(delta, anchor) {
    if (anchor) {
      anchor = fromUserCoordinate(anchor, this.getProjection());
    }
    this.adjustRotationInternal(delta, anchor);
  }
  /**
   * @param {number} delta Relative value to add to the zoom rotation, in radians.
   * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
   */
  adjustRotationInternal(delta, anchor) {
    const isMoving = this.getAnimating() || this.getInteracting();
    const newRotation = this.constraints_.rotation(
      this.targetRotation_ + delta,
      isMoving
    );
    if (anchor) {
      this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
    }
    this.targetRotation_ += delta;
    this.applyTargetState_();
  }
  /**
   * Set the center of the current view. Any extent constraint will apply.
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   * @observable
   * @api
   */
  setCenter(center) {
    this.setCenterInternal(
      center ? fromUserCoordinate(center, this.getProjection()) : center
    );
  }
  /**
   * Set the center using the view projection (not the user projection).
   * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
   */
  setCenterInternal(center) {
    this.targetCenter_ = center;
    this.applyTargetState_();
  }
  /**
   * @param {import("./ViewHint.js").default} hint Hint.
   * @param {number} delta Delta.
   * @return {number} New value.
   */
  setHint(hint, delta) {
    this.hints_[hint] += delta;
    this.changed();
    return this.hints_[hint];
  }
  /**
   * Set the resolution for this view. Any resolution constraint will apply.
   * @param {number|undefined} resolution The resolution of the view.
   * @observable
   * @api
   */
  setResolution(resolution) {
    this.targetResolution_ = resolution;
    this.applyTargetState_();
  }
  /**
   * Set the rotation for this view. Any rotation constraint will apply.
   * @param {number} rotation The rotation of the view in radians.
   * @observable
   * @api
   */
  setRotation(rotation) {
    this.targetRotation_ = rotation;
    this.applyTargetState_();
  }
  /**
   * Zoom to a specific zoom level. Any resolution constrain will apply.
   * @param {number} zoom Zoom level.
   * @api
   */
  setZoom(zoom) {
    this.setResolution(this.getResolutionForZoom(zoom));
  }
  /**
   * Recompute rotation/resolution/center based on target values.
   * Note: we have to compute rotation first, then resolution and center considering that
   * parameters can influence one another in case a view extent constraint is present.
   * @param {boolean} [doNotCancelAnims] Do not cancel animations.
   * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
   * @private
   */
  applyTargetState_(doNotCancelAnims, forceMoving) {
    const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
    const newRotation = this.constraints_.rotation(
      this.targetRotation_,
      isMoving
    );
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      0,
      size,
      isMoving
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      isMoving,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (this.get(ViewProperty.ROTATION) !== newRotation) {
      this.set(ViewProperty.ROTATION, newRotation);
    }
    if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
      this.set(ViewProperty.RESOLUTION, newResolution);
      this.set("zoom", this.getZoom(), true);
    }
    if (!newCenter || !this.get(ViewProperty.CENTER) || !equals(this.get(ViewProperty.CENTER), newCenter)) {
      this.set(ViewProperty.CENTER, newCenter);
    }
    if (this.getAnimating() && !doNotCancelAnims) {
      this.cancelAnimations();
    }
    this.cancelAnchor_ = void 0;
  }
  /**
   * If any constraints need to be applied, an animation will be triggered.
   * This is typically done on interaction end.
   * Note: calling this with a duration of 0 will apply the constrained values straight away,
   * without animation.
   * @param {number} [duration] The animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  resolveConstraints(duration, resolutionDirection, anchor) {
    duration = duration !== void 0 ? duration : 200;
    const direction = resolutionDirection || 0;
    const newRotation = this.constraints_.rotation(this.targetRotation_);
    const size = this.getViewportSize_(newRotation);
    const newResolution = this.constraints_.resolution(
      this.targetResolution_,
      direction,
      size
    );
    const newCenter = this.constraints_.center(
      this.targetCenter_,
      newResolution,
      size,
      false,
      this.calculateCenterShift(
        this.targetCenter_,
        newResolution,
        newRotation,
        size
      )
    );
    if (duration === 0 && !this.cancelAnchor_) {
      this.targetResolution_ = newResolution;
      this.targetRotation_ = newRotation;
      this.targetCenter_ = newCenter;
      this.applyTargetState_();
      return;
    }
    anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
    this.cancelAnchor_ = void 0;
    if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals(this.getCenterInternal(), newCenter)) {
      if (this.getAnimating()) {
        this.cancelAnimations();
      }
      this.animateInternal({
        rotation: newRotation,
        center: newCenter,
        resolution: newResolution,
        duration,
        easing: easeOut,
        anchor
      });
    }
  }
  /**
   * Notify the View that an interaction has started.
   * The view state will be resolved to a stable one if needed
   * (depending on its constraints).
   * @api
   */
  beginInteraction() {
    this.resolveConstraints(0);
    this.setHint(ViewHint.INTERACTING, 1);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   * @api
   */
  endInteraction(duration, resolutionDirection, anchor) {
    anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
    this.endInteractionInternal(duration, resolutionDirection, anchor);
  }
  /**
   * Notify the View that an interaction has ended. The view state will be resolved
   * to a stable one if needed (depending on its constraints).
   * @param {number} [duration] Animation duration in ms.
   * @param {number} [resolutionDirection] Which direction to zoom.
   * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
   */
  endInteractionInternal(duration, resolutionDirection, anchor) {
    if (!this.getInteracting()) {
      return;
    }
    this.setHint(ViewHint.INTERACTING, -1);
    this.resolveConstraints(duration, resolutionDirection, anchor);
  }
  /**
   * Get a valid position for the view center according to the current constraints.
   * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
   * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
   * This is useful to guess a valid center position at a different zoom level.
   * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
   */
  getConstrainedCenter(targetCenter, targetResolution) {
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.center(
      targetCenter,
      targetResolution || this.getResolution(),
      size
    );
  }
  /**
   * Get a valid zoom level according to the current view constraints.
   * @param {number|undefined} targetZoom Target zoom.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid zoom level.
   */
  getConstrainedZoom(targetZoom, direction) {
    const targetRes = this.getResolutionForZoom(targetZoom);
    return this.getZoomForResolution(
      this.getConstrainedResolution(targetRes, direction)
    );
  }
  /**
   * Get a valid resolution according to the current view constraints.
   * @param {number|undefined} targetResolution Target resolution.
   * @param {number} [direction=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   * @return {number|undefined} Valid resolution.
   */
  getConstrainedResolution(targetResolution, direction) {
    direction = direction || 0;
    const size = this.getViewportSize_(this.getRotation());
    return this.constraints_.resolution(targetResolution, direction, size);
  }
}
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none$1;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT$1.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
class Layer extends BaseLayer {
  /**
   * @param {Options<SourceType>} options Layer options.
   */
  constructor(options) {
    const baseOptions = Object.assign({}, options);
    delete baseOptions.source;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.mapPrecomposeKey_ = null;
    this.mapRenderKey_ = null;
    this.sourceChangeKey_ = null;
    this.renderer_ = null;
    this.sourceReady_ = false;
    this.rendered = false;
    if (options.render) {
      this.render = options.render;
    }
    if (options.map) {
      this.setMap(options.map);
    }
    this.addChangeListener(
      LayerProperty.SOURCE,
      this.handleSourcePropertyChange_
    );
    const source = options.source ? (
      /** @type {SourceType} */
      options.source
    ) : null;
    this.setSource(source);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array ? array : [];
    array.push(this);
    return array;
  }
  /**
   * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(states) {
    states = states ? states : [];
    states.push(this.getLayerState());
    return states;
  }
  /**
   * Get the layer source.
   * @return {SourceType|null} The layer source (or `null` if not yet set).
   * @observable
   * @api
   */
  getSource() {
    return (
      /** @type {SourceType} */
      this.get(LayerProperty.SOURCE) || null
    );
  }
  /**
   * @return {SourceType|null} The source being rendered.
   */
  getRenderSource() {
    return this.getSource();
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    const source = this.getSource();
    return !source ? "undefined" : source.getState();
  }
  /**
   * @private
   */
  handleSourceChange_() {
    this.changed();
    if (this.sourceReady_ || this.getSource().getState() !== "ready") {
      return;
    }
    this.sourceReady_ = true;
    this.dispatchEvent("sourceready");
  }
  /**
   * @private
   */
  handleSourcePropertyChange_() {
    if (this.sourceChangeKey_) {
      unlistenByKey(this.sourceChangeKey_);
      this.sourceChangeKey_ = null;
    }
    this.sourceReady_ = false;
    const source = this.getSource();
    if (source) {
      this.sourceChangeKey_ = listen(
        source,
        EventType.CHANGE,
        this.handleSourceChange_,
        this
      );
      if (source.getState() === "ready") {
        this.sourceReady_ = true;
        setTimeout(() => {
          this.dispatchEvent("sourceready");
        }, 0);
      }
    }
    this.changed();
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    if (!this.renderer_) {
      return Promise.resolve([]);
    }
    return this.renderer_.getFeatures(pixel);
  }
  /**
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    if (!this.renderer_ || !this.rendered) {
      return null;
    }
    return this.renderer_.getData(pixel);
  }
  /**
   * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
   * extent, not set to `visible: false`, and not inside a layer group that is set
   * to `visible: false`.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {boolean} The layer is visible in the map view.
   * @api
   */
  isVisible(view) {
    let frameState;
    const map = this.getMapInternal();
    if (!view && map) {
      view = map.getView();
    }
    if (view instanceof View) {
      frameState = {
        viewState: view.getState(),
        extent: view.calculateExtent()
      };
    } else {
      frameState = view;
    }
    if (!frameState.layerStatesArray && map) {
      frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
    }
    let layerState;
    if (frameState.layerStatesArray) {
      layerState = frameState.layerStatesArray.find(
        (layerState2) => layerState2.layer === this
      );
    } else {
      layerState = this.getLayerState();
    }
    const layerExtent = this.getExtent();
    return inView(layerState, frameState.viewState) && (!layerExtent || intersects$1(layerExtent, frameState.extent));
  }
  /**
   * Get the attributions of the source of this layer for the given view.
   * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
   * Only required when the layer is not added to a map.
   * @return {Array<string>} Attributions for this layer at the given view.
   * @api
   */
  getAttributions(view) {
    var _a;
    if (!this.isVisible(view)) {
      return [];
    }
    const getAttributions = (_a = this.getSource()) == null ? void 0 : _a.getAttributions();
    if (!getAttributions) {
      return [];
    }
    const frameState = view instanceof View ? view.getViewStateAndExtent() : view;
    let attributions = getAttributions(frameState);
    if (!Array.isArray(attributions)) {
      attributions = [attributions];
    }
    return attributions;
  }
  /**
   * In charge to manage the rendering of the layer. One layer type is
   * bounded with one layer renderer.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target which the renderer may (but need not) use
   * for rendering its content.
   * @return {HTMLElement|null} The rendered element.
   */
  render(frameState, target) {
    const layerRenderer = this.getRenderer();
    if (layerRenderer.prepareFrame(frameState)) {
      this.rendered = true;
      return layerRenderer.renderFrame(frameState, target);
    }
    return null;
  }
  /**
   * Called when a layer is not visible during a map render.
   */
  unrender() {
    this.rendered = false;
  }
  /** @return {string} Declutter */
  getDeclutter() {
    return void 0;
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   */
  renderDeclutter(frameState, layerState) {
  }
  /**
   * When the renderer follows a layout -> render approach, do the final rendering here.
   * @param {import('../Map.js').FrameState} frameState Frame state
   */
  renderDeferred(frameState) {
    const layerRenderer = this.getRenderer();
    if (!layerRenderer) {
      return;
    }
    layerRenderer.renderDeferred(frameState);
  }
  /**
   * For use inside the library only.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMapInternal(map) {
    if (!map) {
      this.unrender();
    }
    this.set(LayerProperty.MAP, map);
  }
  /**
   * For use inside the library only.
   * @return {import("../Map.js").default|null} Map.
   */
  getMapInternal() {
    return this.get(LayerProperty.MAP);
  }
  /**
   * Sets the layer to be rendered on top of other layers on a map. The map will
   * not manage this layer in its layers collection. This
   * is useful for temporary layers. To remove an unmanaged layer from the map,
   * use `#setMap(null)`.
   *
   * To add the layer to a map and have it managed by the map, use
   * {@link module:ol/Map~Map#addLayer} instead.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    if (this.mapPrecomposeKey_) {
      unlistenByKey(this.mapPrecomposeKey_);
      this.mapPrecomposeKey_ = null;
    }
    if (!map) {
      this.changed();
    }
    if (this.mapRenderKey_) {
      unlistenByKey(this.mapRenderKey_);
      this.mapRenderKey_ = null;
    }
    if (map) {
      this.mapPrecomposeKey_ = listen(
        map,
        RenderEventType.PRECOMPOSE,
        this.handlePrecompose_,
        this
      );
      this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
      this.changed();
    }
  }
  /**
   * @param {import("../events/Event.js").default} renderEvent Render event
   * @private
   */
  handlePrecompose_(renderEvent) {
    const layerStatesArray = (
      /** @type {import("../render/Event.js").default} */
      renderEvent.frameState.layerStatesArray
    );
    const layerState = this.getLayerState(false);
    assert(
      !layerStatesArray.some(
        (arrayLayerState) => arrayLayerState.layer === layerState.layer
      ),
      "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
    );
    layerStatesArray.push(layerState);
  }
  /**
   * Set the layer source.
   * @param {SourceType|null} source The layer source.
   * @observable
   * @api
   */
  setSource(source) {
    this.set(LayerProperty.SOURCE, source);
  }
  /**
   * Get the renderer for this layer.
   * @return {RendererType|null} The layer renderer.
   */
  getRenderer() {
    if (!this.renderer_) {
      this.renderer_ = this.createRenderer();
    }
    return this.renderer_;
  }
  /**
   * @return {boolean} The layer has a renderer.
   */
  hasRenderer() {
    return !!this.renderer_;
  }
  /**
   * Create a renderer for this layer.
   * @return {RendererType} A layer renderer.
   * @protected
   */
  createRenderer() {
    return null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.renderer_) {
      this.renderer_.dispose();
      delete this.renderer_;
    }
    this.setSource(null);
    super.disposeInternal();
  }
}
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {
  while (right > left) {
    if (right - left > 600) {
      const n = right - left + 1;
      const m = k - left + 1;
      const z = Math.log(n);
      const s = 0.5 * Math.exp(2 * z / 3);
      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight, compare);
    }
    const t = arr[k];
    let i = left;
    let j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0) swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0) i++;
      while (compare(arr[j], t) > 0) j--;
    }
    if (compare(arr[left], t) === 0) swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k) left = j + 1;
    if (k <= j) right = j - 1;
  }
}
function swap(arr, i, j) {
  const tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
class RBush {
  constructor(maxEntries = 9) {
    this._maxEntries = Math.max(4, maxEntries);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
    this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(bbox) {
    let node = this.data;
    const result = [];
    if (!intersects(bbox, node)) return result;
    const toBBox = this.toBBox;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf) result.push(child);
          else if (contains(bbox, childBBox)) this._all(child, result);
          else nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return result;
  }
  collides(bbox) {
    let node = this.data;
    if (!intersects(bbox, node)) return false;
    const nodesToSearch = [];
    while (node) {
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const childBBox = node.leaf ? this.toBBox(child) : child;
        if (intersects(bbox, childBBox)) {
          if (node.leaf || contains(bbox, childBBox)) return true;
          nodesToSearch.push(child);
        }
      }
      node = nodesToSearch.pop();
    }
    return false;
  }
  load(data) {
    if (!(data && data.length)) return this;
    if (data.length < this._minEntries) {
      for (let i = 0; i < data.length; i++) {
        this.insert(data[i]);
      }
      return this;
    }
    let node = this._build(data.slice(), 0, data.length - 1, 0);
    if (!this.data.children.length) {
      this.data = node;
    } else if (this.data.height === node.height) {
      this._splitRoot(this.data, node);
    } else {
      if (this.data.height < node.height) {
        const tmpNode = this.data;
        this.data = node;
        node = tmpNode;
      }
      this._insert(node, this.data.height - node.height - 1, true);
    }
    return this;
  }
  insert(item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
  }
  clear() {
    this.data = createNode([]);
    return this;
  }
  remove(item, equalsFn) {
    if (!item) return this;
    let node = this.data;
    const bbox = this.toBBox(item);
    const path = [];
    const indexes = [];
    let i, parent, goingUp;
    while (node || path.length) {
      if (!node) {
        node = path.pop();
        parent = path[path.length - 1];
        i = indexes.pop();
        goingUp = true;
      }
      if (node.leaf) {
        const index = findItem(item, node.children, equalsFn);
        if (index !== -1) {
          node.children.splice(index, 1);
          path.push(node);
          this._condense(path);
          return this;
        }
      }
      if (!goingUp && !node.leaf && contains(node, bbox)) {
        path.push(node);
        indexes.push(i);
        i = 0;
        parent = node;
        node = node.children[0];
      } else if (parent) {
        i++;
        node = parent.children[i];
        goingUp = false;
      } else node = null;
    }
    return this;
  }
  toBBox(item) {
    return item;
  }
  compareMinX(a, b) {
    return a.minX - b.minX;
  }
  compareMinY(a, b) {
    return a.minY - b.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(data) {
    this.data = data;
    return this;
  }
  _all(node, result) {
    const nodesToSearch = [];
    while (node) {
      if (node.leaf) result.push(...node.children);
      else nodesToSearch.push(...node.children);
      node = nodesToSearch.pop();
    }
    return result;
  }
  _build(items, left, right, height) {
    const N = right - left + 1;
    let M = this._maxEntries;
    let node;
    if (N <= M) {
      node = createNode(items.slice(left, right + 1));
      calcBBox(node, this.toBBox);
      return node;
    }
    if (!height) {
      height = Math.ceil(Math.log(N) / Math.log(M));
      M = Math.ceil(N / Math.pow(M, height - 1));
    }
    node = createNode([]);
    node.leaf = false;
    node.height = height;
    const N2 = Math.ceil(N / M);
    const N1 = N2 * Math.ceil(Math.sqrt(M));
    multiSelect(items, left, right, N1, this.compareMinX);
    for (let i = left; i <= right; i += N1) {
      const right2 = Math.min(i + N1 - 1, right);
      multiSelect(items, i, right2, N2, this.compareMinY);
      for (let j = i; j <= right2; j += N2) {
        const right3 = Math.min(j + N2 - 1, right2);
        node.children.push(this._build(items, j, right3, height - 1));
      }
    }
    calcBBox(node, this.toBBox);
    return node;
  }
  _chooseSubtree(bbox, node, level, path) {
    while (true) {
      path.push(node);
      if (node.leaf || path.length - 1 === level) break;
      let minArea = Infinity;
      let minEnlargement = Infinity;
      let targetNode;
      for (let i = 0; i < node.children.length; i++) {
        const child = node.children[i];
        const area = bboxArea(child);
        const enlargement = enlargedArea(bbox, child) - area;
        if (enlargement < minEnlargement) {
          minEnlargement = enlargement;
          minArea = area < minArea ? area : minArea;
          targetNode = child;
        } else if (enlargement === minEnlargement) {
          if (area < minArea) {
            minArea = area;
            targetNode = child;
          }
        }
      }
      node = targetNode || node.children[0];
    }
    return node;
  }
  _insert(item, level, isNode) {
    const bbox = isNode ? item : this.toBBox(item);
    const insertPath = [];
    const node = this._chooseSubtree(bbox, this.data, level, insertPath);
    node.children.push(item);
    extend(node, bbox);
    while (level >= 0) {
      if (insertPath[level].children.length > this._maxEntries) {
        this._split(insertPath, level);
        level--;
      } else break;
    }
    this._adjustParentBBoxes(bbox, insertPath, level);
  }
  // split overflowed node into two
  _split(insertPath, level) {
    const node = insertPath[level];
    const M = node.children.length;
    const m = this._minEntries;
    this._chooseSplitAxis(node, m, M);
    const splitIndex = this._chooseSplitIndex(node, m, M);
    const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;
    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);
    if (level) insertPath[level - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
  }
  _splitRoot(node, newNode) {
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
  }
  _chooseSplitIndex(node, m, M) {
    let index;
    let minOverlap = Infinity;
    let minArea = Infinity;
    for (let i = m; i <= M - m; i++) {
      const bbox1 = distBBox(node, 0, i, this.toBBox);
      const bbox2 = distBBox(node, i, M, this.toBBox);
      const overlap = intersectionArea(bbox1, bbox2);
      const area = bboxArea(bbox1) + bboxArea(bbox2);
      if (overlap < minOverlap) {
        minOverlap = overlap;
        index = i;
        minArea = area < minArea ? area : minArea;
      } else if (overlap === minOverlap) {
        if (area < minArea) {
          minArea = area;
          index = i;
        }
      }
    }
    return index || M - m;
  }
  // sorts node children by the best axis for split
  _chooseSplitAxis(node, m, M) {
    const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
    const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
    const xMargin = this._allDistMargin(node, m, M, compareMinX);
    const yMargin = this._allDistMargin(node, m, M, compareMinY);
    if (xMargin < yMargin) node.children.sort(compareMinX);
  }
  // total margin of all possible split distributions where each node is at least m full
  _allDistMargin(node, m, M, compare) {
    node.children.sort(compare);
    const toBBox = this.toBBox;
    const leftBBox = distBBox(node, 0, m, toBBox);
    const rightBBox = distBBox(node, M - m, M, toBBox);
    let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
    for (let i = m; i < M - m; i++) {
      const child = node.children[i];
      extend(leftBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(leftBBox);
    }
    for (let i = M - m - 1; i >= m; i--) {
      const child = node.children[i];
      extend(rightBBox, node.leaf ? toBBox(child) : child);
      margin += bboxMargin(rightBBox);
    }
    return margin;
  }
  _adjustParentBBoxes(bbox, path, level) {
    for (let i = level; i >= 0; i--) {
      extend(path[i], bbox);
    }
  }
  _condense(path) {
    for (let i = path.length - 1, siblings; i >= 0; i--) {
      if (path[i].children.length === 0) {
        if (i > 0) {
          siblings = path[i - 1].children;
          siblings.splice(siblings.indexOf(path[i]), 1);
        } else this.clear();
      } else calcBBox(path[i], this.toBBox);
    }
  }
}
function findItem(item, items, equalsFn) {
  if (!equalsFn) return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i])) return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode) destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n) continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
const ImageState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4
};
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
class ImageStyle {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    this.opacity_ = options.opacity;
    this.rotateWithView_ = options.rotateWithView;
    this.rotation_ = options.rotation;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale);
    this.displacement_ = options.displacement;
    this.declutterMode_ = options.declutterMode;
  }
  /**
   * Clones the style.
   * @return {ImageStyle} The cloned style.
   * @api
   */
  clone() {
    const scale2 = this.getScale();
    return new ImageStyle({
      opacity: this.getOpacity(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the symbolizer opacity.
   * @return {number} Opacity.
   * @api
   */
  getOpacity() {
    return this.opacity_;
  }
  /**
   * Determine whether the symbolizer rotates with the map.
   * @return {boolean} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the symoblizer rotation.
   * @return {number} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the symbolizer scale.
   * @return {number|import("../size.js").Size} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the displacement of the shape
   * @return {Array<number>} Shape's center displacement
   * @api
   */
  getDisplacement() {
    return this.displacement_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @abstract
   * @return {Array<number>} Anchor.
   */
  getAnchor() {
    return abstract();
  }
  /**
   * Get the image element for the symbolizer.
   * @abstract
   * @param {number} pixelRatio Pixel ratio.
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getImage(pixelRatio) {
    return abstract();
  }
  /**
   * @abstract
   * @return {import('../DataTile.js').ImageLike} Image element.
   */
  getHitDetectionImage() {
    return abstract();
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   */
  getPixelRatio(pixelRatio) {
    return 1;
  }
  /**
   * @abstract
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return abstract();
  }
  /**
   * @abstract
   * @return {import("../size.js").Size} Image size.
   */
  getImageSize() {
    return abstract();
  }
  /**
   * Get the origin of the symbolizer.
   * @abstract
   * @return {Array<number>} Origin.
   */
  getOrigin() {
    return abstract();
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @abstract
   * @return {import("../size.js").Size} Size.
   */
  getSize() {
    return abstract();
  }
  /**
   * Set the displacement.
   *
   * @param {Array<number>} displacement Displacement.
   * @api
   */
  setDisplacement(displacement) {
    this.displacement_ = displacement;
  }
  /**
   * Set the opacity.
   *
   * @param {number} opacity Opacity.
   * @api
   */
  setOpacity(opacity) {
    this.opacity_ = opacity;
  }
  /**
   * Set whether to rotate the style with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  /**
   * Set the rotation.
   *
   * @param {number} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   */
  setScale(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2);
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  listenImageChange(listener) {
    abstract();
  }
  /**
   * Load not yet loaded URI.
   * @abstract
   */
  load() {
    abstract();
  }
  /**
   * @abstract
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   */
  unlistenImageChange(listener) {
    abstract();
  }
  /**
   * @return {Promise<void>} `false` or Promise that resolves when the style is ready to use.
   */
  ready() {
    return Promise.resolve();
  }
}
const rgb = {
  name: "rgb",
  min: [0, 0, 0],
  max: [255, 255, 255],
  channel: ["red", "green", "blue"],
  alias: ["RGB"]
};
var xyz = {
  name: "xyz",
  min: [0, 0, 0],
  channel: ["X", "Y", "Z"],
  alias: ["XYZ", "ciexyz", "cie1931"]
};
xyz.whitepoint = {
  //1931 2°
  2: {
    //incadescent
    A: [109.85, 100, 35.585],
    // B:[],
    C: [98.074, 100, 118.232],
    D50: [96.422, 100, 82.521],
    D55: [95.682, 100, 92.149],
    //daylight
    D65: [95.045592705167, 100, 108.9057750759878],
    D75: [94.972, 100, 122.638],
    //flourescent
    // F1: [],
    F2: [99.187, 100, 67.395],
    // F3: [],
    // F4: [],
    // F5: [],
    // F6:[],
    F7: [95.044, 100, 108.755],
    // F8: [],
    // F9: [],
    // F10: [],
    F11: [100.966, 100, 64.37],
    // F12: [],
    E: [100, 100, 100]
  },
  //1964  10°
  10: {
    //incadescent
    A: [111.144, 100, 35.2],
    C: [97.285, 100, 116.145],
    D50: [96.72, 100, 81.427],
    D55: [95.799, 100, 90.926],
    //daylight
    D65: [94.811, 100, 107.304],
    D75: [94.416, 100, 120.641],
    //flourescent
    F2: [103.28, 100, 69.026],
    F7: [95.792, 100, 107.687],
    F11: [103.866, 100, 65.627],
    E: [100, 100, 100]
  }
};
xyz.max = xyz.whitepoint[2].D65;
xyz.rgb = function(_xyz, white) {
  white = white || xyz.whitepoint[2].E;
  var x = _xyz[0] / white[0], y = _xyz[1] / white[1], z = _xyz[2] / white[2], r, g, b;
  r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
  g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
  b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
  r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92;
  g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g = g * 12.92;
  b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b = b * 12.92;
  r = Math.min(Math.max(0, r), 1);
  g = Math.min(Math.max(0, g), 1);
  b = Math.min(Math.max(0, b), 1);
  return [r * 255, g * 255, b * 255];
};
rgb.xyz = function(rgb2, white) {
  var r = rgb2[0] / 255, g = rgb2[1] / 255, b = rgb2[2] / 255;
  r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
  b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
  var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
  var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
  var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
  white = white || xyz.whitepoint[2].E;
  return [x * white[0], y * white[1], z * white[2]];
};
const luv = {
  name: "luv",
  //NOTE: luv has no rigidly defined limits
  //easyrgb fails to get proper coords
  //boronine states no rigid limits
  //colorMine refers this ones:
  min: [0, -134, -140],
  max: [100, 224, 122],
  channel: ["lightness", "u", "v"],
  alias: ["LUV", "cieluv", "cie1976"],
  xyz: function(arg, i, o) {
    var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
    l = arg[0], u = arg[1], v = arg[2];
    if (l === 0) return [0, 0, 0];
    var k = 0.0011070564598794539;
    i = i || "D65";
    o = o || 2;
    xn = xyz.whitepoint[o][i][0];
    yn = xyz.whitepoint[o][i][1];
    zn = xyz.whitepoint[o][i][2];
    un = 4 * xn / (xn + 15 * yn + 3 * zn);
    vn = 9 * yn / (xn + 15 * yn + 3 * zn);
    _u = u / (13 * l) + un || 0;
    _v = v / (13 * l) + vn || 0;
    y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;
    x = y * 9 * _u / (4 * _v) || 0;
    z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;
    return [x, y, z];
  }
};
xyz.luv = function(arg, i, o) {
  var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
  var e = 0.008856451679035631;
  var k = 903.2962962962961;
  i = i || "D65";
  o = o || 2;
  xn = xyz.whitepoint[o][i][0];
  yn = xyz.whitepoint[o][i][1];
  zn = xyz.whitepoint[o][i][2];
  un = 4 * xn / (xn + 15 * yn + 3 * zn);
  vn = 9 * yn / (xn + 15 * yn + 3 * zn);
  x = arg[0], y = arg[1], z = arg[2];
  _u = 4 * x / (x + 15 * y + 3 * z) || 0;
  _v = 9 * y / (x + 15 * y + 3 * z) || 0;
  var yr = y / yn;
  l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
  u = 13 * l * (_u - un);
  v = 13 * l * (_v - vn);
  return [l, u, v];
};
var lchuv = {
  name: "lchuv",
  channel: ["lightness", "chroma", "hue"],
  alias: ["LCHuv", "cielchuv"],
  min: [0, 0, 0],
  max: [100, 100, 360],
  luv: function(luv2) {
    var l = luv2[0], c = luv2[1], h = luv2[2], u, v, hr;
    hr = h / 360 * 2 * Math.PI;
    u = c * Math.cos(hr);
    v = c * Math.sin(hr);
    return [l, u, v];
  },
  xyz: function(arg) {
    return luv.xyz(lchuv.luv(arg));
  }
};
luv.lchuv = function(luv2) {
  var l = luv2[0], u = luv2[1], v = luv2[2];
  var c = Math.sqrt(u * u + v * v);
  var hr = Math.atan2(v, u);
  var h = hr * 360 / 2 / Math.PI;
  if (h < 0) {
    h += 360;
  }
  return [l, c, h];
};
xyz.lchuv = function(arg) {
  return luv.lchuv(xyz.luv(arg));
};
const names = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
var baseHues = {
  red: 0,
  orange: 60,
  yellow: 120,
  green: 180,
  blue: 240,
  purple: 300
};
function parse$1(cstr) {
  var _a, _b;
  var m, parts = [], alpha = 1, space;
  if (typeof cstr === "number") {
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  }
  if (typeof cstr === "number") return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  cstr = String(cstr).toLowerCase();
  if (names[cstr]) {
    parts = names[cstr].slice();
    space = "rgb";
  } else if (cstr === "transparent") {
    alpha = 0;
    space = "rgb";
    parts = [0, 0, 0];
  } else if (cstr[0] === "#") {
    var base = cstr.slice(1);
    var size = base.length;
    var isShort = size <= 4;
    alpha = 1;
    if (isShort) {
      parts = [
        parseInt(base[0] + base[0], 16),
        parseInt(base[1] + base[1], 16),
        parseInt(base[2] + base[2], 16)
      ];
      if (size === 4) {
        alpha = parseInt(base[3] + base[3], 16) / 255;
      }
    } else {
      parts = [
        parseInt(base[0] + base[1], 16),
        parseInt(base[2] + base[3], 16),
        parseInt(base[4] + base[5], 16)
      ];
      if (size === 8) {
        alpha = parseInt(base[6] + base[7], 16) / 255;
      }
    }
    if (!parts[0]) parts[0] = 0;
    if (!parts[1]) parts[1] = 0;
    if (!parts[2]) parts[2] = 0;
    space = "rgb";
  } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name = m[1];
    space = name.replace(/a$/, "");
    var dims = space === "cmyk" ? 4 : space === "gray" ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
    if (space === "color") space = parts.shift();
    parts = parts.map(function(x, i) {
      if (x[x.length - 1] === "%") {
        x = parseFloat(x) / 100;
        if (i === 3) return x;
        if (space === "rgb") return x * 255;
        if (space[0] === "h") return x * 100;
        if (space[0] === "l" && !i) return x * 100;
        if (space === "lab") return x * 125;
        if (space === "lch") return i < 2 ? x * 150 : x * 360;
        if (space[0] === "o" && !i) return x;
        if (space === "oklab") return x * 0.4;
        if (space === "oklch") return i < 2 ? x * 0.4 : x * 360;
        return x;
      }
      if (space[i] === "h" || i === 2 && space[space.length - 1] === "h") {
        if (baseHues[x] !== void 0) return baseHues[x];
        if (x.endsWith("deg")) return parseFloat(x);
        if (x.endsWith("turn")) return parseFloat(x) * 360;
        if (x.endsWith("grad")) return parseFloat(x) * 360 / 400;
        if (x.endsWith("rad")) return parseFloat(x) * 180 / Math.PI;
      }
      if (x === "none") return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function(value) {
      return parseFloat(value);
    });
    space = ((_b = (_a = cstr.match(/([a-z])/ig)) == null ? void 0 : _a.join("")) == null ? void 0 : _b.toLowerCase()) || "rgb";
  }
  return {
    space,
    values: parts,
    alpha
  };
}
const hsl = {
  name: "hsl",
  min: [0, 0, 0],
  max: [360, 100, 100],
  channel: ["hue", "saturation", "lightness"],
  alias: ["HSL"],
  rgb: function(hsl2) {
    var h = hsl2[0] / 360, s = hsl2[1] / 100, l = hsl2[2] / 100, t1, t2, t3, rgb2, val, i = 0;
    if (s === 0) return val = l * 255, [val, val, val];
    t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
    t1 = 2 * l - t2;
    rgb2 = [0, 0, 0];
    for (; i < 3; ) {
      t3 = h + 1 / 3 * -(i - 1);
      t3 < 0 ? t3++ : t3 > 1 && t3--;
      val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
      rgb2[i++] = val * 255;
    }
    return rgb2;
  }
};
rgb.hsl = function(rgb2) {
  var r = rgb2[0] / 255, g = rgb2[1] / 255, b = rgb2[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
  if (max === min) {
    h = 0;
  } else if (r === max) {
    h = (g - b) / delta;
  } else if (g === max) {
    h = 2 + (b - r) / delta;
  } else if (b === max) {
    h = 4 + (r - g) / delta;
  }
  h = Math.min(h * 60, 360);
  if (h < 0) {
    h += 360;
  }
  l = (min + max) / 2;
  if (max === min) {
    s = 0;
  } else if (l <= 0.5) {
    s = delta / (max + min);
  } else {
    s = delta / (2 - max - min);
  }
  return [h, s * 100, l * 100];
};
function rgba(color) {
  if (Array.isArray(color) && color.raw) color = String.raw(...arguments);
  if (color instanceof Number) color = +color;
  var values;
  var parsed = parse$1(color);
  if (!parsed.space) return [];
  const min = parsed.space[0] === "h" ? hsl.min : rgb.min;
  const max = parsed.space[0] === "h" ? hsl.max : rgb.max;
  values = Array(3);
  values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
  values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
  values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
  if (parsed.space[0] === "h") {
    values = hsl.rgb(values);
  }
  values.push(Math.min(Math.max(parsed.alpha, 0), 1));
  return values;
}
const NO_COLOR = [NaN, NaN, NaN, 0];
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString(color);
}
const MAX_CACHE_SIZE = 1024;
const cache = {};
let cacheSize = 0;
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}
function rgbaToLcha(color) {
  const output = xyz.lchuv(rgb.xyz(color));
  output[3] = color[3];
  return output;
}
function lchaToRgba(color) {
  const output = xyz.rgb(lchuv.xyz(color));
  output[3] = color[3];
  return output;
}
function fromString(s) {
  if (s === "none") {
    return NO_COLOR;
  }
  if (cache.hasOwnProperty(s)) {
    return cache[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key in cache) {
      if ((i++ & 3) === 0) {
        delete cache[key];
        --cacheSize;
      }
    }
  }
  const color = rgba(s);
  if (color.length !== 4) {
    throw new Error('failed to parse "' + s + '" as color');
  }
  for (const c of color) {
    if (isNaN(c)) {
      throw new Error('failed to parse "' + s + '" as color');
    }
  }
  normalize(color);
  cache[s] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 1e3) / 1e3;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}
const ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
const FIREFOX = ua.includes("firefox");
const SAFARI = ua.includes("safari") && !ua.includes("chrom");
SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
const WEBKIT = ua.includes("webkit") && !ua.includes("edge");
const MAC = ua.includes("macintosh");
const DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
const WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
const IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
const PASSIVE_EVENT_LISTENERS = function() {
  let passive = false;
  try {
    const options = Object.defineProperty({}, "passive", {
      get: function() {
        passive = true;
      }
    });
    window.addEventListener("_", null, options);
    window.removeEventListener("_", null, options);
  } catch (error) {
  }
  return passive;
}();
function createCanvasContext2D(width, height, canvasPool2, settings) {
  let canvas;
  if (canvasPool2 && canvasPool2.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool2.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
let sharedCanvasContext;
function getSharedCanvasContext2D() {
  if (!sharedCanvasContext) {
    sharedCanvasContext = createCanvasContext2D(1, 1);
  }
  return sharedCanvasContext;
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeChildren(node) {
  while (node.lastChild) {
    node.lastChild.remove();
  }
}
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;
  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }
    node.insertBefore(newChild, oldChild);
  }
}
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e) => image.complete && image.width ? resolve(image) : reject(e)
    )
  ) : load(image);
}
class IconImageCache {
  constructor() {
    this.cache_ = {};
    this.patternCache_ = {};
    this.cacheSize_ = 0;
    this.maxCacheSize_ = 32;
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.cache_ = {};
    this.patternCache_ = {};
    this.cacheSize_ = 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.cacheSize_ > this.maxCacheSize_;
  }
  /**
   * FIXME empty description for jsdoc
   */
  expire() {
    if (this.canExpireCache()) {
      let i = 0;
      for (const key in this.cache_) {
        const iconImage = this.cache_[key];
        if ((i++ & 3) === 0 && !iconImage.hasListener()) {
          delete this.cache_[key];
          delete this.patternCache_[key];
          --this.cacheSize_;
        }
      }
    }
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {import("./IconImage.js").default} Icon image.
   */
  get(src, crossOrigin, color) {
    const key = getCacheKey$1(src, crossOrigin, color);
    return key in this.cache_ ? this.cache_[key] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @return {CanvasPattern} Icon image.
   */
  getPattern(src, crossOrigin, color) {
    const key = getCacheKey$1(src, crossOrigin, color);
    return key in this.patternCache_ ? this.patternCache_[key] : null;
  }
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color|string|null} color Color.
   * @param {import("./IconImage.js").default|null} iconImage Icon image.
   * @param {boolean} [pattern] Also cache a `'repeat'` pattern with this `iconImage`.
   */
  set(src, crossOrigin, color, iconImage, pattern) {
    const key = getCacheKey$1(src, crossOrigin, color);
    const update = key in this.cache_;
    this.cache_[key] = iconImage;
    if (pattern) {
      if (iconImage.getImageState() === ImageState.IDLE) {
        iconImage.load();
      }
      if (iconImage.getImageState() === ImageState.LOADING) {
        iconImage.ready().then(() => {
          this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
            iconImage.getImage(1),
            "repeat"
          );
        });
      } else {
        this.patternCache_[key] = getSharedCanvasContext2D().createPattern(
          iconImage.getImage(1),
          "repeat"
        );
      }
    }
    if (!update) {
      ++this.cacheSize_;
    }
  }
  /**
   * Set the cache size of the icon cache. Default is `32`. Change this value when
   * your map uses more than 32 different icon images and you are not caching icon
   * styles on the application level.
   * @param {number} maxCacheSize Cache max size.
   * @api
   */
  setSize(maxCacheSize) {
    this.maxCacheSize_ = maxCacheSize;
    this.expire();
  }
}
function getCacheKey$1(src, crossOrigin, color) {
  const colorString = color ? asArray(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
const shared = new IconImageCache();
let taintedTestContext = null;
class IconImage extends Target {
  /**
   * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap|null} image Image.
   * @param {string|undefined} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default|undefined} imageState Image state.
   * @param {import("../color.js").Color|string|null} color Color.
   */
  constructor(image, src, crossOrigin, imageState, color) {
    super();
    this.hitDetectionImage_ = null;
    this.image_ = image;
    this.crossOrigin_ = crossOrigin;
    this.canvas_ = {};
    this.color_ = color;
    this.imageState_ = imageState === void 0 ? ImageState.IDLE : imageState;
    this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
    this.src_ = src;
    this.tainted_;
    this.ready_ = null;
  }
  /**
   * @private
   */
  initializeImage_() {
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  /**
   * @private
   * @return {boolean} The image canvas is tainted.
   */
  isTainted_() {
    if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
      if (!taintedTestContext) {
        taintedTestContext = createCanvasContext2D(1, 1, void 0, {
          willReadFrequently: true
        });
      }
      taintedTestContext.drawImage(this.image_, 0, 0);
      try {
        taintedTestContext.getImageData(0, 0, 1, 1);
        this.tainted_ = false;
      } catch (e) {
        taintedTestContext = null;
        this.tainted_ = true;
      }
    }
    return this.tainted_ === true;
  }
  /**
   * @private
   */
  dispatchChangeEvent_() {
    this.dispatchEvent(EventType.CHANGE);
  }
  /**
   * @private
   */
  handleImageError_() {
    this.imageState_ = ImageState.ERROR;
    this.dispatchChangeEvent_();
  }
  /**
   * @private
   */
  handleImageLoad_() {
    this.imageState_ = ImageState.LOADED;
    this.size_ = [this.image_.width, this.image_.height];
    this.dispatchChangeEvent_();
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
   */
  getImage(pixelRatio) {
    if (!this.image_) {
      this.initializeImage_();
    }
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Image or Canvas element.
   */
  getPixelRatio(pixelRatio) {
    this.replaceColor_(pixelRatio);
    return this.canvas_[pixelRatio] ? pixelRatio : 1;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   */
  getHitDetectionImage() {
    if (!this.image_) {
      this.initializeImage_();
    }
    if (!this.hitDetectionImage_) {
      if (this.isTainted_()) {
        const width = this.size_[0];
        const height = this.size_[1];
        const context = createCanvasContext2D(width, height);
        context.fillRect(0, 0, width, height);
        this.hitDetectionImage_ = context.canvas;
      } else {
        this.hitDetectionImage_ = this.image_;
      }
    }
    return this.hitDetectionImage_;
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   */
  getSize() {
    return this.size_;
  }
  /**
   * @return {string|undefined} Image src.
   */
  getSrc() {
    return this.src_;
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.imageState_ !== ImageState.IDLE) {
      return;
    }
    if (!this.image_) {
      this.initializeImage_();
    }
    this.imageState_ = ImageState.LOADING;
    try {
      if (this.src_ !== void 0) {
        this.image_.src = this.src_;
      }
    } catch (e) {
      this.handleImageError_();
    }
    if (this.image_ instanceof HTMLImageElement) {
      decodeFallback(this.image_, this.src_).then((image) => {
        this.image_ = image;
        this.handleImageLoad_();
      }).catch(this.handleImageError_.bind(this));
    }
  }
  /**
   * @param {number} pixelRatio Pixel ratio.
   * @private
   */
  replaceColor_(pixelRatio) {
    if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState.LOADED) {
      return;
    }
    const image = this.image_;
    const ctx = createCanvasContext2D(
      Math.ceil(image.width * pixelRatio),
      Math.ceil(image.height * pixelRatio)
    );
    const canvas = ctx.canvas;
    ctx.scale(pixelRatio, pixelRatio);
    ctx.drawImage(image, 0, 0);
    ctx.globalCompositeOperation = "multiply";
    ctx.fillStyle = asString(this.color_);
    ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(image, 0, 0);
    this.canvas_[pixelRatio] = canvas;
  }
  /**
   * @return {Promise<void>} Promise that resolves when the image is loaded.
   */
  ready() {
    if (!this.ready_) {
      this.ready_ = new Promise((resolve) => {
        if (this.imageState_ === ImageState.LOADED || this.imageState_ === ImageState.ERROR) {
          resolve();
        } else {
          const onChange = () => {
            if (this.imageState_ === ImageState.LOADED || this.imageState_ === ImageState.ERROR) {
              this.removeEventListener(EventType.CHANGE, onChange);
              resolve();
            }
          };
          this.addEventListener(EventType.CHANGE, onChange);
        }
      });
    }
    return this.ready_;
  }
}
function get(image, cacheKey, crossOrigin, imageState, color, pattern) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image && "src" in image ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  if (pattern && iconImage && !shared.getPattern(cacheKey, crossOrigin, color)) {
    shared.set(cacheKey, crossOrigin, color, iconImage, pattern);
  }
  return iconImage;
}
function asColorLike(color) {
  if (!color) {
    return null;
  }
  if (Array.isArray(color)) {
    return toString(color);
  }
  if (typeof color === "object" && "src" in color) {
    return asCanvasPattern(color);
  }
  return color;
}
function asCanvasPattern(pattern) {
  if (!pattern.offset || !pattern.size) {
    return shared.getPattern(pattern.src, "anonymous", pattern.color);
  }
  const cacheKey = pattern.src + ":" + pattern.offset;
  const canvasPattern = shared.getPattern(
    cacheKey,
    void 0,
    pattern.color
  );
  if (canvasPattern) {
    return canvasPattern;
  }
  const iconImage = shared.get(pattern.src, "anonymous", null);
  if (iconImage.getImageState() !== ImageState.LOADED) {
    return null;
  }
  const patternCanvasContext = createCanvasContext2D(
    pattern.size[0],
    pattern.size[1]
  );
  patternCanvasContext.drawImage(
    iconImage.getImage(1),
    pattern.offset[0],
    pattern.offset[1],
    pattern.size[0],
    pattern.size[1],
    0,
    0,
    pattern.size[0],
    pattern.size[1]
  );
  get(
    patternCanvasContext.canvas,
    cacheKey,
    void 0,
    ImageState.LOADED,
    pattern.color,
    true
  );
  return shared.getPattern(cacheKey, void 0, pattern.color);
}
const CLASS_HIDDEN = "ol-hidden";
const CLASS_UNSELECTABLE = "ol-unselectable";
const CLASS_CONTROL = "ol-control";
const CLASS_COLLAPSED = "ol-collapsed";
const defaultFillStyle = "#000";
const defaultLineCap = "round";
const defaultLineJoin = "round";
const defaultMiterLimit = 10;
const defaultStrokeStyle = "#000";
const defaultLineWidth = 1;
const checkedFonts = new BaseObject();
class RegularShape extends ImageStyle {
  /**
   * @param {Options} options Options.
   */
  constructor(options) {
    super({
      opacity: 1,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      scale: options.scale !== void 0 ? options.scale : 1,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
    this.canvases_;
    this.hitDetectionCanvas_ = null;
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.origin_ = [0, 0];
    this.points_ = options.points;
    this.radius = options.radius;
    this.radius2_ = options.radius2;
    this.angle_ = options.angle !== void 0 ? options.angle : 0;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.size_;
    this.renderOptions_;
    this.imageState_ = this.fill_ && this.fill_.loading() ? ImageState.LOADING : ImageState.LOADED;
    if (this.imageState_ === ImageState.LOADING) {
      this.ready().then(() => this.imageState_ = ImageState.LOADED);
    }
    this.render();
  }
  /**
   * Clones the style.
   * @return {RegularShape} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale2 = this.getScale();
    const style = new RegularShape({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      points: this.getPoints(),
      radius: this.getRadius(),
      radius2: this.getRadius2(),
      angle: this.getAngle(),
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    const size = this.size_;
    const displacement = this.getDisplacement();
    const scale2 = this.getScaleArray();
    return [
      size[0] / 2 - displacement[0] / scale2[0],
      size[1] / 2 + displacement[1] / scale2[1]
    ];
  }
  /**
   * Get the angle used in generating the shape.
   * @return {number} Shape's rotation in radians.
   * @api
   */
  getAngle() {
    return this.angle_;
  }
  /**
   * Get the fill style for the shape.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
    this.render();
  }
  /**
   * @return {HTMLCanvasElement} Image element.
   * @override
   */
  getHitDetectionImage() {
    if (!this.hitDetectionCanvas_) {
      this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
        this.renderOptions_
      );
    }
    return this.hitDetectionCanvas_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLCanvasElement} Image or Canvas element.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    let image = this.canvases_[pixelRatio];
    if (!image) {
      const renderOptions = this.renderOptions_;
      const context = createCanvasContext2D(
        renderOptions.size * pixelRatio,
        renderOptions.size * pixelRatio
      );
      this.draw_(renderOptions, context, pixelRatio);
      image = context.canvas;
      this.canvases_[pixelRatio] = image;
    }
    return image;
  }
  /**
   * Get the image pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel ratio.
   * @override
   */
  getPixelRatio(pixelRatio) {
    return pixelRatio;
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.size_;
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.imageState_;
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    return this.origin_;
  }
  /**
   * Get the number of points for generating the shape.
   * @return {number} Number of points for stars and regular polygons.
   * @api
   */
  getPoints() {
    return this.points_;
  }
  /**
   * Get the (primary) radius for the shape.
   * @return {number} Radius.
   * @api
   */
  getRadius() {
    return this.radius;
  }
  /**
   * Get the secondary radius for the shape.
   * @return {number|undefined} Radius2.
   * @api
   */
  getRadius2() {
    return this.radius2_;
  }
  /**
   * Get the size of the symbolizer (in pixels).
   * @return {import("../size.js").Size} Size.
   * @api
   * @override
   */
  getSize() {
    return this.size_;
  }
  /**
   * Get the stroke style for the shape.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
    this.render();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {
  }
  /**
   * Calculate additional canvas size needed for the miter.
   * @param {string} lineJoin Line join
   * @param {number} strokeWidth Stroke width
   * @param {number} miterLimit Miter limit
   * @return {number} Additional canvas size needed
   * @private
   */
  calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
    if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
      return strokeWidth;
    }
    let r1 = this.radius;
    let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
    if (r1 < r2) {
      const tmp = r1;
      r1 = r2;
      r2 = tmp;
    }
    const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
    const alpha = 2 * Math.PI / points;
    const a = r2 * Math.sin(alpha);
    const b = Math.sqrt(r2 * r2 - a * a);
    const d = r1 - b;
    const e = Math.sqrt(a * a + d * d);
    const miterRatio = e / a;
    if (lineJoin === "miter" && miterRatio <= miterLimit) {
      return miterRatio * strokeWidth;
    }
    const k = strokeWidth / 2 / miterRatio;
    const l = strokeWidth / 2 * (d / e);
    const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
    const bevelAdd = maxr - r1;
    if (this.radius2_ === void 0 || lineJoin === "bevel") {
      return bevelAdd * 2;
    }
    const aa = r1 * Math.sin(alpha);
    const bb = Math.sqrt(r1 * r1 - aa * aa);
    const dd = r2 - bb;
    const ee = Math.sqrt(aa * aa + dd * dd);
    const innerMiterRatio = ee / aa;
    if (innerMiterRatio <= miterLimit) {
      const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
      return 2 * Math.max(bevelAdd, innerLength);
    }
    return bevelAdd * 2;
  }
  /**
   * @return {RenderOptions}  The render options
   * @protected
   */
  createRenderOptions() {
    let lineCap = defaultLineCap;
    let lineJoin = defaultLineJoin;
    let miterLimit = 0;
    let lineDash = null;
    let lineDashOffset = 0;
    let strokeStyle;
    let strokeWidth = 0;
    if (this.stroke_) {
      strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
      strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
      lineDash = this.stroke_.getLineDash();
      lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
      lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
      lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
      miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
    }
    const add2 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
    const maxRadius = Math.max(this.radius, this.radius2_ || 0);
    const size = Math.ceil(2 * maxRadius + add2);
    return {
      strokeStyle,
      strokeWidth,
      size,
      lineCap,
      lineDash,
      lineDashOffset,
      lineJoin,
      miterLimit
    };
  }
  /**
   * @protected
   */
  render() {
    this.renderOptions_ = this.createRenderOptions();
    const size = this.renderOptions_.size;
    this.canvases_ = {};
    this.hitDetectionCanvas_ = null;
    this.size_ = [size, size];
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The rendering context.
   * @param {number} pixelRatio The pixel ratio.
   */
  draw_(renderOptions, context, pixelRatio) {
    context.scale(pixelRatio, pixelRatio);
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    if (this.fill_) {
      let color = this.fill_.getColor();
      if (color === null) {
        color = defaultFillStyle;
      }
      context.fillStyle = asColorLike(color);
      context.fill();
    }
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineCap = renderOptions.lineCap;
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @return {HTMLCanvasElement} Canvas containing the icon
   */
  createHitDetectionCanvas_(renderOptions) {
    let context;
    if (this.fill_) {
      let color = this.fill_.getColor();
      let opacity = 0;
      if (typeof color === "string") {
        color = asArray(color);
      }
      if (color === null) {
        opacity = 1;
      } else if (Array.isArray(color)) {
        opacity = color.length === 4 ? color[3] : 1;
      }
      if (opacity === 0) {
        context = createCanvasContext2D(renderOptions.size, renderOptions.size);
        this.drawHitDetectionCanvas_(renderOptions, context);
      }
    }
    return context ? context.canvas : this.getImage(1);
  }
  /**
   * @private
   * @param {CanvasRenderingContext2D} context The context to draw in.
   */
  createPath_(context) {
    let points = this.points_;
    const radius = this.radius;
    if (points === Infinity) {
      context.arc(0, 0, radius, 0, 2 * Math.PI);
    } else {
      const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
      if (this.radius2_ !== void 0) {
        points *= 2;
      }
      const startAngle = this.angle_ - Math.PI / 2;
      const step = 2 * Math.PI / points;
      for (let i = 0; i < points; i++) {
        const angle0 = startAngle + i * step;
        const radiusC = i % 2 === 0 ? radius : radius2;
        context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
      }
      context.closePath();
    }
  }
  /**
   * @private
   * @param {RenderOptions} renderOptions Render options.
   * @param {CanvasRenderingContext2D} context The context.
   */
  drawHitDetectionCanvas_(renderOptions, context) {
    context.translate(renderOptions.size / 2, renderOptions.size / 2);
    this.createPath_(context);
    context.fillStyle = defaultFillStyle;
    context.fill();
    if (renderOptions.strokeStyle) {
      context.strokeStyle = renderOptions.strokeStyle;
      context.lineWidth = renderOptions.strokeWidth;
      if (renderOptions.lineDash) {
        context.setLineDash(renderOptions.lineDash);
        context.lineDashOffset = renderOptions.lineDashOffset;
      }
      context.lineJoin = renderOptions.lineJoin;
      context.miterLimit = renderOptions.miterLimit;
      context.stroke();
    }
  }
  /**
   * @override
   */
  ready() {
    return this.fill_ ? this.fill_.ready() : Promise.resolve();
  }
}
class CircleStyle extends RegularShape {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : { radius: 5 };
    super({
      points: Infinity,
      fill: options.fill,
      radius: options.radius,
      stroke: options.stroke,
      scale: options.scale !== void 0 ? options.scale : 1,
      rotation: options.rotation !== void 0 ? options.rotation : 0,
      rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      declutterMode: options.declutterMode
    });
  }
  /**
   * Clones the style.
   * @return {CircleStyle} The cloned style.
   * @api
   * @override
   */
  clone() {
    const scale2 = this.getScale();
    const style = new CircleStyle({
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      radius: this.getRadius(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
    style.setOpacity(this.getOpacity());
    return style;
  }
  /**
   * Set the circle radius.
   *
   * @param {number} radius Circle radius.
   * @api
   */
  setRadius(radius) {
    this.radius = radius;
    this.render();
  }
}
class Fill {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.patternImage_ = null;
    this.color_ = null;
    if (options.color !== void 0) {
      this.setColor(options.color);
    }
  }
  /**
   * Clones the style. The color is not cloned if it is a {@link module:ol/colorlike~ColorLike}.
   * @return {Fill} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Fill({
      color: Array.isArray(color) ? color.slice() : color || void 0
    });
  }
  /**
   * Get the fill color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|import('../colorlike.js').PatternDescriptor|null} color Color.
   * @api
   */
  setColor(color) {
    if (color !== null && typeof color === "object" && "src" in color) {
      const patternImage = get(
        null,
        color.src,
        "anonymous",
        void 0,
        color.offset ? null : color.color ? color.color : null,
        !(color.offset && color.size)
      );
      patternImage.ready().then(() => {
        this.patternImage_ = null;
      });
      if (patternImage.getImageState() === ImageState.IDLE) {
        patternImage.load();
      }
      if (patternImage.getImageState() === ImageState.LOADING) {
        this.patternImage_ = patternImage;
      }
    }
    this.color_ = color;
  }
  /**
   * @return {boolean} The fill style is loading an image pattern.
   */
  loading() {
    return !!this.patternImage_;
  }
  /**
   * @return {Promise<void>} `false` or a promise that resolves when the style is ready to use.
   */
  ready() {
    return this.patternImage_ ? this.patternImage_.ready() : Promise.resolve();
  }
}
class Stroke {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.color_ = options.color !== void 0 ? options.color : null;
    this.lineCap_ = options.lineCap;
    this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
    this.lineDashOffset_ = options.lineDashOffset;
    this.lineJoin_ = options.lineJoin;
    this.miterLimit_ = options.miterLimit;
    this.width_ = options.width;
  }
  /**
   * Clones the style.
   * @return {Stroke} The cloned style.
   * @api
   */
  clone() {
    const color = this.getColor();
    return new Stroke({
      color: Array.isArray(color) ? color.slice() : color || void 0,
      lineCap: this.getLineCap(),
      lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
      lineDashOffset: this.getLineDashOffset(),
      lineJoin: this.getLineJoin(),
      miterLimit: this.getMiterLimit(),
      width: this.getWidth()
    });
  }
  /**
   * Get the stroke color.
   * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the line cap type for the stroke.
   * @return {CanvasLineCap|undefined} Line cap.
   * @api
   */
  getLineCap() {
    return this.lineCap_;
  }
  /**
   * Get the line dash style for the stroke.
   * @return {Array<number>|null} Line dash.
   * @api
   */
  getLineDash() {
    return this.lineDash_;
  }
  /**
   * Get the line dash offset for the stroke.
   * @return {number|undefined} Line dash offset.
   * @api
   */
  getLineDashOffset() {
    return this.lineDashOffset_;
  }
  /**
   * Get the line join type for the stroke.
   * @return {CanvasLineJoin|undefined} Line join.
   * @api
   */
  getLineJoin() {
    return this.lineJoin_;
  }
  /**
   * Get the miter limit for the stroke.
   * @return {number|undefined} Miter limit.
   * @api
   */
  getMiterLimit() {
    return this.miterLimit_;
  }
  /**
   * Get the stroke width.
   * @return {number|undefined} Width.
   * @api
   */
  getWidth() {
    return this.width_;
  }
  /**
   * Set the color.
   *
   * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
   * @api
   */
  setColor(color) {
    this.color_ = color;
  }
  /**
   * Set the line cap.
   *
   * @param {CanvasLineCap|undefined} lineCap Line cap.
   * @api
   */
  setLineCap(lineCap) {
    this.lineCap_ = lineCap;
  }
  /**
   * Set the line dash.
   *
   * @param {Array<number>|null} lineDash Line dash.
   * @api
   */
  setLineDash(lineDash) {
    this.lineDash_ = lineDash;
  }
  /**
   * Set the line dash offset.
   *
   * @param {number|undefined} lineDashOffset Line dash offset.
   * @api
   */
  setLineDashOffset(lineDashOffset) {
    this.lineDashOffset_ = lineDashOffset;
  }
  /**
   * Set the line join.
   *
   * @param {CanvasLineJoin|undefined} lineJoin Line join.
   * @api
   */
  setLineJoin(lineJoin) {
    this.lineJoin_ = lineJoin;
  }
  /**
   * Set the miter limit.
   *
   * @param {number|undefined} miterLimit Miter limit.
   * @api
   */
  setMiterLimit(miterLimit) {
    this.miterLimit_ = miterLimit;
  }
  /**
   * Set the width.
   *
   * @param {number|undefined} width Width.
   * @api
   */
  setWidth(width) {
    this.width_ = width;
  }
}
class Style {
  /**
   * @param {Options} [options] Style options.
   */
  constructor(options) {
    options = options || {};
    this.geometry_ = null;
    this.geometryFunction_ = defaultGeometryFunction;
    if (options.geometry !== void 0) {
      this.setGeometry(options.geometry);
    }
    this.fill_ = options.fill !== void 0 ? options.fill : null;
    this.image_ = options.image !== void 0 ? options.image : null;
    this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
    this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.text_ = options.text !== void 0 ? options.text : null;
    this.zIndex_ = options.zIndex;
  }
  /**
   * Clones the style.
   * @return {Style} The cloned style.
   * @api
   */
  clone() {
    let geometry = this.getGeometry();
    if (geometry && typeof geometry === "object") {
      geometry = /** @type {import("../geom/Geometry.js").default} */
      geometry.clone();
    }
    return new Style({
      geometry: geometry ?? void 0,
      fill: this.getFill() ? this.getFill().clone() : void 0,
      image: this.getImage() ? this.getImage().clone() : void 0,
      renderer: this.getRenderer() ?? void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      text: this.getText() ? this.getText().clone() : void 0,
      zIndex: this.getZIndex()
    });
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setRenderer} or the `renderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Sets a custom renderer function for this style. When set, `fill`, `stroke`
   * and `image` options of the style will be ignored.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setRenderer(renderer) {
    this.renderer_ = renderer;
  }
  /**
   * Sets a custom renderer function for this style used
   * in hit detection.
   * @param {RenderFunction|null} renderer Custom renderer function.
   * @api
   */
  setHitDetectionRenderer(renderer) {
    this.hitDetectionRenderer_ = renderer;
  }
  /**
   * Get the custom renderer function that was configured with
   * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
   * @return {RenderFunction|null} Custom renderer function.
   * @api
   */
  getHitDetectionRenderer() {
    return this.hitDetectionRenderer_;
  }
  /**
   * Get the geometry to be rendered.
   * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
   * Feature property or geometry or function that returns the geometry that will
   * be rendered with this style.
   * @api
   */
  getGeometry() {
    return this.geometry_;
  }
  /**
   * Get the function used to generate a geometry for rendering.
   * @return {!GeometryFunction} Function that is called with a feature
   * and returns the geometry to render instead of the feature's geometry.
   * @api
   */
  getGeometryFunction() {
    return this.geometryFunction_;
  }
  /**
   * Get the fill style.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Set the fill style.
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }
  /**
   * Get the image style.
   * @return {import("./Image.js").default|null} Image style.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Set the image style.
   * @param {import("./Image.js").default} image Image style.
   * @api
   */
  setImage(image) {
    this.image_ = image;
  }
  /**
   * Get the stroke style.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Set the stroke style.
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  /**
   * Get the text style.
   * @return {import("./Text.js").default|null} Text style.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Set the text style.
   * @param {import("./Text.js").default} text Text style.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }
  /**
   * Get the z-index for the style.
   * @return {number|undefined} ZIndex.
   * @api
   */
  getZIndex() {
    return this.zIndex_;
  }
  /**
   * Set a geometry that is rendered instead of the feature's geometry.
   *
   * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
   *     Feature property or geometry or function returning a geometry to render
   *     for this style.
   * @api
   */
  setGeometry(geometry) {
    if (typeof geometry === "function") {
      this.geometryFunction_ = geometry;
    } else if (typeof geometry === "string") {
      this.geometryFunction_ = function(feature) {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          feature.get(geometry)
        );
      };
    } else if (!geometry) {
      this.geometryFunction_ = defaultGeometryFunction;
    } else if (geometry !== void 0) {
      this.geometryFunction_ = function() {
        return (
          /** @type {import("../geom/Geometry.js").default} */
          geometry
        );
      };
    }
    this.geometry_ = geometry;
  }
  /**
   * Set the z-index.
   *
   * @param {number|undefined} zIndex ZIndex.
   * @api
   */
  setZIndex(zIndex) {
    this.zIndex_ = zIndex;
  }
}
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `Style` or an array of `Style`"
      );
      const style = (
        /** @type {Style} */
        obj
      );
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
let defaultStyles = null;
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new CircleStyle({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
class Icon extends ImageStyle {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    const opacity = options.opacity !== void 0 ? options.opacity : 1;
    const rotation = options.rotation !== void 0 ? options.rotation : 0;
    const scale2 = options.scale !== void 0 ? options.scale : 1;
    const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
    super({
      opacity,
      rotation,
      scale: scale2,
      displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
      rotateWithView,
      declutterMode: options.declutterMode
    });
    this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
    this.normalizedAnchor_ = null;
    this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
    this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
    this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
    this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    const image = options.img !== void 0 ? options.img : null;
    let cacheKey = options.src;
    assert(
      !(cacheKey !== void 0 && image),
      "`image` and `src` cannot be provided at the same time"
    );
    if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
      cacheKey = /** @type {HTMLImageElement} */
      image.src || getUid(image);
    }
    assert(
      cacheKey !== void 0 && cacheKey.length > 0,
      "A defined and non-empty `src` or `image` must be provided"
    );
    assert(
      !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
      "`width` or `height` cannot be provided together with `scale`"
    );
    let imageState;
    if (options.src !== void 0) {
      imageState = ImageState.IDLE;
    } else if (image !== void 0) {
      if ("complete" in image) {
        if (image.complete) {
          imageState = image.src ? ImageState.LOADED : ImageState.IDLE;
        } else {
          imageState = ImageState.LOADING;
        }
      } else {
        imageState = ImageState.LOADED;
      }
    }
    this.color_ = options.color !== void 0 ? asArray(options.color) : null;
    this.iconImage_ = get(
      image,
      /** @type {string} */
      cacheKey,
      this.crossOrigin_,
      imageState,
      this.color_
    );
    this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
    this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
    this.origin_ = null;
    this.size_ = options.size !== void 0 ? options.size : null;
    this.initialOptions_;
    if (options.width !== void 0 || options.height !== void 0) {
      let width, height;
      if (options.size) {
        [width, height] = options.size;
      } else {
        const image2 = this.getImage(1);
        if (image2.width && image2.height) {
          width = image2.width;
          height = image2.height;
        } else if (image2 instanceof HTMLImageElement) {
          this.initialOptions_ = options;
          const onload = () => {
            this.unlistenImageChange(onload);
            if (!this.initialOptions_) {
              return;
            }
            const imageSize = this.iconImage_.getSize();
            this.setScale(
              calculateScale(
                imageSize[0],
                imageSize[1],
                options.width,
                options.height
              )
            );
          };
          this.listenImageChange(onload);
          return;
        }
      }
      if (width !== void 0) {
        this.setScale(
          calculateScale(width, height, options.width, options.height)
        );
      }
    }
  }
  /**
   * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
   * @return {Icon} The cloned style.
   * @api
   * @override
   */
  clone() {
    let scale2, width, height;
    if (this.initialOptions_) {
      width = this.initialOptions_.width;
      height = this.initialOptions_.height;
    } else {
      scale2 = this.getScale();
      scale2 = Array.isArray(scale2) ? scale2.slice() : scale2;
    }
    return new Icon({
      anchor: this.anchor_.slice(),
      anchorOrigin: this.anchorOrigin_,
      anchorXUnits: this.anchorXUnits_,
      anchorYUnits: this.anchorYUnits_,
      color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
      crossOrigin: this.crossOrigin_,
      offset: this.offset_.slice(),
      offsetOrigin: this.offsetOrigin_,
      opacity: this.getOpacity(),
      rotateWithView: this.getRotateWithView(),
      rotation: this.getRotation(),
      scale: scale2,
      width,
      height,
      size: this.size_ !== null ? this.size_.slice() : void 0,
      src: this.getSrc(),
      displacement: this.getDisplacement().slice(),
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the anchor point in pixels. The anchor determines the center point for the
   * symbolizer.
   * @return {Array<number>} Anchor.
   * @api
   * @override
   */
  getAnchor() {
    let anchor = this.normalizedAnchor_;
    if (!anchor) {
      anchor = this.anchor_;
      const size = this.getSize();
      if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
        if (!size) {
          return null;
        }
        anchor = this.anchor_.slice();
        if (this.anchorXUnits_ == "fraction") {
          anchor[0] *= size[0];
        }
        if (this.anchorYUnits_ == "fraction") {
          anchor[1] *= size[1];
        }
      }
      if (this.anchorOrigin_ != "top-left") {
        if (!size) {
          return null;
        }
        if (anchor === this.anchor_) {
          anchor = this.anchor_.slice();
        }
        if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
          anchor[0] = -anchor[0] + size[0];
        }
        if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
          anchor[1] = -anchor[1] + size[1];
        }
      }
      this.normalizedAnchor_ = anchor;
    }
    const displacement = this.getDisplacement();
    const scale2 = this.getScaleArray();
    return [
      anchor[0] - displacement[0] / scale2[0],
      anchor[1] + displacement[1] / scale2[1]
    ];
  }
  /**
   * Set the anchor point. The anchor determines the center point for the
   * symbolizer.
   *
   * @param {Array<number>} anchor Anchor.
   * @api
   */
  setAnchor(anchor) {
    this.anchor_ = anchor;
    this.normalizedAnchor_ = null;
  }
  /**
   * Get the icon color.
   * @return {import("../color.js").Color} Color.
   * @api
   */
  getColor() {
    return this.color_;
  }
  /**
   * Get the image icon.
   * @param {number} pixelRatio Pixel ratio.
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
   * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
   * @api
   * @override
   */
  getImage(pixelRatio) {
    return this.iconImage_.getImage(pixelRatio);
  }
  /**
   * Get the pixel ratio.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} The pixel ratio of the image.
   * @api
   * @override
   */
  getPixelRatio(pixelRatio) {
    return this.iconImage_.getPixelRatio(pixelRatio);
  }
  /**
   * @return {import("../size.js").Size} Image size.
   * @override
   */
  getImageSize() {
    return this.iconImage_.getSize();
  }
  /**
   * @return {import("../ImageState.js").default} Image state.
   * @override
   */
  getImageState() {
    return this.iconImage_.getImageState();
  }
  /**
   * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
   * @override
   */
  getHitDetectionImage() {
    return this.iconImage_.getHitDetectionImage();
  }
  /**
   * Get the origin of the symbolizer.
   * @return {Array<number>} Origin.
   * @api
   * @override
   */
  getOrigin() {
    if (this.origin_) {
      return this.origin_;
    }
    let offset = this.offset_;
    if (this.offsetOrigin_ != "top-left") {
      const size = this.getSize();
      const iconImageSize = this.iconImage_.getSize();
      if (!size || !iconImageSize) {
        return null;
      }
      offset = offset.slice();
      if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
        offset[0] = iconImageSize[0] - size[0] - offset[0];
      }
      if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
        offset[1] = iconImageSize[1] - size[1] - offset[1];
      }
    }
    this.origin_ = offset;
    return this.origin_;
  }
  /**
   * Get the image URL.
   * @return {string|undefined} Image src.
   * @api
   */
  getSrc() {
    return this.iconImage_.getSrc();
  }
  /**
   * Get the size of the icon (in pixels).
   * @return {import("../size.js").Size} Image size.
   * @api
   * @override
   */
  getSize() {
    return !this.size_ ? this.iconImage_.getSize() : this.size_;
  }
  /**
   * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon width (in pixels).
   * @api
   */
  getWidth() {
    const scale2 = this.getScaleArray();
    if (this.size_) {
      return this.size_[0] * scale2[0];
    }
    if (this.iconImage_.getImageState() == ImageState.LOADED) {
      return this.iconImage_.getSize()[0] * scale2[0];
    }
    return void 0;
  }
  /**
   * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
   * @return {number} Icon height (in pixels).
   * @api
   */
  getHeight() {
    const scale2 = this.getScaleArray();
    if (this.size_) {
      return this.size_[1] * scale2[1];
    }
    if (this.iconImage_.getImageState() == ImageState.LOADED) {
      return this.iconImage_.getSize()[1] * scale2[1];
    }
    return void 0;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size} scale Scale.
   * @api
   * @override
   */
  setScale(scale2) {
    delete this.initialOptions_;
    super.setScale(scale2);
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  listenImageChange(listener) {
    this.iconImage_.addEventListener(EventType.CHANGE, listener);
  }
  /**
   * Load not yet loaded URI.
   * When rendering a feature with an icon style, the vector renderer will
   * automatically call this method. However, you might want to call this
   * method yourself for preloading or other purposes.
   * @api
   * @override
   */
  load() {
    this.iconImage_.load();
  }
  /**
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @override
   */
  unlistenImageChange(listener) {
    this.iconImage_.removeEventListener(EventType.CHANGE, listener);
  }
  /**
   * @override
   */
  ready() {
    return this.iconImage_.ready();
  }
}
const DEFAULT_FILL_COLOR = "#333";
class Text {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options || {};
    this.font_ = options.font;
    this.rotation_ = options.rotation;
    this.rotateWithView_ = options.rotateWithView;
    this.scale_ = options.scale;
    this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
    this.text_ = options.text;
    this.textAlign_ = options.textAlign;
    this.justify_ = options.justify;
    this.repeat_ = options.repeat;
    this.textBaseline_ = options.textBaseline;
    this.fill_ = options.fill !== void 0 ? options.fill : new Fill({ color: DEFAULT_FILL_COLOR });
    this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
    this.placement_ = options.placement !== void 0 ? options.placement : "point";
    this.overflow_ = !!options.overflow;
    this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
    this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
    this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
    this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
    this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
    this.padding_ = options.padding === void 0 ? null : options.padding;
    this.declutterMode_ = options.declutterMode;
  }
  /**
   * Clones the style.
   * @return {Text} The cloned style.
   * @api
   */
  clone() {
    const scale2 = this.getScale();
    return new Text({
      font: this.getFont(),
      placement: this.getPlacement(),
      repeat: this.getRepeat(),
      maxAngle: this.getMaxAngle(),
      overflow: this.getOverflow(),
      rotation: this.getRotation(),
      rotateWithView: this.getRotateWithView(),
      scale: Array.isArray(scale2) ? scale2.slice() : scale2,
      text: this.getText(),
      textAlign: this.getTextAlign(),
      justify: this.getJustify(),
      textBaseline: this.getTextBaseline(),
      fill: this.getFill() ? this.getFill().clone() : void 0,
      stroke: this.getStroke() ? this.getStroke().clone() : void 0,
      offsetX: this.getOffsetX(),
      offsetY: this.getOffsetY(),
      backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
      backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
      padding: this.getPadding() || void 0,
      declutterMode: this.getDeclutterMode()
    });
  }
  /**
   * Get the `overflow` configuration.
   * @return {boolean} Let text overflow the length of the path they follow.
   * @api
   */
  getOverflow() {
    return this.overflow_;
  }
  /**
   * Get the font name.
   * @return {string|undefined} Font.
   * @api
   */
  getFont() {
    return this.font_;
  }
  /**
   * Get the maximum angle between adjacent characters.
   * @return {number} Angle in radians.
   * @api
   */
  getMaxAngle() {
    return this.maxAngle_;
  }
  /**
   * Get the label placement.
   * @return {TextPlacement} Text placement.
   * @api
   */
  getPlacement() {
    return this.placement_;
  }
  /**
   * Get the repeat interval of the text.
   * @return {number|undefined} Repeat interval in pixels.
   * @api
   */
  getRepeat() {
    return this.repeat_;
  }
  /**
   * Get the x-offset for the text.
   * @return {number} Horizontal text offset.
   * @api
   */
  getOffsetX() {
    return this.offsetX_;
  }
  /**
   * Get the y-offset for the text.
   * @return {number} Vertical text offset.
   * @api
   */
  getOffsetY() {
    return this.offsetY_;
  }
  /**
   * Get the fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getFill() {
    return this.fill_;
  }
  /**
   * Determine whether the text rotates with the map.
   * @return {boolean|undefined} Rotate with map.
   * @api
   */
  getRotateWithView() {
    return this.rotateWithView_;
  }
  /**
   * Get the text rotation.
   * @return {number|undefined} Rotation.
   * @api
   */
  getRotation() {
    return this.rotation_;
  }
  /**
   * Get the text scale.
   * @return {number|import("../size.js").Size|undefined} Scale.
   * @api
   */
  getScale() {
    return this.scale_;
  }
  /**
   * Get the symbolizer scale array.
   * @return {import("../size.js").Size} Scale array.
   */
  getScaleArray() {
    return this.scaleArray_;
  }
  /**
   * Get the stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getStroke() {
    return this.stroke_;
  }
  /**
   * Get the text to be rendered.
   * @return {string|Array<string>|undefined} Text.
   * @api
   */
  getText() {
    return this.text_;
  }
  /**
   * Get the text alignment.
   * @return {CanvasTextAlign|undefined} Text align.
   * @api
   */
  getTextAlign() {
    return this.textAlign_;
  }
  /**
   * Get the justification.
   * @return {TextJustify|undefined} Justification.
   * @api
   */
  getJustify() {
    return this.justify_;
  }
  /**
   * Get the text baseline.
   * @return {CanvasTextBaseline|undefined} Text baseline.
   * @api
   */
  getTextBaseline() {
    return this.textBaseline_;
  }
  /**
   * Get the background fill style for the text.
   * @return {import("./Fill.js").default|null} Fill style.
   * @api
   */
  getBackgroundFill() {
    return this.backgroundFill_;
  }
  /**
   * Get the background stroke style for the text.
   * @return {import("./Stroke.js").default|null} Stroke style.
   * @api
   */
  getBackgroundStroke() {
    return this.backgroundStroke_;
  }
  /**
   * Get the padding for the text.
   * @return {Array<number>|null} Padding.
   * @api
   */
  getPadding() {
    return this.padding_;
  }
  /**
   * Get the declutter mode of the shape
   * @return {import("./Style.js").DeclutterMode} Shape's declutter mode
   * @api
   */
  getDeclutterMode() {
    return this.declutterMode_;
  }
  /**
   * Set the `overflow` property.
   *
   * @param {boolean} overflow Let text overflow the path that it follows.
   * @api
   */
  setOverflow(overflow) {
    this.overflow_ = overflow;
  }
  /**
   * Set the font.
   *
   * @param {string|undefined} font Font.
   * @api
   */
  setFont(font) {
    this.font_ = font;
  }
  /**
   * Set the maximum angle between adjacent characters.
   *
   * @param {number} maxAngle Angle in radians.
   * @api
   */
  setMaxAngle(maxAngle) {
    this.maxAngle_ = maxAngle;
  }
  /**
   * Set the x offset.
   *
   * @param {number} offsetX Horizontal text offset.
   * @api
   */
  setOffsetX(offsetX) {
    this.offsetX_ = offsetX;
  }
  /**
   * Set the y offset.
   *
   * @param {number} offsetY Vertical text offset.
   * @api
   */
  setOffsetY(offsetY) {
    this.offsetY_ = offsetY;
  }
  /**
   * Set the text placement.
   *
   * @param {TextPlacement} placement Placement.
   * @api
   */
  setPlacement(placement) {
    this.placement_ = placement;
  }
  /**
   * Set the repeat interval of the text.
   * @param {number|undefined} [repeat] Repeat interval in pixels.
   * @api
   */
  setRepeat(repeat) {
    this.repeat_ = repeat;
  }
  /**
   * Set whether to rotate the text with the view.
   *
   * @param {boolean} rotateWithView Rotate with map.
   * @api
   */
  setRotateWithView(rotateWithView) {
    this.rotateWithView_ = rotateWithView;
  }
  /**
   * Set the fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setFill(fill) {
    this.fill_ = fill;
  }
  /**
   * Set the rotation.
   *
   * @param {number|undefined} rotation Rotation.
   * @api
   */
  setRotation(rotation) {
    this.rotation_ = rotation;
  }
  /**
   * Set the scale.
   *
   * @param {number|import("../size.js").Size|undefined} scale Scale.
   * @api
   */
  setScale(scale2) {
    this.scale_ = scale2;
    this.scaleArray_ = toSize(scale2 !== void 0 ? scale2 : 1);
  }
  /**
   * Set the stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setStroke(stroke) {
    this.stroke_ = stroke;
  }
  /**
   * Set the text.
   *
   * @param {string|Array<string>|undefined} text Text.
   * @api
   */
  setText(text) {
    this.text_ = text;
  }
  /**
   * Set the text alignment.
   *
   * @param {CanvasTextAlign|undefined} textAlign Text align.
   * @api
   */
  setTextAlign(textAlign) {
    this.textAlign_ = textAlign;
  }
  /**
   * Set the justification.
   *
   * @param {TextJustify|undefined} justify Justification.
   * @api
   */
  setJustify(justify) {
    this.justify_ = justify;
  }
  /**
   * Set the text baseline.
   *
   * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
   * @api
   */
  setTextBaseline(textBaseline) {
    this.textBaseline_ = textBaseline;
  }
  /**
   * Set the background fill.
   *
   * @param {import("./Fill.js").default|null} fill Fill style.
   * @api
   */
  setBackgroundFill(fill) {
    this.backgroundFill_ = fill;
  }
  /**
   * Set the background stroke.
   *
   * @param {import("./Stroke.js").default|null} stroke Stroke style.
   * @api
   */
  setBackgroundStroke(stroke) {
    this.backgroundStroke_ = stroke;
  }
  /**
   * Set the padding (`[top, right, bottom, left]`).
   *
   * @param {Array<number>|null} padding Padding.
   * @api
   */
  setPadding(padding) {
    this.padding_ = padding;
  }
}
let numTypes = 0;
const BooleanType = 1 << numTypes++;
const NumberType = 1 << numTypes++;
const StringType = 1 << numTypes++;
const ColorType = 1 << numTypes++;
const NumberArrayType = 1 << numTypes++;
const SizeType = 1 << numTypes++;
const AnyType = Math.pow(2, numTypes) - 1;
const typeNames = {
  [BooleanType]: "boolean",
  [NumberType]: "number",
  [StringType]: "string",
  [ColorType]: "color",
  [NumberArrayType]: "number[]",
  [SizeType]: "size"
};
const namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
function isSpecific(type) {
  return type in typeNames;
}
function typeName(type) {
  const names2 = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names2.push(typeNames[namedType]);
    }
  }
  if (names2.length === 0) {
    return "untyped";
  }
  if (names2.length < 3) {
    return names2.join(" or ");
  }
  return names2.slice(0, -1).join(", ") + ", or " + names2[names2.length - 1];
}
function includesType(broad, specific) {
  return (broad & specific) === specific;
}
function isType(type, expected) {
  return type === expected;
}
class LiteralExpression {
  /**
   * @param {number} type The value type.
   * @param {LiteralValue} value The literal value.
   */
  constructor(type, value) {
    if (!isSpecific(type)) {
      throw new Error(
        `literal expressions must have a specific type, got ${typeName(type)}`
      );
    }
    this.type = type;
    this.value = value;
  }
}
class CallExpression {
  /**
   * @param {number} type The return type.
   * @param {string} operator The operator.
   * @param {...Expression} args The arguments.
   */
  constructor(type, operator, ...args) {
    this.type = type;
    this.operator = operator;
    this.args = args;
  }
}
function newParsingContext() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: false,
    geometryType: false
  };
}
function parse(encoded, expectedType, context) {
  switch (typeof encoded) {
    case "boolean": {
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded ? "true" : "false");
      }
      if (!includesType(expectedType, BooleanType)) {
        throw new Error(
          `got a boolean, but expected ${typeName(expectedType)}`
        );
      }
      return new LiteralExpression(BooleanType, encoded);
    }
    case "number": {
      if (isType(expectedType, SizeType)) {
        return new LiteralExpression(SizeType, toSize(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (isType(expectedType, StringType)) {
        return new LiteralExpression(StringType, encoded.toString());
      }
      if (!includesType(expectedType, NumberType)) {
        throw new Error(`got a number, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(NumberType, encoded);
    }
    case "string": {
      if (isType(expectedType, ColorType)) {
        return new LiteralExpression(ColorType, fromString(encoded));
      }
      if (isType(expectedType, BooleanType)) {
        return new LiteralExpression(BooleanType, !!encoded);
      }
      if (!includesType(expectedType, StringType)) {
        throw new Error(`got a string, but expected ${typeName(expectedType)}`);
      }
      return new LiteralExpression(StringType, encoded);
    }
  }
  if (!Array.isArray(encoded)) {
    throw new Error("expression must be an array or a primitive value");
  }
  if (encoded.length === 0) {
    throw new Error("empty expression");
  }
  if (typeof encoded[0] === "string") {
    return parseCallExpression(encoded, expectedType, context);
  }
  for (const item of encoded) {
    if (typeof item !== "number") {
      throw new Error("expected an array of numbers");
    }
  }
  if (isType(expectedType, SizeType)) {
    if (encoded.length !== 2) {
      throw new Error(
        `expected an array of two values for a size, got ${encoded.length}`
      );
    }
    return new LiteralExpression(SizeType, encoded);
  }
  if (isType(expectedType, ColorType)) {
    if (encoded.length === 3) {
      return new LiteralExpression(ColorType, [...encoded, 1]);
    }
    if (encoded.length === 4) {
      return new LiteralExpression(ColorType, encoded);
    }
    throw new Error(
      `expected an array of 3 or 4 values for a color, got ${encoded.length}`
    );
  }
  if (!includesType(expectedType, NumberArrayType)) {
    throw new Error(
      `got an array of numbers, but expected ${typeName(expectedType)}`
    );
  }
  return new LiteralExpression(NumberArrayType, encoded);
}
const Ops = {
  Get: "get",
  Var: "var",
  Concat: "concat",
  GeometryType: "geometry-type",
  LineMetric: "line-metric",
  Any: "any",
  All: "all",
  Not: "!",
  Resolution: "resolution",
  Zoom: "zoom",
  Time: "time",
  Equal: "==",
  NotEqual: "!=",
  GreaterThan: ">",
  GreaterThanOrEqualTo: ">=",
  LessThan: "<",
  LessThanOrEqualTo: "<=",
  Multiply: "*",
  Divide: "/",
  Add: "+",
  Subtract: "-",
  Clamp: "clamp",
  Mod: "%",
  Pow: "^",
  Abs: "abs",
  Floor: "floor",
  Ceil: "ceil",
  Round: "round",
  Sin: "sin",
  Cos: "cos",
  Atan: "atan",
  Sqrt: "sqrt",
  Match: "match",
  Between: "between",
  Interpolate: "interpolate",
  Coalesce: "coalesce",
  Case: "case",
  In: "in",
  Number: "number",
  String: "string",
  Array: "array",
  Color: "color",
  Id: "id",
  Band: "band",
  Palette: "palette",
  ToString: "to-string",
  Has: "has"
};
const parsers = {
  [Ops.Get]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Var]: createCallExpressionParser(hasArgsCount(1, 1), withVarArgs),
  [Ops.Has]: createCallExpressionParser(hasArgsCount(1, Infinity), withGetArgs),
  [Ops.Id]: createCallExpressionParser(usesFeatureId, withNoArgs),
  [Ops.Concat]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(StringType)
  ),
  [Ops.GeometryType]: createCallExpressionParser(usesGeometryType, withNoArgs),
  [Ops.LineMetric]: createCallExpressionParser(withNoArgs),
  [Ops.Resolution]: createCallExpressionParser(withNoArgs),
  [Ops.Zoom]: createCallExpressionParser(withNoArgs),
  [Ops.Time]: createCallExpressionParser(withNoArgs),
  [Ops.Any]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType)
  ),
  [Ops.All]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(BooleanType)
  ),
  [Ops.Not]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType)
  ),
  [Ops.Equal]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType)
  ),
  [Ops.NotEqual]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(AnyType)
  ),
  [Ops.GreaterThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.GreaterThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.LessThan]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.LessThanOrEqualTo]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Multiply]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType
  ),
  [Ops.Coalesce]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfReturnType
  ),
  [Ops.Divide]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Add]: createCallExpressionParser(
    hasArgsCount(2, Infinity),
    withArgsOfType(NumberType)
  ),
  [Ops.Subtract]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Clamp]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Mod]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Pow]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Abs]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Floor]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Ceil]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Round]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Sin]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Cos]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Atan]: createCallExpressionParser(
    hasArgsCount(1, 2),
    withArgsOfType(NumberType)
  ),
  [Ops.Sqrt]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(NumberType)
  ),
  [Ops.Match]: createCallExpressionParser(
    hasArgsCount(4, Infinity),
    hasEvenArgs,
    withMatchArgs
  ),
  [Ops.Between]: createCallExpressionParser(
    hasArgsCount(3, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Interpolate]: createCallExpressionParser(
    hasArgsCount(6, Infinity),
    hasEvenArgs,
    withInterpolateArgs
  ),
  [Ops.Case]: createCallExpressionParser(
    hasArgsCount(3, Infinity),
    hasOddArgs,
    withCaseArgs
  ),
  [Ops.In]: createCallExpressionParser(hasArgsCount(2, 2), withInArgs),
  [Ops.Number]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType)
  ),
  [Ops.String]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(AnyType)
  ),
  [Ops.Array]: createCallExpressionParser(
    hasArgsCount(1, Infinity),
    withArgsOfType(NumberType)
  ),
  [Ops.Color]: createCallExpressionParser(
    hasArgsCount(1, 4),
    withArgsOfType(NumberType)
  ),
  [Ops.Band]: createCallExpressionParser(
    hasArgsCount(1, 3),
    withArgsOfType(NumberType)
  ),
  [Ops.Palette]: createCallExpressionParser(
    hasArgsCount(2, 2),
    withPaletteArgs
  ),
  [Ops.ToString]: createCallExpressionParser(
    hasArgsCount(1, 1),
    withArgsOfType(BooleanType | NumberType | StringType | ColorType)
  )
};
function withGetArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const args = new Array(argsCount);
  for (let i = 0; i < argsCount; ++i) {
    const key = encoded[i + 1];
    switch (typeof key) {
      case "number": {
        args[i] = new LiteralExpression(NumberType, key);
        break;
      }
      case "string": {
        args[i] = new LiteralExpression(StringType, key);
        break;
      }
      default: {
        throw new Error(
          `expected a string key or numeric array index for a get operation, got ${key}`
        );
      }
    }
    if (i === 0) {
      context.properties.add(String(key));
    }
  }
  return args;
}
function withVarArgs(encoded, returnType, context) {
  const name = encoded[1];
  if (typeof name !== "string") {
    throw new Error("expected a string argument for var operation");
  }
  context.variables.add(name);
  return [new LiteralExpression(StringType, name)];
}
function usesFeatureId(encoded, returnType, context) {
  context.featureId = true;
}
function usesGeometryType(encoded, returnType, context) {
  context.geometryType = true;
}
function withNoArgs(encoded, returnType, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`expected no arguments for ${operation} operation`);
  }
  return [];
}
function hasArgsCount(minArgs, maxArgs) {
  return function(encoded, returnType, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? "" : "s";
        throw new Error(
          `expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `expected ${range} arguments for ${operation}, got ${argCount}`
      );
    }
  };
}
function withArgsOfReturnType(encoded, returnType, context) {
  const argCount = encoded.length - 1;
  const args = new Array(argCount);
  for (let i = 0; i < argCount; ++i) {
    const expression = parse(encoded[i + 1], returnType, context);
    args[i] = expression;
  }
  return args;
}
function withArgsOfType(argType) {
  return function(encoded, returnType, context) {
    const argCount = encoded.length - 1;
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse(encoded[i + 1], argType, context);
      args[i] = expression;
    }
    return args;
  };
}
function hasOddArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `expected an odd number of arguments for ${operation}, got ${argCount} instead`
    );
  }
}
function hasEvenArgs(encoded, returnType, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `expected an even number of arguments for operation ${operation}, got ${argCount} instead`
    );
  }
}
function withMatchArgs(encoded, returnType, context) {
  const argsCount = encoded.length - 1;
  const inputType = StringType | NumberType | BooleanType;
  const input = parse(encoded[1], inputType, context);
  const fallback2 = parse(encoded[encoded.length - 1], returnType, context);
  const args = new Array(argsCount - 2);
  for (let i = 0; i < argsCount - 2; i += 2) {
    try {
      const match = parse(encoded[i + 2], input.type, context);
      args[i] = match;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of match expression: ${err.message}`
      );
    }
    try {
      const output = parse(encoded[i + 3], fallback2.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} of match expression: ${err.message}`
      );
    }
  }
  return [input, ...args, fallback2];
}
function withInterpolateArgs(encoded, returnType, context) {
  const interpolationType = encoded[1];
  let base;
  switch (interpolationType[0]) {
    case "linear":
      base = 1;
      break;
    case "exponential":
      const b = interpolationType[1];
      if (typeof b !== "number" || b <= 0) {
        throw new Error(
          `expected a number base for exponential interpolation, got ${JSON.stringify(b)} instead`
        );
      }
      base = b;
      break;
    default:
      throw new Error(
        `invalid interpolation type: ${JSON.stringify(interpolationType)}`
      );
  }
  const interpolation = new LiteralExpression(NumberType, base);
  let input;
  try {
    input = parse(encoded[2], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse argument 1 in interpolate expression: ${err.message}`
    );
  }
  const args = new Array(encoded.length - 3);
  for (let i = 0; i < args.length; i += 2) {
    try {
      const stop = parse(encoded[i + 3], NumberType, context);
      args[i] = stop;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 2} for interpolate expression: ${err.message}`
      );
    }
    try {
      const output = parse(encoded[i + 4], returnType, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 3} for interpolate expression: ${err.message}`
      );
    }
  }
  return [interpolation, input, ...args];
}
function withCaseArgs(encoded, returnType, context) {
  const fallback2 = parse(encoded[encoded.length - 1], returnType, context);
  const args = new Array(encoded.length - 1);
  for (let i = 0; i < args.length - 1; i += 2) {
    try {
      const condition = parse(encoded[i + 1], BooleanType, context);
      args[i] = condition;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i} of case expression: ${err.message}`
      );
    }
    try {
      const output = parse(encoded[i + 2], fallback2.type, context);
      args[i + 1] = output;
    } catch (err) {
      throw new Error(
        `failed to parse argument ${i + 1} of case expression: ${err.message}`
      );
    }
  }
  args[args.length - 1] = fallback2;
  return args;
}
function withInArgs(encoded, returnType, context) {
  let haystack = encoded[2];
  if (!Array.isArray(haystack)) {
    throw new Error(
      `the second argument for the "in" operator must be an array`
    );
  }
  let needleType;
  if (typeof haystack[0] === "string") {
    if (haystack[0] !== "literal") {
      throw new Error(
        `for the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions`
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `failed to parse "in" expression: the literal operator must be followed by an array`
      );
    }
    haystack = haystack[1];
    needleType = StringType;
  } else {
    needleType = NumberType;
  }
  const args = new Array(haystack.length);
  for (let i = 0; i < args.length; i++) {
    try {
      const arg = parse(haystack[i], needleType, context);
      args[i] = arg;
    } catch (err) {
      throw new Error(
        `failed to parse haystack item ${i} for "in" expression: ${err.message}`
      );
    }
  }
  const needle = parse(encoded[1], needleType, context);
  return [needle, ...args];
}
function withPaletteArgs(encoded, returnType, context) {
  let index;
  try {
    index = parse(encoded[1], NumberType, context);
  } catch (err) {
    throw new Error(
      `failed to parse first argument in palette expression: ${err.message}`
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error("the second argument of palette must be an array");
  }
  const parsedColors = new Array(colors.length);
  for (let i = 0; i < parsedColors.length; i++) {
    let color;
    try {
      color = parse(colors[i], ColorType, context);
    } catch (err) {
      throw new Error(
        `failed to parse color at index ${i} in palette expression: ${err.message}`
      );
    }
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `the palette color at index ${i} must be a literal value`
      );
    }
    parsedColors[i] = color;
  }
  return [index, ...parsedColors];
}
function createCallExpressionParser(...validators) {
  return function(encoded, returnType, context) {
    const operator = encoded[0];
    let args;
    for (let i = 0; i < validators.length; i++) {
      const parsed = validators[i](encoded, returnType, context);
      if (i == validators.length - 1) {
        if (!parsed) {
          throw new Error(
            "expected last argument validator to return the parsed args"
          );
        }
        args = parsed;
      }
    }
    return new CallExpression(returnType, operator, ...args);
  };
}
function parseCallExpression(encoded, returnType, context) {
  const operator = encoded[0];
  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`unknown operator: ${operator}`);
  }
  return parser(encoded, returnType, context);
}
function computeGeometryType(geometry) {
  if (!geometry) {
    return "";
  }
  const type = geometry.getType();
  switch (type) {
    case "Point":
    case "LineString":
    case "Polygon":
      return type;
    case "MultiPoint":
    case "MultiLineString":
    case "MultiPolygon":
      return (
        /** @type {'Point'|'LineString'|'Polygon'} */
        type.substring(5)
      );
    case "Circle":
      return "Polygon";
    case "GeometryCollection":
      return computeGeometryType(
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry.getGeometries()[0]
      );
    default:
      return "";
  }
}
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null,
    geometryType: ""
  };
}
function buildExpression(encoded, type, context) {
  const expression = parse(encoded, type, context);
  return compileExpression(expression);
}
function compileExpression(expression, context) {
  if (expression instanceof LiteralExpression) {
    if (expression.type === ColorType && typeof expression.value === "string") {
      const colorValue = fromString(expression.value);
      return function() {
        return colorValue;
      };
    }
    return function() {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case Ops.Number:
    case Ops.String:
    case Ops.Coalesce: {
      return compileAssertionExpression(expression);
    }
    case Ops.Get:
    case Ops.Var:
    case Ops.Has: {
      return compileAccessorExpression(expression);
    }
    case Ops.Id: {
      return (context2) => context2.featureId;
    }
    case Ops.GeometryType: {
      return (context2) => context2.geometryType;
    }
    case Ops.Concat: {
      const args = expression.args.map((e) => compileExpression(e));
      return (context2) => "".concat(...args.map((arg) => arg(context2).toString()));
    }
    case Ops.Resolution: {
      return (context2) => context2.resolution;
    }
    case Ops.Any:
    case Ops.All:
    case Ops.Between:
    case Ops.In:
    case Ops.Not: {
      return compileLogicalExpression(expression);
    }
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression);
    }
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt: {
      return compileNumericExpression(expression);
    }
    case Ops.Case: {
      return compileCaseExpression(expression);
    }
    case Ops.Match: {
      return compileMatchExpression(expression);
    }
    case Ops.Interpolate: {
      return compileInterpolateExpression(expression);
    }
    case Ops.ToString: {
      return compileConvertExpression(expression);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i]);
  }
  switch (type) {
    case Ops.Coalesce: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value !== "undefined" && value !== null) {
            return value;
          }
        }
        throw new Error("Expected one of the values to be non-null");
      };
    }
    case Ops.Number:
    case Ops.String: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}
function compileAccessorExpression(expression, context) {
  const nameExpression = (
    /** @type {LiteralExpression} */
    expression.args[0]
  );
  const name = (
    /** @type {string} */
    nameExpression.value
  );
  switch (expression.operator) {
    case Ops.Get: {
      return (context2) => {
        const args = expression.args;
        let value = context2.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          value = value[key];
        }
        return value;
      };
    }
    case Ops.Var: {
      return (context2) => context2.variables[name];
    }
    case Ops.Has: {
      return (context2) => {
        const args = expression.args;
        if (!(name in context2.properties)) {
          return false;
        }
        let value = context2.properties[name];
        for (let i = 1, ii = args.length; i < ii; ++i) {
          const keyExpression = (
            /** @type {LiteralExpression} */
            args[i]
          );
          const key = (
            /** @type {string|number} */
            keyExpression.value
          );
          if (!value || !Object.hasOwn(value, key)) {
            return false;
          }
          value = value[key];
        }
        return true;
      };
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0]);
  const right = compileExpression(expression.args[1]);
  switch (op) {
    case Ops.Equal: {
      return (context2) => left(context2) === right(context2);
    }
    case Ops.NotEqual: {
      return (context2) => left(context2) !== right(context2);
    }
    case Ops.LessThan: {
      return (context2) => left(context2) < right(context2);
    }
    case Ops.LessThanOrEqualTo: {
      return (context2) => left(context2) <= right(context2);
    }
    case Ops.GreaterThan: {
      return (context2) => left(context2) > right(context2);
    }
    case Ops.GreaterThanOrEqualTo: {
      return (context2) => left(context2) >= right(context2);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i]);
  }
  switch (op) {
    case Ops.Any: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.All: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context2)) {
            return false;
          }
        }
        return true;
      };
    }
    case Ops.Between: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        const max = args[2](context2);
        return value >= min && value <= max;
      };
    }
    case Ops.In: {
      return (context2) => {
        const value = args[0](context2);
        for (let i = 1; i < length; ++i) {
          if (value === args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.Not: {
      return (context2) => !args[0](context2);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i]);
  }
  switch (op) {
    case Ops.Multiply: {
      return (context2) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context2);
        }
        return value;
      };
    }
    case Ops.Divide: {
      return (context2) => args[0](context2) / args[1](context2);
    }
    case Ops.Add: {
      return (context2) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context2);
        }
        return value;
      };
    }
    case Ops.Subtract: {
      return (context2) => args[0](context2) - args[1](context2);
    }
    case Ops.Clamp: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        if (value < min) {
          return min;
        }
        const max = args[2](context2);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case Ops.Mod: {
      return (context2) => args[0](context2) % args[1](context2);
    }
    case Ops.Pow: {
      return (context2) => Math.pow(args[0](context2), args[1](context2));
    }
    case Ops.Abs: {
      return (context2) => Math.abs(args[0](context2));
    }
    case Ops.Floor: {
      return (context2) => Math.floor(args[0](context2));
    }
    case Ops.Ceil: {
      return (context2) => Math.ceil(args[0](context2));
    }
    case Ops.Round: {
      return (context2) => Math.round(args[0](context2));
    }
    case Ops.Sin: {
      return (context2) => Math.sin(args[0](context2));
    }
    case Ops.Cos: {
      return (context2) => Math.cos(args[0](context2));
    }
    case Ops.Atan: {
      if (length === 2) {
        return (context2) => Math.atan2(args[0](context2), args[1](context2));
      }
      return (context2) => Math.atan(args[0](context2));
    }
    case Ops.Sqrt: {
      return (context2) => Math.sqrt(args[0](context2));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}
function compileCaseExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i]);
  }
  return (context2) => {
    for (let i = 0; i < length - 1; i += 2) {
      const condition = args[i](context2);
      if (condition) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i]);
  }
  return (context2) => {
    const value = args[0](context2);
    for (let i = 1; i < length; i += 2) {
      if (value === args[i](context2)) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i]);
  }
  return (context2) => {
    const base = args[0](context2);
    const value = args[1](context2);
    let previousInput;
    let previousOutput;
    for (let i = 2; i < length; i += 2) {
      const input = args[i](context2);
      let output = args[i + 1](context2);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = withAlpha(output);
      }
      if (input >= value) {
        if (i === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}
function compileConvertExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i]);
  }
  switch (op) {
    case Ops.ToString: {
      return (context2) => {
        const value = args[0](context2);
        if (expression.args[0].type === ColorType) {
          return toString(value);
        }
        return value.toString();
      };
    }
    default: {
      throw new Error(`Unsupported convert operator ${op}`);
    }
  }
}
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = rgbaToLcha(rgba1);
  const lcha2 = rgbaToLcha(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
  ];
  return normalize(lchaToRgba(lcha));
}
function always$1(context) {
  return true;
}
function rulesToStyleFunction(rules) {
  const parsingContext = newParsingContext();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = newEvaluationContext();
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    if (parsingContext.geometryType) {
      evaluationContext.geometryType = computeGeometryType(
        feature.getGeometry()
      );
    }
    return evaluator(evaluationContext);
  };
}
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = newParsingContext();
  const length = flatStyles.length;
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = newEvaluationContext();
  const styles = new Array(length);
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i = 0; i < length; ++i) {
      const style = evaluators[i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}
function buildRuleSet(rules, context) {
  const length = rules.length;
  const compiledRules = new Array(length);
  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always$1;
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i] = { filter, styles };
  }
  return function(context2) {
    const styles = [];
    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context2)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context2);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }
    return styles;
  };
}
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, "", context);
  const evaluateStroke = buildStroke(flatStyle, "", context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty$1(flatStyle)) {
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle)
    );
  }
  const style = new Style();
  return function(context2) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context2);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context2);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context2);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context2);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context2));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}
function buildFill(flatStyle, prefix, context) {
  let evaluateColor;
  if (prefix + "fill-pattern-src" in flatStyle) {
    evaluateColor = patternEvaluator(flatStyle, prefix + "fill-", context);
  } else {
    if (flatStyle[prefix + "fill-color"] === "none") {
      return (context2) => null;
    }
    evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + "fill-color",
      context
    );
  }
  if (!evaluateColor) {
    return null;
  }
  const fill = new Fill();
  return function(context2) {
    const color = evaluateColor(context2);
    if (color === NO_COLOR) {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + "stroke-width",
    context
  );
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "stroke-color",
    context
  );
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-cap",
    context
  );
  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-join",
    context
  );
  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + "stroke-line-dash",
    context
  );
  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + "stroke-line-dash-offset",
    context
  );
  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + "stroke-miter-limit",
    context
  );
  const stroke = new Stroke();
  return function(context2) {
    if (evaluateColor) {
      const color = evaluateColor(context2);
      if (color === NO_COLOR) {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context2));
    }
    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context2);
      if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
        throw new Error("Expected butt, round, or square line cap");
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context2);
      if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
        throw new Error("Expected bevel, round, or miter line join");
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context2));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context2));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context2));
    }
    return stroke;
  };
}
function buildText(flatStyle, context) {
  const prefix = "text-";
  const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
  if (!evaluateValue) {
    return null;
  }
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + "max-angle",
    context
  );
  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + "offset-x",
    context
  );
  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + "offset-y",
    context
  );
  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + "overflow",
    context
  );
  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + "placement",
    context
  );
  const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + "justify",
    context
  );
  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + "baseline",
    context
  );
  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + "padding",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const text = new Text({ declutterMode });
  return function(context2) {
    text.setText(evaluateValue(context2));
    if (evaluateFill) {
      text.setFill(evaluateFill(context2));
    }
    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context2));
    }
    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context2));
    }
    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context2));
    }
    if (evaluateFont) {
      text.setFont(evaluateFont(context2));
    }
    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context2));
    }
    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context2));
    }
    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context2));
    }
    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context2));
    }
    if (evaluatePlacement) {
      const placement = evaluatePlacement(context2);
      if (placement !== "point" && placement !== "line") {
        throw new Error("Expected point or line for text-placement");
      }
      text.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context2));
    }
    if (evaluateScale) {
      text.setScale(evaluateScale(context2));
    }
    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context2));
    }
    if (evaluateAlign) {
      const textAlign = evaluateAlign(context2);
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      }
      text.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      const justify = evaluateJustify(context2);
      if (justify !== "left" && justify !== "right" && justify !== "center") {
        throw new Error("Expected left, right, or center for text-justify");
      }
      text.setJustify(justify);
    }
    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context2);
      if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      }
      text.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context2));
    }
    return text;
  };
}
function buildImage(flatStyle, context) {
  if ("icon-src" in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ("shape-points" in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ("circle-radius" in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}
function buildIcon(flatStyle, context) {
  const prefix = "icon-";
  const srcName = prefix + "src";
  const src = requireString(flatStyle[srcName], srcName);
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + "anchor",
    context
  );
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + "opacity",
    context
  );
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-x-units"
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-y-units"
  );
  const color = optionalColorLike(flatStyle, prefix + "color");
  const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
  const offset = optionalNumberArray(flatStyle, prefix + "offset");
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
  const width = optionalNumber(flatStyle, prefix + "width");
  const height = optionalNumber(flatStyle, prefix + "height");
  const size = optionalSize(flatStyle, prefix + "size");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const icon = new Icon({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode
  });
  return function(context2) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context2));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context2));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context2));
    }
    return icon;
  };
}
function buildShape(flatStyle, context) {
  const prefix = "shape-";
  const pointsName = prefix + "points";
  const radiusName = prefix + "radius";
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const radius = requireNumber(flatStyle[radiusName], radiusName);
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const radius2 = optionalNumber(flatStyle, prefix + "radius2");
  const angle = optionalNumber(flatStyle, prefix + "angle");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const shape = new RegularShape({
    points,
    radius,
    radius2,
    angle,
    declutterMode
  });
  return function(context2) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context2));
    }
    return shape;
  };
}
function buildCircle(flatStyle, context) {
  const prefix = "circle-";
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const circle = new CircleStyle({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode
  });
  return function(context2) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context2));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context2));
    }
    return circle;
  };
}
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return void 0;
  }
  const evaluator = buildExpression(flatStyle[name], NumberType, context);
  return function(context2) {
    return requireNumber(evaluator(context2), name);
  };
}
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], StringType, context);
  return function(context2) {
    return requireString(evaluator(context2), name);
  };
}
function patternEvaluator(flatStyle, prefix, context) {
  const srcEvaluator = stringEvaluator(
    flatStyle,
    prefix + "pattern-src",
    context
  );
  const offsetEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-offset",
    context
  );
  const patternSizeEvaluator = sizeEvaluator(
    flatStyle,
    prefix + "pattern-size",
    context
  );
  const colorEvaluator = colorLikeEvaluator(
    flatStyle,
    prefix + "color",
    context
  );
  return function(context2) {
    return {
      src: srcEvaluator(context2),
      offset: offsetEvaluator && offsetEvaluator(context2),
      size: patternSizeEvaluator && patternSizeEvaluator(context2),
      color: colorEvaluator && colorEvaluator(context2)
    };
  };
}
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], BooleanType, context);
  return function(context2) {
    const value = evaluator(context2);
    if (typeof value !== "boolean") {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], ColorType, context);
  return function(context2) {
    return requireColorLike(evaluator(context2), name);
  };
}
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireNumberArray(evaluator(context2), name);
  };
}
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    const array = requireNumberArray(evaluator(context2), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}
function sizeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireSize(evaluator(context2), name);
  };
}
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    NumberArrayType | NumberType,
    context
  );
  return function(context2) {
    return requireSizeLike(evaluator(context2), name);
  };
}
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === void 0) {
    return void 0;
  }
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded === "number") {
    return toSize(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "pixels" && encoded !== "fraction") {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireNumberArray(encoded, property);
}
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireColorLike(encoded, property);
}
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== "number") {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}
function requireString(value, property) {
  if (typeof value !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}
function requireNumber(value, property) {
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function requireColorLike(value, property) {
  if (typeof value === "string") {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}
function requireSize(value, property) {
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}
function requireSizeLike(value, property) {
  if (typeof value === "number") {
    return value;
  }
  return requireSize(value, property);
}
const Property$1 = {
  RENDER_ORDER: "renderOrder"
};
class BaseVectorLayer extends Layer {
  /**
   * @param {Options<FeatureType, VectorSourceType>} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.style;
    delete baseOptions.renderBuffer;
    delete baseOptions.updateWhileAnimating;
    delete baseOptions.updateWhileInteracting;
    super(baseOptions);
    this.declutter_ = options.declutter ? String(options.declutter) : void 0;
    this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
    this.style_ = null;
    this.styleFunction_ = void 0;
    this.setStyle(options.style);
    this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
    this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
  }
  /**
   * @return {string} Declutter group.
   * @override
   */
  getDeclutter() {
    return this.declutter_;
  }
  /**
   * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
   * that resolves with an array of features. The array will either contain the topmost feature
   * when a hit was detected, or it will be empty.
   *
   * The hit detection algorithm used for this method is optimized for performance, but is less
   * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
   * Text is not considered, and icons are only represented by their bounding box instead of the exact
   * image.
   *
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
   * @api
   * @override
   */
  getFeatures(pixel) {
    return super.getFeatures(pixel);
  }
  /**
   * @return {number|undefined} Render buffer.
   */
  getRenderBuffer() {
    return this.renderBuffer_;
  }
  /**
   * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
   *     order.
   */
  getRenderOrder() {
    return (
      /** @type {import("../render.js").OrderFunction|null|undefined} */
      this.get(Property$1.RENDER_ORDER)
    );
  }
  /**
   * Get the style for features.  This returns whatever was passed to the `style`
   * option at construction or to the `setStyle` method.
   * @return {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null|undefined} Layer style.
   * @api
   */
  getStyle() {
    return this.style_;
  }
  /**
   * Get the style function.
   * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
   * @api
   */
  getStyleFunction() {
    return this.styleFunction_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     animating.
   */
  getUpdateWhileAnimating() {
    return this.updateWhileAnimating_;
  }
  /**
   * @return {boolean} Whether the rendered layer should be updated while
   *     interacting.
   */
  getUpdateWhileInteracting() {
    return this.updateWhileInteracting_;
  }
  /**
   * Render declutter items for this layer
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {import("../layer/Layer.js").State} layerState Layer state.
   * @override
   */
  renderDeclutter(frameState, layerState) {
    const declutterGroup = this.getDeclutter();
    if (declutterGroup in frameState.declutter === false) {
      frameState.declutter[declutterGroup] = new RBush(9);
    }
    this.getRenderer().renderDeclutter(frameState, layerState);
  }
  /**
   * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
   *     Render order.
   */
  setRenderOrder(renderOrder) {
    this.set(Property$1.RENDER_ORDER, renderOrder);
  }
  /**
   * Set the style for features.  This can be a single style object, an array
   * of styles, or a function that takes a feature and resolution and returns
   * an array of styles. If set to `null`, the layer has no style (a `null` style),
   * so only features that have their own styles will be rendered in the layer. Call
   * `setStyle()` without arguments to reset to the default style. See
   * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
   *
   * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
   * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
   * ```js
   * vectorLayer.setStyle({
   *   "fill-color": "yellow",
   *   "stroke-color": "black",
   *   "stroke-width": 4
   * })
   * ```
   *
   * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
   * @api
   */
  setStyle(style) {
    this.style_ = style === void 0 ? createDefaultStyle : style;
    const styleLike = toStyleLike(style);
    this.styleFunction_ = style === null ? void 0 : toFunction(styleLike);
    this.changed();
  }
}
function toStyleLike(style) {
  if (style === void 0) {
    return createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === "function") {
    return style;
  }
  if (style instanceof Style) {
    return style;
  }
  if (!Array.isArray(style)) {
    return flatStylesToStyleFunction([style]);
  }
  if (style.length === 0) {
    return [];
  }
  const length = style.length;
  const first = style[0];
  if (first instanceof Style) {
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof Style)) {
        throw new Error("Expected a list of style instances");
      }
      styles[i] = candidate;
    }
    return styles;
  }
  if ("style" in first) {
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!("style" in candidate)) {
        throw new Error("Expected a list of rules with a style property");
      }
      rules[i] = candidate;
    }
    return rulesToStyleFunction(rules);
  }
  const flatStyles = (
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    style
  );
  return flatStylesToStyleFunction(flatStyles);
}
class MapRenderer extends Disposable {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();
    this.map_ = map;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX$1(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = (
      /** @type {Array<HitMatch<T>>} */
      []
    );
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates2[0] + offsets[i][0];
            tmpCoord[1] = coordinates2[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback2,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => m.distanceSq += i * order);
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      TRUE,
      this,
      layerFilter,
      thisArg
    );
    return hasFeature !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
}
function expireIconCache(map, frameState) {
  shared.expire();
}
class RenderEvent extends BaseEvent {
  /**
   * @param {import("./EventType.js").default} type Type.
   * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
   *     CSS pixels to rendered pixels.
   * @param {import("../Map.js").FrameState} [frameState] Frame state.
   * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
   */
  constructor(type, inversePixelTransform, frameState, context) {
    super(type);
    this.inversePixelTransform = inversePixelTransform;
    this.frameState = frameState;
    this.context = context;
  }
}
class CompositeMapRenderer extends MapRenderer {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(
      checkedFonts,
      ObjectEventType.PROPERTYCHANGE,
      map.redrawText,
      map
    );
    this.element_ = document.createElement("div");
    const style = this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new RenderEvent(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.remove();
    super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(
      (a, b) => a.zIndex - b.zIndex
    );
    const declutter = layerStatesArray.some(
      (layerState) => layerState.layer instanceof BaseVectorLayer && layerState.layer.getDeclutter()
    );
    if (declutter) {
      frameState.declutter = {};
    }
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const renderedLayerStates = [];
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      renderedLayerStates.push(layerState);
    }
    this.declutter(frameState, renderedLayerStates);
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.
   */
  declutter(frameState, layerStates) {
    if (!frameState.declutter) {
      return;
    }
    for (let i = layerStates.length - 1; i >= 0; --i) {
      const layerState = layerStates[i];
      const layer = layerState.layer;
      if (layer.getDeclutter()) {
        layer.renderDeclutter(frameState, layerState);
      }
    }
    layerStates.forEach(
      (layerState) => layerState.layer.renderDeferred(frameState)
    );
  }
}
class GroupEvent extends BaseEvent {
  /**
   * @param {GroupEventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
}
const Property = {
  LAYERS: "layers"
};
class LayerGroup extends BaseLayer {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = (
      /** @type {Options} */
      Object.assign({}, options)
    );
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection(layers.slice(), { unique: true });
      } else {
        assert(
          typeof /** @type {?} */
          layers.getArray === "function",
          "Expected `layers` to be an array or a `Collection`"
        );
      }
    } else {
      layers = new Collection(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this),
      listen(
        layers,
        CollectionEventType.REMOVE,
        this.handleLayersRemove_,
        this
      )
    );
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(
        layer,
        ObjectEventType.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      listen(layer, EventType.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof LayerGroup) {
      listenerKeys.push(
        listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
        listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
      );
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Property.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
      }
    }
    this.set(Property.LAYERS, layers);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   * @override
   */
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   * @override
   */
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   * @override
   */
  getSourceState() {
    return "ready";
  }
}
class MapEvent extends BaseEvent {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
}
class MapBrowserEvent extends MapEvent {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   * @override
   */
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   * @override
   */
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
}
const MapBrowserEventType = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: EventType.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: EventType.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
const PointerEventType = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};
class MapBrowserEventHandler extends Target {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(
      element,
      PointerEventType.POINTERDOWN,
      this.handlePointerDown_,
      this
    );
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(
      element,
      PointerEventType.POINTERMOVE,
      this.relayMoveEvent_,
      this
    );
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(
      EventType.TOUCHMOVE,
      this.boundHandleTouchMove_,
      PASSIVE_EVENT_LISTENERS ? { passive: false } : false
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent(
      MapBrowserEventType.CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent(
        MapBrowserEventType.DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent(
          MapBrowserEventType.SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType.POINTERUP || event.type == MapBrowserEventType.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType.POINTERDOWN || event.type == MapBrowserEventType.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent(
      MapBrowserEventType.POINTERUP,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent(
      MapBrowserEventType.POINTERDOWN,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, "target", {
      writable: false,
      value: pointerEvent.target
    });
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(
          doc,
          MapBrowserEventType.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        listen(doc, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        listen(
          this.element_,
          MapBrowserEventType.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          listen(
            this.element_.getRootNode(),
            MapBrowserEventType.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent(
        MapBrowserEventType.POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new MapBrowserEvent(
        MapBrowserEventType.POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      EventType.TOUCHMOVE,
      this.boundHandleTouchMove_
    );
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
}
const MapEventType = {
  /**
   * Triggered after a map frame is rendered.
   * @event module:ol/MapEvent~MapEvent#postrender
   * @api
   */
  POSTRENDER: "postrender",
  /**
   * Triggered when the map starts moving.
   * @event module:ol/MapEvent~MapEvent#movestart
   * @api
   */
  MOVESTART: "movestart",
  /**
   * Triggered after the map is moved.
   * @event module:ol/MapEvent~MapEvent#moveend
   * @api
   */
  MOVEEND: "moveend",
  /**
   * Triggered when loading of additional map data (tiles, images, features) starts.
   * @event module:ol/MapEvent~MapEvent#loadstart
   * @api
   */
  LOADSTART: "loadstart",
  /**
   * Triggered when loading of additional map data has completed.
   * @event module:ol/MapEvent~MapEvent#loadend
   * @api
   */
  LOADEND: "loadend"
};
const MapProperty = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};
const DROP = Infinity;
class PriorityQueue {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = /** @type {T} */
      elements.pop();
      priorities[0] = /** @type {number} */
      priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    assert(
      !(this.keyFunction_(element) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return index - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;
    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];
    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
}
const TileState = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};
class TileQueue extends PriorityQueue {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (
          /** @type {import("./Tile.js").default} */
          element[0].getKey()
        );
      }
    );
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   * @override
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile = element[0];
      tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("./Tile.js").default} */
      event.target
    );
    const state = tile.getState();
    if (state === TileState.LOADED || state === TileState.ERROR || state === TileState.EMPTY) {
      if (state !== TileState.ERROR) {
        tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      const tile = this.dequeue()[0];
      const tileKey = tile.getKey();
      const state = tile.getState();
      if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile.load();
      }
    }
  }
}
function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}
class Control extends BaseObject {
  /**
   * @param {Options} options Control options.
   */
  constructor(options) {
    super();
    const element = options.element;
    if (element && !options.target && !element.style.pointerEvents) {
      element.style.pointerEvents = "auto";
    }
    this.element = element ? element : null;
    this.target_ = null;
    this.map_ = null;
    this.listenerKeys = [];
    if (options.render) {
      this.render = options.render;
    }
    if (options.target) {
      this.setTarget(options.target);
    }
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    var _a;
    (_a = this.element) == null ? void 0 : _a.remove();
    super.disposeInternal();
  }
  /**
   * Get the map associated with this control.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    var _a;
    if (this.map_) {
      (_a = this.element) == null ? void 0 : _a.remove();
    }
    for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
      unlistenByKey(this.listenerKeys[i]);
    }
    this.listenerKeys.length = 0;
    this.map_ = map;
    if (map) {
      const target = this.target_ ?? map.getOverlayContainerStopEvent();
      target.appendChild(this.element);
      if (this.render !== VOID) {
        this.listenerKeys.push(
          listen(map, MapEventType.POSTRENDER, this.render, this)
        );
      }
      map.render();
    }
  }
  /**
   * Renders the control.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @api
   */
  render(mapEvent) {
  }
  /**
   * This function is used to set a target element for the control. It has no
   * effect if it is called after the control has been added to the map (i.e.
   * after `setMap` is called on the control). If no `target` is set in the
   * options passed to the control constructor and if `setTarget` is not called
   * then the control is added to the map's overlay container.
   * @param {HTMLElement|string} target Target.
   * @api
   */
  setTarget(target) {
    this.target_ = typeof target === "string" ? document.getElementById(target) : target;
  }
}
class Attribution extends Control {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    this.attributions_ = options.attributions;
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "›";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(
      EventType.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const layers = this.getMap().getAllLayers();
    const visibleAttributions = new Set(
      layers.flatMap((layer) => layer.getAttributions(frameState))
    );
    if (this.attributions_ !== void 0) {
      Array.isArray(this.attributions_) ? this.attributions_.forEach((item) => visibleAttributions.add(item)) : visibleAttributions.add(this.attributions_);
    }
    if (!this.overrideCollapsible_) {
      const collapsible = !layers.some(
        (layer) => {
          var _a;
          return ((_a = layer.getSource()) == null ? void 0 : _a.getAttributionsCollapsible()) === false;
        }
      );
      this.setCollapsible(collapsible);
    }
    return Array.from(visibleAttributions);
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  async updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = await Promise.all(
      this.collectSourceAttributions_(frameState).map(
        (attribution) => toPromise(() => attribution)
      )
    );
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals$2(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
}
class Rotate extends Control {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "⇧";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(
      EventType.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
}
class Zoom extends Control {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "–";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
    );
    inElement.addEventListener(
      EventType.CLICK,
      this.handleClick_.bind(this, delta),
      false
    );
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );
    outElement.addEventListener(
      EventType.CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
}
function defaults$1(options) {
  options = options ? options : {};
  const controls = new Collection();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution(options.attributionOptions));
  }
  return controls;
}
const InteractionProperty = {
  ACTIVE: "active"
};
class Interaction extends BaseObject {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(InteractionProperty.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(InteractionProperty.ACTIVE, active);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
}
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== void 0 ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration !== void 0 ? duration : 250,
    easing: easeOut
  });
}
class DoubleClickZoom extends Interaction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
      const browserEvent = (
        /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
}
class PointerInteraction extends Interaction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
}
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return { clientX: clientX / length, clientY: clientY / length };
}
function all(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
const altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return rootNode instanceof ShadowRoot ? rootNode.host.contains(activeElement) : targetElement.contains(activeElement);
};
const focusWithTabindex = function(event) {
  const targetElement = event.map.getTargetElement();
  const rootNode = targetElement.getRootNode();
  const tabIndexCandidate = rootNode instanceof ShadowRoot ? rootNode.host : targetElement;
  return tabIndexCandidate.hasAttribute("tabindex") ? focus(event) : true;
};
const always = TRUE;
const mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
const noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
const platformModifierKey = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};
const shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
const targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  const tagName = (
    /** @type {Element} */
    originalEvent.target.tagName
  );
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};
const mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.pointerType == "mouse";
};
const primaryAction = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
class DragPan extends PointerInteraction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid$1 = map.getEventPixel(centroid(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid$1[0], centroid$1[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid$1[0],
          centroid$1[1] - this.lastCentroid[1]
        ];
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        scale$2(delta, view.getResolution());
        rotate$1(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid$1;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance * Math.cos(angle),
          centerpx[1] - distance * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
}
class DragRotate extends PointerInteraction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
}
class RenderBox extends Disposable {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    if (!this.map_) {
      return;
    }
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
}
const DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
class DragBoxEvent extends BaseEvent {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
}
class DragBox extends PointerInteraction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ?? {};
    this.box_ = new RenderBox(options.className || "ol-dragbox");
    this.minArea_ = options.minArea ?? 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ?? mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ?? this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return;
    }
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (!this.startPixel_) {
      return false;
    }
    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    this.box_.setMap(null);
    this.startPixel_ = null;
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   * @override
   */
  setActive(active) {
    if (!active) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null)
        );
        this.startPixel_ = null;
      }
    }
    super.setActive(active);
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   * @override
   */
  setMap(map) {
    const oldMap = this.getMap();
    if (oldMap) {
      this.box_.setMap(null);
      if (this.startPixel_) {
        this.dispatchEvent(
          new DragBoxEvent(DragBoxEventType.BOXCANCEL, this.startPixel_, null)
        );
        this.startPixel_ = null;
      }
    }
    super.setMap(map);
  }
}
class DragZoom extends DragBox {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   * @override
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = (
      /** @type {!import("../View.js").default} */
      map.getView()
    );
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
}
const Key = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};
class KeyboardPan extends Interaction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType.KEYDOWN) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key == Key.DOWN || key == Key.LEFT || key == Key.RIGHT || key == Key.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (key == Key.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == Key.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == Key.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate$1(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}
class KeyboardZoom extends Interaction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType.KEYDOWN || mapBrowserEvent.type == EventType.KEYPRESS) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
        const map = mapBrowserEvent.map;
        const delta = key === "+" ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
}
class Kinetic {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
}
class MouseWheelZoom extends Interaction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always;
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @override
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = (
      /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.pixel;
    }
    let delta;
    if (mapBrowserEvent.type == EventType.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(
        -delta / this.deltaPerZoom_,
        this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null
      );
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );
    return false;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(
      view,
      delta,
      this.lastAnchor_ ? map.getCoordinateFromPixel(this.lastAnchor_) : null,
      this.duration_
    );
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
}
class PinchRotate extends PointerInteraction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}
class PinchZoom extends PointerInteraction {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @override
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance;
    }
    this.lastDistance_ = distance;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @override
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
}
function defaults(options) {
  options = options ? options : {};
  const interactions = new Collection();
  const kinetic = new Kinetic(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new DoubleClickZoom({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new DragPan({
        onFocusOnly: options.onFocusOnly,
        kinetic
      })
    );
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new PinchZoom({
        duration: options.zoomDuration
      })
    );
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan());
    interactions.push(
      new KeyboardZoom({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new MouseWheelZoom({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      })
    );
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new DragZoom({
        duration: options.zoomDuration
      })
    );
  }
  return interactions;
}
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof LayerGroup) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof LayerGroup) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
class Map extends BaseObject {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_ = false;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create();
    this.pixelToCoordinateTransform_ = create();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.targetElement_ = null;
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
    this.controls = optionsInternal.controls || defaults$1();
    this.interactions = optionsInternal.interactions || defaults({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );
    this.addChangeListener(
      MapProperty.LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(MapProperty.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View)) {
      options.view.then(function(viewOptions) {
        map.setView(new View(viewOptions));
      });
    }
    this.controls.addEventListener(
      CollectionEventType.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.controls.addEventListener(
      CollectionEventType.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );
    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      }
    );
    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      }
    );
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  /**
   *
   * Clean up.
   * @override
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function(feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof LayerGroup) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in event ? (
        /** @type {TouchEvent} */
        event.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        event
      )
    );
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(MapProperty.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default|null} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(MapProperty.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(MapProperty.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(MapProperty.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(
      this.frameState_,
      tile,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = (
      /** @type {PointerEvent} */
      mapBrowserEvent.originalEvent
    );
    const eventType = originalEvent.type;
    if (eventType === PointerEventType.POINTERDOWN || eventType === EventType.WHEEL || eventType === EventType.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = (
        /** @type {Node} */
        originalEvent.target
      );
      const currentDoc = rootNode instanceof ShadowRoot ? rootNode.host === target ? rootNode.host.ownerDocument : rootNode : rootNode === doc ? doc.documentElement : rootNode;
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !currentDoc.contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_) {
        if (this.hasListener(RenderEventType.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            RenderEventType.RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new MapEvent(MapEventType.LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new MapEvent(MapEventType.LOADSTART, this, frameState)
        );
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        EventType.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        EventType.WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      this.viewport_.remove();
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(void 0);
    }
    const target = this.getTarget();
    const targetElement = typeof target === "string" ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new CompositeMapRenderer(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler(
        this,
        this.moveTolerance_
      );
      for (const key in MapBrowserEventType) {
        this.mapBrowserEventHandler_.addEventListener(
          MapBrowserEventType[key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        EventType.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        EventType.WHEEL,
        this.boundHandleBrowserEvent_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
      let keyboardEventTarget;
      if (!this.keyboardEventTarget_) {
        const targetRoot = targetElement.getRootNode();
        const targetCandidate = targetRoot instanceof ShadowRoot ? targetRoot.host : targetElement;
        keyboardEventTarget = targetCandidate;
      } else {
        keyboardEventTarget = this.keyboardEventTarget_;
      }
      this.targetChangeHandlerKeys_ = [
        listen(
          keyboardEventTarget,
          EventType.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        listen(
          keyboardEventTarget,
          EventType.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_(this.getSize());
      this.viewPropertyListenerKey_ = listen(
        view,
        ObjectEventType.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = listen(
        view,
        EventType.CHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      view.resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutter: null,
        extent: getForViewAndSize(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals$1(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(
            new MapEvent(MapEventType.MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint.ANIMATING] && !frameState.viewHints[ViewHint.INTERACTING] && !equals$1(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(
          new MapEvent(MapEventType.MOVEEND, this, frameState)
        );
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));
    this.renderComplete_ = (this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE)) && !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady();
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty.LAYERGROUP, layerGroup);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(MapProperty.SIZE, size);
  }
  /**
   * Set the target element to render this map into.
   * For accessibility (focus and keyboard events for map navigation), the `target` element must have a
   *  properly configured `tabindex` attribute. If the `target` element is inside a Shadow DOM, the
   *  `tabindex` atribute must be set on the custom element's host element.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(MapProperty.TARGET, target);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof View) {
      this.set(MapProperty.VIEW, view);
      return;
    }
    this.set(MapProperty.VIEW, new View());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View(viewOptions));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [Math.max(0, width), Math.max(0, height)];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          warn(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }
    const oldSize = this.getSize();
    if (size && (!oldSize || !equals$2(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_(size);
    }
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(size) {
    const view = this.getView();
    if (view) {
      view.setViewportSize(size);
    }
  }
}
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values = {};
  const layerGroup = options.layers && typeof /** @type {?} */
  options.layers.getLayers === "function" ? (
    /** @type {LayerGroup} */
    options.layers
  ) : new LayerGroup({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      options.layers
    )
  });
  values[MapProperty.LAYERGROUP] = layerGroup;
  values[MapProperty.TARGET] = options.target;
  values[MapProperty.VIEW] = options.view instanceof View ? options.view : new View();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection(options.controls.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.controls.getArray === "function",
        "Expected `controls` to be an array or an `ol/Collection.js`"
      );
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection(options.interactions.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.interactions.getArray === "function",
        "Expected `interactions` to be an array or an `ol/Collection.js`"
      );
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection(options.overlays.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.overlays.getArray === "function",
        "Expected `overlays` to be an array or an `ol/Collection.js`"
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
let instances = /* @__PURE__ */ new WeakMap();
function ui(tag, create2) {
  if (customElements.get(tag) === void 0) {
    customElements.define(tag, class extends HTMLElement {
      connectedCallback() {
        var _a;
        const connect = (_a = instances.get(this)) == null ? void 0 : _a.connect;
        if (typeof connect === "function") {
          connect();
        }
      }
      disconnectedCallback() {
        var _a;
        const disconnect = (_a = instances.get(this)) == null ? void 0 : _a.disconnect;
        if (typeof disconnect === "function") {
          disconnect();
        }
      }
    });
  }
  return Object.freeze(function make_element(params) {
    const element = document.createElement(tag);
    instances.set(element, create2(element, params));
    return element;
  });
}
const make_ui = Object.freeze(ui);
function dom(tag, properties = {}, children = []) {
  if (typeof properties === "string" || Array.isArray(properties)) {
    children = properties;
    properties = {};
  }
  if (!Array.isArray(children)) {
    children = [children];
  }
  const element = typeof tag === "string" ? document.createElement(tag) : tag;
  element.append(...children);
  Object.keys(properties).forEach(function(name) {
    element[name] = properties[name];
  });
  Object.assign(element.style, properties.style);
  return element;
}
const dom$1 = Object.freeze(dom);
const map_ui = make_ui("map-ui", function(element) {
  const ol_map = new Map({
    controls: defaults$1({
      attribution: false,
      attributionOptions: false,
      rotate: false,
      rotateOptions: false,
      zoom: false,
      zoomOptions: false
    }),
    view: new View({
      center: [0, 0],
      zoom: 2
    })
  });
  const shadow = element.attachShadow({ mode: "closed" });
  const map_root = dom$1("div", {
    style: {
      height: "500px",
      position: "relative",
      width: "100%"
    }
  });
  function get_map() {
    return ol_map;
  }
  function dispose_map() {
    ol_map.dispose();
  }
  element.get_map = get_map;
  shadow.append(map_root);
  return {
    connect() {
      ol_map.setTarget(map_root);
    },
    disconnect() {
      dispose_map();
    }
  };
});
const map_ui$1 = Object.freeze(map_ui);
const coordinates_ui = make_ui("map-coordinates", function(element, {
  coords,
  on_coords_update
}) {
  const shadow = element.attachShadow({ mode: "closed" });
  const coords_element = dom$1("input", {
    onchange: function on_change(event) {
      event.preventDefault();
      const value = event.target.value;
      const [x, y] = value.split(",");
      on_coords_update(x == null ? void 0 : x.trim(), y == null ? void 0 : y.trim());
    },
    type: "text"
  });
  function update_coordinates(x, y) {
    coords.x = x;
    coords.y = y;
    coords_element.value = `${coords.x}, ${coords.y}`;
  }
  function clear_coordinates() {
    coords_element.value = "";
  }
  shadow.append(coords_element);
  element.update_coordinates = update_coordinates;
  element.clear_coordinates = clear_coordinates;
  return {
    connect() {
      update_coordinates(coords.x, coords.y);
    },
    disconnect() {
      clear_coordinates();
    }
  };
});
const make_coordinates = Object.freeze(coordinates_ui);
const make_bottom_pane = make_ui("map-bottom-pane", function(element, {
  map
}) {
  const shadow = element.attachShadow({ mode: "closed" });
  const view = map.getView();
  const [x, y] = view.getCenter();
  const coords_ui = make_coordinates({
    coords: { x, y },
    on_coords_update(x2, y2) {
      view.setCenter([x2, y2]);
    }
  });
  function update_coords(event) {
    const [x2, y2] = event.coordinate;
    coords_ui.update_coordinates(x2, y2);
  }
  map.on("pointermove", update_coords);
  shadow.append(coords_ui);
  return {
    disconnect() {
      map.un("pointermove", update_coords);
    }
  };
});
const bottom_pane_ui = Object.freeze(make_bottom_pane);
function render_css$1({ visibility }) {
  const display = visibility ? "block;" : "none;";
  return `
        :host {
            display: ${display}
        }`;
}
const dialog_ui = make_ui("dialog-ui", function(element, {
  on_close,
  visibility
}) {
  let close_button;
  let dialog_container;
  const style = dom$1("style");
  const shadow = element.attachShadow({ mode: "closed" });
  function close() {
    style.textContent = render_css$1({ visibility: false });
    dialog_container.innerHTML = "";
  }
  function open(content) {
    style.textContent = render_css$1({ visibility: true });
    dialog_container.append(content);
  }
  close_button = dom$1("button", {
    onclick: function(event) {
      event.preventDefault();
      on_close();
    }
  }, ["Close"]);
  dialog_container = dom$1("div");
  shadow.append(style, close_button, dialog_container);
  element.open = open;
  element.close = close;
  return {
    connect() {
      style.textContent = render_css$1({ visibility });
    },
    disconnect() {
      close();
    }
  };
});
const dialog_ui$1 = Object.freeze(dialog_ui);
const TileProperty = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class BaseTileLayer extends Layer {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    const cacheSize2 = options.cacheSize;
    delete options.cacheSize;
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.cacheSize_ = cacheSize2;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
    );
  }
  /**
   * @return {number|undefined} The suggested cache size
   * @protected
   */
  getCacheSize() {
    return this.cacheSize_;
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(TileProperty.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(TileProperty.PRELOAD, preload);
  }
  /**
   * Deprecated.  Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Deprecated.  Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   * @override
   */
  getData(pixel) {
    return super.getData(pixel);
  }
}
const maxStaleKeys = 5;
class LayerRenderer extends Observable {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super();
    this.ready = true;
    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
    this.layer_ = layer;
    this.staleKeys_ = new Array();
    this.maxStaleKeys = maxStaleKeys;
  }
  /**
   * @return {Array<string>} Get the list of stale keys.
   */
  getStaleKeys() {
    return this.staleKeys_;
  }
  /**
   * @param {string} key The new stale key.
   */
  prependStaleKey(key) {
    this.staleKeys_.unshift(key);
    if (this.staleKeys_.length > this.maxStaleKeys) {
      this.staleKeys_.length = this.maxStaleKeys;
    }
  }
  /**
   * Asynchronous layer level hit detection.
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
   * an array of features.
   */
  getFeatures(pixel) {
    return abstract();
  }
  /**
   * @param {import("../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   */
  getData(pixel) {
    return null;
  }
  /**
   * Determine whether render should be called.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return abstract();
  }
  /**
   * Render the layer.
   * @abstract
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement|null} target Target that may be used to render content to.
   * @return {HTMLElement|null} The rendered element.
   */
  renderFrame(frameState, target) {
    return abstract();
  }
  /**
   * @abstract
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
   * @return {T|undefined} Callback result.
   * @template T
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
    return void 0;
  }
  /**
   * @return {LayerType} Layer.
   */
  getLayer() {
    return this.layer_;
  }
  /**
   * Perform action necessary to get the layer rendered after new fonts have loaded
   * @abstract
   */
  handleFontsChanged() {
  }
  /**
   * Handle changes in image state.
   * @param {import("../events/Event.js").default} event Image change event.
   * @private
   */
  handleImageChange_(event) {
    const image = (
      /** @type {import("../Image.js").default} */
      event.target
    );
    if (image.getState() === ImageState.LOADED || image.getState() === ImageState.ERROR) {
      this.renderIfReadyAndVisible();
    }
  }
  /**
   * Load the image if not already loaded, and register the image change
   * listener if needed.
   * @param {import("../Image.js").default} image Image.
   * @return {boolean} `true` if the image is already loaded, `false` otherwise.
   * @protected
   */
  loadImage(image) {
    let imageState = image.getState();
    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
    }
    if (imageState == ImageState.IDLE) {
      image.load();
      imageState = image.getState();
    }
    return imageState == ImageState.LOADED;
  }
  /**
   * @protected
   */
  renderIfReadyAndVisible() {
    const layer = this.getLayer();
    if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
      layer.changed();
    }
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  renderDeferred(frameState) {
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.layer_;
    super.disposeInternal();
  }
}
class ZIndexContext {
  constructor() {
    /**
     * @private
     * @param {...*} args Args.
     * @return {ZIndexContext} This.
     */
    __publicField(this, "pushMethodArgs_", (...args) => {
      this.instructions_[this.zIndex + this.offset_].push(args);
      return this;
    });
    this.instructions_ = [];
    this.zIndex = 0;
    this.offset_ = 0;
    this.context_ = /** @type {ZIndexContextProxy} */
    new Proxy(getSharedCanvasContext2D(), {
      get: (target, property) => {
        if (typeof /** @type {*} */
        getSharedCanvasContext2D()[property] !== "function") {
          return void 0;
        }
        if (!this.instructions_[this.zIndex + this.offset_]) {
          this.instructions_[this.zIndex + this.offset_] = [];
        }
        this.instructions_[this.zIndex + this.offset_].push(property);
        return this.pushMethodArgs_;
      },
      set: (target, property, value) => {
        if (!this.instructions_[this.zIndex + this.offset_]) {
          this.instructions_[this.zIndex + this.offset_] = [];
        }
        this.instructions_[this.zIndex + this.offset_].push(property, value);
        return true;
      }
    });
  }
  /**
   * Push a function that renders to the context directly.
   * @param {function(CanvasRenderingContext2D): void} render Function.
   */
  pushFunction(render2) {
    this.instructions_[this.zIndex + this.offset_].push(render2);
  }
  /**
   * Get a proxy for CanvasRenderingContext2D which does not support getting state
   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a
   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,
   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.
   * @return {ZIndexContextProxy} Context.
   */
  getContext() {
    return this.context_;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   */
  draw(context) {
    this.instructions_.forEach((instructionsAtIndex) => {
      for (let i = 0, ii = instructionsAtIndex.length; i < ii; ++i) {
        const property = instructionsAtIndex[i];
        if (typeof property === "function") {
          property(context);
          continue;
        }
        const instructionAtIndex = instructionsAtIndex[++i];
        if (typeof /** @type {*} */
        context[property] === "function") {
          context[property](...instructionAtIndex);
        } else {
          if (typeof instructionAtIndex === "function") {
            context[property] = instructionAtIndex(context);
            continue;
          }
          context[property] = instructionAtIndex;
        }
      }
    });
  }
  clear() {
    this.instructions_.length = 0;
    this.zIndex = 0;
    this.offset_ = 0;
  }
  /**
   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to
   * avoid conflicting context.clip() or context.save()/restore() calls.
   */
  offset() {
    this.offset_ = this.instructions_.length;
    this.zIndex = 0;
  }
}
let pixelContext = null;
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
class CanvasLayerRenderer extends LayerRenderer {
  /**
   * @param {LayerType} layer Layer.
   */
  constructor(layer) {
    super(layer);
    this.container = null;
    this.renderedResolution;
    this.tempTransform = create();
    this.pixelTransform = create();
    this.inversePixelTransform = create();
    this.context = null;
    this.deferredContext_ = null;
    this.containerReused = false;
    this.frameState = null;
  }
  /**
   * @param {import('../../DataTile.js').ImageLike} image Image.
   * @param {number} col The column index.
   * @param {number} row The row index.
   * @return {Uint8ClampedArray|null} The image data.
   */
  getImageData(image, col, row) {
    if (!pixelContext) {
      createPixelContext();
    }
    pixelContext.clearRect(0, 0, 1, 1);
    let data;
    try {
      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
      data = pixelContext.getImageData(0, 0, 1, 1).data;
    } catch (err) {
      pixelContext = null;
      return null;
    }
    return data;
  }
  /**
   * @param {import('../../Map.js').FrameState} frameState Frame state.
   * @return {string} Background color.
   */
  getBackground(frameState) {
    const layer = this.getLayer();
    let background = layer.getBackground();
    if (typeof background === "function") {
      background = background(frameState.viewState.resolution);
    }
    return background || void 0;
  }
  /**
   * Get a rendering container from an existing target, if compatible.
   * @param {HTMLElement} target Potential render target.
   * @param {string} transform CSS Transform.
   * @param {string} [backgroundColor] Background color.
   */
  useContainer(target, transform2, backgroundColor) {
    const layerClassName = this.getLayer().getClassName();
    let container, context;
    if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals$2(
      asArray(target.style.backgroundColor),
      asArray(backgroundColor)
    ))) {
      const canvas = target.firstElementChild;
      if (canvas instanceof HTMLCanvasElement) {
        context = canvas.getContext("2d");
      }
    }
    if (context && context.canvas.style.transform === transform2) {
      this.container = target;
      this.context = context;
      this.containerReused = true;
    } else if (this.containerReused) {
      this.container = null;
      this.context = null;
      this.containerReused = false;
    } else if (this.container) {
      this.container.style.backgroundColor = null;
    }
    if (!this.container) {
      container = document.createElement("div");
      container.className = layerClassName;
      let style = container.style;
      style.position = "absolute";
      style.width = "100%";
      style.height = "100%";
      context = createCanvasContext2D();
      const canvas = context.canvas;
      container.appendChild(canvas);
      style = canvas.style;
      style.position = "absolute";
      style.left = "0";
      style.transformOrigin = "top left";
      this.container = container;
      this.context = context;
    }
    if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
      this.container.style.backgroundColor = backgroundColor;
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent Clip extent.
   * @protected
   */
  clipUnrotated(context, frameState, extent) {
    const topLeft = getTopLeft(extent);
    const topRight = getTopRight(extent);
    const bottomRight = getBottomRight(extent);
    const bottomLeft = getBottomLeft(extent);
    apply(frameState.coordinateToPixelTransform, topLeft);
    apply(frameState.coordinateToPixelTransform, topRight);
    apply(frameState.coordinateToPixelTransform, bottomRight);
    apply(frameState.coordinateToPixelTransform, bottomLeft);
    const inverted = this.inversePixelTransform;
    apply(inverted, topLeft);
    apply(inverted, topRight);
    apply(inverted, bottomRight);
    apply(inverted, bottomLeft);
    context.save();
    context.beginPath();
    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
    context.clip();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @protected
   */
  prepareContainer(frameState, target) {
    const extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const rotation = frameState.viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const width = Math.round(getWidth(extent) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent) / resolution * pixelRatio);
    compose(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    const canvasTransform = toString$1(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    if (!this.containerReused) {
      const canvas = this.context.canvas;
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
      } else {
        this.context.clearRect(0, 0, width, height);
      }
      if (canvasTransform !== canvas.style.transform) {
        canvas.style.transform = canvasTransform;
      }
    }
  }
  /**
   * @param {import("../../render/EventType.js").default} type Event type.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @private
   */
  dispatchRenderEvent_(type, context, frameState) {
    const layer = this.getLayer();
    if (layer.hasListener(type)) {
      const event = new RenderEvent(
        type,
        this.inversePixelTransform,
        frameState,
        context
      );
      layer.dispatchEvent(event);
    }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  preRender(context, frameState) {
    this.frameState = frameState;
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  postRender(context, frameState) {
    if (frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   */
  renderDeferredInternal(frameState) {
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.
   */
  getRenderContext(frameState) {
    if (frameState.declutter && !this.deferredContext_) {
      this.deferredContext_ = new ZIndexContext();
    }
    return frameState.declutter ? this.deferredContext_.getContext() : this.context;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @override
   */
  renderDeferred(frameState) {
    if (!frameState.declutter) {
      return;
    }
    this.dispatchRenderEvent_(
      RenderEventType.PRERENDER,
      this.context,
      frameState
    );
    if (frameState.declutter && this.deferredContext_) {
      this.deferredContext_.draw(this.context);
      this.deferredContext_.clear();
    }
    this.renderDeferredInternal(frameState);
    this.dispatchRenderEvent_(
      RenderEventType.POSTRENDER,
      this.context,
      frameState
    );
  }
  /**
   * Creates a transform for rendering to an element that will be rotated after rendering.
   * @param {import("../../coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} width Width of the rendered element (in pixels).
   * @param {number} height Height of the rendered element (in pixels).
   * @param {number} offsetX Offset on the x-axis in view coordinates.
   * @protected
   * @return {!import("../../transform.js").Transform} Transform.
   */
  getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
    const dx1 = width / 2;
    const dy1 = height / 2;
    const sx = pixelRatio / resolution;
    const sy = -sx;
    const dx2 = -center[0] + offsetX;
    const dy2 = -center[1];
    return compose(
      this.tempTransform,
      dx1,
      dy1,
      sx,
      sy,
      -rotation,
      dx2,
      dy2
    );
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    delete this.frameState;
    super.disposeInternal();
  }
}
class Tile extends Target {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(EventType.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === TileState.ERROR) {
      this.setState(TileState.EMPTY);
    }
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== TileState.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    abstract();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }
    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }
    const delta = time - start + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    this.release();
    super.disposeInternal();
  }
}
function asImageLike(data) {
  return data instanceof Image || data instanceof HTMLCanvasElement || data instanceof HTMLVideoElement || data instanceof ImageBitmap ? data : null;
}
function asArrayLike(data) {
  return data instanceof Uint8Array || data instanceof Uint8ClampedArray || data instanceof Float32Array || data instanceof DataView ? data : null;
}
const disposedError = new Error("disposed");
let sharedContext = null;
function toArray(image) {
  if (!sharedContext) {
    sharedContext = createCanvasContext2D(
      image.width,
      image.height,
      void 0,
      { willReadFrequently: true }
    );
  }
  const canvas = sharedContext.canvas;
  const width = image.width;
  if (canvas.width !== width) {
    canvas.width = width;
  }
  const height = image.height;
  if (canvas.height !== height) {
    canvas.height = height;
  }
  sharedContext.clearRect(0, 0, width, height);
  sharedContext.drawImage(image, 0, 0);
  return sharedContext.getImageData(0, 0, width, height).data;
}
const defaultSize = [256, 256];
class DataTile extends Tile {
  /**
   * @param {Options} options Tile options.
   */
  constructor(options) {
    const state = TileState.IDLE;
    super(options.tileCoord, state, {
      transition: options.transition,
      interpolate: options.interpolate
    });
    this.loader_ = options.loader;
    this.data_ = null;
    this.error_ = null;
    this.size_ = options.size || null;
    this.controller_ = options.controller || null;
  }
  /**
   * Get the tile size.
   * @return {import('./size.js').Size} Tile size.
   */
  getSize() {
    if (this.size_) {
      return this.size_;
    }
    const imageData = asImageLike(this.data_);
    if (imageData) {
      return [imageData.width, imageData.height];
    }
    return defaultSize;
  }
  /**
   * Get the data for the tile.
   * @return {Data} Tile data.
   * @api
   */
  getData() {
    return this.data_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @api
   */
  getError() {
    return this.error_;
  }
  /**
   * Load the tile data.
   * @api
   * @override
   */
  load() {
    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {
      return;
    }
    this.state = TileState.LOADING;
    this.changed();
    const self2 = this;
    this.loader_().then(function(data) {
      self2.data_ = data;
      self2.state = TileState.LOADED;
      self2.changed();
    }).catch(function(error) {
      self2.error_ = error;
      self2.state = TileState.ERROR;
      self2.changed();
    });
  }
  /**
   * Clean up.
   * @override
   */
  disposeInternal() {
    if (this.controller_) {
      this.controller_.abort(disposedError);
      this.controller_ = null;
    }
    super.disposeInternal();
  }
}
class ImageTile extends Tile {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = TileState.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = TileState.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    if (image.naturalWidth && image.naturalHeight) {
      this.state = TileState.LOADED;
    } else {
      this.state = TileState.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   * @api
   * @override
   */
  load() {
    if (this.state == TileState.ERROR) {
      this.state = TileState.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState.IDLE) {
      this.state = TileState.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
  /**
   * @override
   */
  disposeInternal() {
    this.unlistenImage_();
    this.image_ = null;
    super.disposeInternal();
  }
}
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
class LRUCache {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache. When the cache entry is a {@link module:ol/Disposable~Disposable},
   * the entry will be disposed.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      const entry = this.pop();
      if (entry instanceof Disposable) {
        entry.dispose();
      }
    }
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */
      entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(key) {
    var _a;
    return (_a = this.entries_[key]) == null ? void 0 : _a.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */
    entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    assert(
      !(key in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
}
const ERROR_THRESHOLD = 0.5;
const MAX_SUBDIVISION = 10;
const MAX_TRIANGLE_WIDTH = 0.25;
class Triangulation {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c) {
      const key = c[0] + "/" + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
        )
      )
    ) : 0);
    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        ) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = (
      /** @type {number} */
      this.sourceWorldWidth_
    );
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a, b, c, d]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects$1(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = createEmpty();
    this.triangles_.forEach(function(triangle, i, arr) {
      const src = triangle.source;
      extendCoordinate(extent, src[0]);
      extendCoordinate(extent, src[1]);
      extendCoordinate(extent, src[2]);
    });
    return extent;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
}
let brokenDiagonalRendering_;
const canvasPool = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset) {
  return Math.abs(data[offset * 4] - 210) > 2 || Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle, clipExtent) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend$1(sourceDataExtent, src.extent);
  });
  let stitchContext;
  const stitchScale = pixelRatio / sourceResolution;
  const inverseScale = (interpolate ? 1 : 1 + Math.pow(2, -24)) / stitchScale;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    stitchContext = createCanvasContext2D(
      Math.round(getWidth(sourceDataExtent) * stitchScale),
      Math.round(getHeight(sourceDataExtent) * stitchScale),
      canvasPool
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    if (sourceExtent && clipExtent) {
      const xPos = (sourceExtent[0] - sourceDataExtent[0]) * stitchScale;
      const yPos = -(sourceExtent[3] - sourceDataExtent[3]) * stitchScale;
      const width2 = getWidth(sourceExtent) * stitchScale;
      const height2 = getHeight(sourceExtent) * stitchScale;
      stitchContext.rect(xPos, yPos, width2, height2);
      stitchContext.clip();
    }
    sources.forEach(function(src, i, arr) {
      if (src.image.width > 0 && src.image.height > 0) {
        if (src.clipExtent) {
          stitchContext.save();
          const xPos2 = (src.clipExtent[0] - sourceDataExtent[0]) * stitchScale;
          const yPos2 = -(src.clipExtent[3] - sourceDataExtent[3]) * stitchScale;
          const width2 = getWidth(src.clipExtent) * stitchScale;
          const height2 = getHeight(src.clipExtent) * stitchScale;
          stitchContext.rect(
            interpolate ? xPos2 : Math.round(xPos2),
            interpolate ? yPos2 : Math.round(yPos2),
            interpolate ? width2 : Math.round(xPos2 + width2) - Math.round(xPos2),
            interpolate ? height2 : Math.round(yPos2 + height2) - Math.round(yPos2)
          );
          stitchContext.clip();
        }
        const xPos = (src.extent[0] - sourceDataExtent[0]) * stitchScale;
        const yPos = -(src.extent[3] - sourceDataExtent[3]) * stitchScale;
        const srcWidth = getWidth(src.extent) * stitchScale;
        const srcHeight = getHeight(src.extent) * stitchScale;
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          interpolate ? xPos : Math.round(xPos),
          interpolate ? yPos : Math.round(yPos),
          interpolate ? srcWidth : Math.round(xPos + srcWidth) - Math.round(xPos),
          interpolate ? srcHeight : Math.round(yPos + srcHeight) - Math.round(yPos)
        );
        if (src.clipExtent) {
          stitchContext.restore();
        }
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(inverseScale, -inverseScale);
    } else {
      const source2 = sources[0];
      const extent = source2.extent;
      image = source2.image;
      context.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}
class ReprojDataTile extends DataTile {
  /**
   * @param {Options} options Tile options.
   */
  constructor(options) {
    super({
      tileCoord: options.tileCoord,
      loader: () => Promise.resolve(new Uint8ClampedArray(4)),
      interpolate: options.interpolate,
      transition: options.transition
    });
    this.pixelRatio_ = options.pixelRatio;
    this.gutter_ = options.gutter;
    this.reprojData_ = null;
    this.reprojError_ = null;
    this.reprojSize_ = void 0;
    this.sourceTileGrid_ = options.sourceTileGrid;
    this.targetTileGrid_ = options.targetTileGrid;
    this.wrappedTileCoord_ = options.wrappedTileCoord || options.tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    const sourceProj = options.sourceProj;
    const sourceProjExtent = sourceProj.getExtent();
    const sourceTileGridExtent = options.sourceTileGrid.getExtent();
    this.clipExtent_ = sourceProj.canWrapX() ? sourceTileGridExtent ? getIntersection(sourceProjExtent, sourceTileGridExtent) : sourceProjExtent : sourceTileGridExtent;
    const targetExtent = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = this.targetTileGrid_.getResolution(
      this.wrappedTileCoord_[0]
    );
    const targetProj = options.targetProj;
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState.EMPTY;
      return;
    }
    const errorThresholdInPixels = options.errorThreshold !== void 0 ? options.errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    this.sourceZ_ = this.sourceTileGrid_.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState.EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = getWidth(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
        );
      }
      const sourceExtents = wrapAndSliceX(
        sourceExtent.slice(),
        sourceProj,
        true
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = this.sourceTileGrid_.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_
        );
        const getTile = options.getTileFunction;
        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile = getTile(this.sourceZ_, srcX, srcY, this.pixelRatio_);
            if (tile) {
              const offset = worldsAway * worldWidth;
              this.sourceTiles_.push({ tile, offset });
            }
          }
        }
        ++worldsAway;
      });
      if (this.sourceTiles_.length === 0) {
        this.state = TileState.EMPTY;
      }
    }
  }
  /**
   * Get the tile size.
   * @return {import('../size.js').Size} Tile size.
   * @override
   */
  getSize() {
    return this.reprojSize_;
  }
  /**
   * Get the data for the tile.
   * @return {import("../DataTile.js").Data} Tile data.
   * @override
   */
  getData() {
    return this.reprojData_;
  }
  /**
   * Get any loading error.
   * @return {Error} Loading error.
   * @override
   */
  getError() {
    return this.reprojError_;
  }
  /**
   * @private
   */
  reproject_() {
    const dataSources = [];
    let imageLike = false;
    this.sourceTiles_.forEach((source) => {
      var _a;
      const tile = source.tile;
      if (!tile || tile.getState() !== TileState.LOADED) {
        return;
      }
      const size2 = tile.getSize();
      const gutter = this.gutter_;
      let tileData;
      const arrayData = asArrayLike(tile.getData());
      if (arrayData) {
        tileData = arrayData;
      } else {
        imageLike = true;
        tileData = toArray(asImageLike(tile.getData()));
      }
      const pixelSize = [size2[0] + 2 * gutter, size2[1] + 2 * gutter];
      const isFloat = tileData instanceof Float32Array;
      const pixelCount = pixelSize[0] * pixelSize[1];
      const DataType = isFloat ? Float32Array : Uint8ClampedArray;
      const tileDataR = new DataType(tileData.buffer);
      const bytesPerElement = DataType.BYTES_PER_ELEMENT;
      const bytesPerPixel2 = bytesPerElement * tileDataR.length / pixelCount;
      const bytesPerRow = tileDataR.byteLength / pixelSize[1];
      const bandCount = Math.floor(
        bytesPerRow / bytesPerElement / pixelSize[0]
      );
      const packedLength = pixelCount * bandCount;
      let packedData = tileDataR;
      if (tileDataR.length !== packedLength) {
        packedData = new DataType(packedLength);
        let dataIndex = 0;
        let rowOffset = 0;
        const colCount = pixelSize[0] * bandCount;
        for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {
          for (let colIndex = 0; colIndex < colCount; ++colIndex) {
            packedData[dataIndex++] = tileDataR[rowOffset + colIndex];
          }
          rowOffset += bytesPerRow / bytesPerElement;
        }
      }
      const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
      extent[0] += source.offset;
      extent[2] += source.offset;
      const clipExtent = (_a = this.clipExtent_) == null ? void 0 : _a.slice();
      if (clipExtent) {
        clipExtent[0] += source.offset;
        clipExtent[2] += source.offset;
      }
      dataSources.push({
        extent,
        clipExtent,
        data: new Uint8ClampedArray(packedData.buffer),
        dataType: DataType,
        bytesPerPixel: bytesPerPixel2,
        pixelSize
      });
    });
    this.sourceTiles_.length = 0;
    if (dataSources.length === 0) {
      this.state = TileState.ERROR;
      this.changed();
      return;
    }
    const z = this.wrappedTileCoord_[0];
    const size = this.targetTileGrid_.getTileSize(z);
    const targetWidth = typeof size === "number" ? size : size[0];
    const targetHeight = typeof size === "number" ? size : size[1];
    const targetResolution = this.targetTileGrid_.getResolution(z);
    const sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
    const targetExtent = this.targetTileGrid_.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    let dataR, dataU;
    const bytesPerPixel = dataSources[0].bytesPerPixel;
    const reprojs = Math.ceil(bytesPerPixel / 3);
    for (let reproj = reprojs - 1; reproj >= 0; --reproj) {
      const sources = [];
      for (let i = 0, len = dataSources.length; i < len; ++i) {
        const dataSource = dataSources[i];
        const buffer = dataSource.data;
        const pixelSize = dataSource.pixelSize;
        const width = pixelSize[0];
        const height = pixelSize[1];
        const context2 = createCanvasContext2D(width, height, canvasPool);
        const imageData2 = context2.createImageData(width, height);
        const data2 = imageData2.data;
        let offset2 = reproj * 3;
        for (let j = 0, len2 = data2.length; j < len2; j += 4) {
          data2[j] = buffer[offset2];
          data2[j + 1] = buffer[offset2 + 1];
          data2[j + 2] = buffer[offset2 + 2];
          data2[j + 3] = 255;
          offset2 += bytesPerPixel;
        }
        context2.putImageData(imageData2, 0, 0);
        sources.push({
          extent: dataSource.extent,
          clipExtent: dataSource.clipExtent,
          image: context2.canvas
        });
      }
      const canvas = render(
        targetWidth,
        targetHeight,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        false,
        false,
        false
      );
      for (let i = 0, len = sources.length; i < len; ++i) {
        const canvas2 = sources[i].image;
        const context2 = canvas2.getContext("2d");
        releaseCanvas(context2);
        canvasPool.push(context2.canvas);
      }
      const context = canvas.getContext("2d");
      const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
      releaseCanvas(context);
      canvasPool.push(canvas);
      if (!dataR) {
        dataU = new Uint8ClampedArray(
          bytesPerPixel * imageData.width * imageData.height
        );
        dataR = new dataSources[0].dataType(dataU.buffer);
      }
      const data = imageData.data;
      let offset = reproj * 3;
      for (let i = 0, len = data.length; i < len; i += 4) {
        if (data[i + 3] === 255) {
          dataU[offset] = data[i];
          dataU[offset + 1] = data[i + 1];
          dataU[offset + 2] = data[i + 2];
        } else {
          dataU[offset] = 0;
          dataU[offset + 1] = 0;
          dataU[offset + 2] = 0;
        }
        offset += bytesPerPixel;
      }
    }
    if (imageLike) {
      const context = createCanvasContext2D(targetWidth, targetHeight);
      const imageData = new ImageData(dataR, targetWidth);
      context.putImageData(imageData, 0, 0);
      this.reprojData_ = context.canvas;
    } else {
      this.reprojData_ = dataR;
    }
    this.reprojSize_ = [
      Math.round(targetWidth * this.pixelRatio_),
      Math.round(targetHeight * this.pixelRatio_)
    ];
    this.state = TileState.LOADED;
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state !== TileState.IDLE && this.state !== TileState.ERROR) {
      return;
    }
    this.state = TileState.LOADING;
    this.changed();
    let leftToLoad = 0;
    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(({ tile }) => {
      const state = tile.getState();
      if (state !== TileState.IDLE && state !== TileState.LOADING) {
        return;
      }
      leftToLoad++;
      const sourceListenKey = listen(tile, EventType.CHANGE, () => {
        const state2 = tile.getState();
        if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
          unlistenByKey(sourceListenKey);
          leftToLoad--;
          if (leftToLoad === 0) {
            this.unlistenSources_();
            this.reproject_();
          }
        }
      });
      this.sourcesListenerKeys_.push(sourceListenKey);
    });
    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    } else {
      this.sourceTiles_.forEach(function({ tile }) {
        const state = tile.getState();
        if (state == TileState.IDLE) {
          tile.load();
        }
      });
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
}
class ReprojTile extends Tile {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
    super(tileCoord, TileState.IDLE, options);
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    this.clipExtent_ = sourceProj.canWrapX() ? sourceProj.getExtent() : void 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState.EMPTY;
    } else {
      let worldWidth = 0;
      let worldsAway = 0;
      if (sourceProj.canWrapX()) {
        worldWidth = getWidth(sourceProjExtent);
        worldsAway = Math.floor(
          (sourceExtent[0] - sourceProjExtent[0]) / worldWidth
        );
      }
      const sourceExtents = wrapAndSliceX(
        sourceExtent.slice(),
        sourceProj,
        true
      );
      sourceExtents.forEach((extent) => {
        const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
          extent,
          this.sourceZ_
        );
        for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
          for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
            const tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
            if (tile) {
              const offset = worldsAway * worldWidth;
              this.sourceTiles_.push({ tile, offset });
            }
          }
        }
        ++worldsAway;
      });
      if (this.sourceTiles_.length === 0) {
        this.state = TileState.EMPTY;
      }
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((source) => {
      var _a;
      const tile = source.tile;
      if (tile && tile.getState() == TileState.LOADED) {
        const extent = this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord);
        extent[0] += source.offset;
        extent[2] += source.offset;
        const clipExtent = (_a = this.clipExtent_) == null ? void 0 : _a.slice();
        if (clipExtent) {
          clipExtent[0] += source.offset;
          clipExtent[2] += source.offset;
        }
        sources.push({
          extent,
          clipExtent,
          image: tile.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState.ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = render(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );
      this.state = TileState.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   * @override
   */
  load() {
    if (this.state == TileState.IDLE) {
      this.state = TileState.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach(({ tile }) => {
        const state = tile.getState();
        if (state == TileState.IDLE || state == TileState.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(tile, EventType.CHANGE, (e) => {
            const state2 = tile.getState();
            if (state2 == TileState.LOADED || state2 == TileState.ERROR || state2 == TileState.EMPTY) {
              unlistenByKey(sourceListenKey);
              leftToLoad--;
              if (leftToLoad === 0) {
                this.unlistenSources_();
                this.reproject_();
              }
            }
          });
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function({ tile }, i, arr) {
          const state = tile.getState();
          if (state == TileState.IDLE) {
            tile.load();
          }
        });
      }
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   * @override
   */
  release() {
    if (this.canvas_) {
      releaseCanvas(this.canvas_.getContext("2d"));
      canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
}
class TileRange {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
}
function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
function createOrUpdate(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function hash(tileCoord) {
  return hashZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function hashZXY(z, x, y) {
  return (x << z) + y;
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}
function getCacheKey(sourceKey, z, x, y) {
  return `${sourceKey},${getKeyZXY(z, x, y)}`;
}
function addTileToLookup(tilesByZ, tile, z) {
  if (!(z in tilesByZ)) {
    tilesByZ[z] = /* @__PURE__ */ new Set([tile]);
    return true;
  }
  const set = tilesByZ[z];
  const existing = set.has(tile);
  if (!existing) {
    set.add(tile);
  }
  return !existing;
}
function removeTileFromLookup(tilesByZ, tile, z) {
  const set = tilesByZ[z];
  if (set) {
    return set.delete(tile);
  }
  return false;
}
function getRenderExtent(frameState, extent) {
  const layerState = frameState.layerStatesArray[frameState.layerIndex];
  if (layerState.extent) {
    extent = getIntersection(
      extent,
      fromUserExtent(layerState.extent, frameState.viewState.projection)
    );
  }
  const source = (
    /** @type {import("../../source/Tile.js").default} */
    layerState.layer.getRenderSource()
  );
  if (!source.getWrapX()) {
    const gridExtent = source.getTileGridForProjection(frameState.viewState.projection).getExtent();
    if (gridExtent) {
      extent = getIntersection(extent, gridExtent);
    }
  }
  return extent;
}
class CanvasTileLayerRenderer extends CanvasLayerRenderer {
  /**
   * @param {LayerType} tileLayer Tile layer.
   * @param {Options} [options] Options.
   */
  constructor(tileLayer, options) {
    super(tileLayer);
    options = options || {};
    this.extentChanged = true;
    this.renderComplete = false;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision;
    this.renderedTiles = [];
    this.renderedSourceKey_;
    this.renderedSourceRevision_;
    this.tempExtent = createEmpty();
    this.tempTileRange_ = new TileRange(0, 0, 0, 0);
    this.tempTileCoord_ = createOrUpdate(0, 0, 0);
    const cacheSize2 = options.cacheSize !== void 0 ? options.cacheSize : 512;
    this.tileCache_ = new LRUCache(cacheSize2);
    this.renderedProjection_ = void 0;
    this.maxStaleKeys = cacheSize2 * 0.5;
  }
  /**
   * @return {LRUCache} Tile cache.
   */
  getTileCache() {
    return this.tileCache_;
  }
  /**
   * Get a tile from the cache or create one if needed.
   *
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getOrCreateTile(z, x, y, frameState) {
    const tileCache = this.tileCache_;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const cacheKey = getCacheKey(tileSource.getKey(), z, x, y);
    let tile;
    if (tileCache.containsKey(cacheKey)) {
      tile = tileCache.get(cacheKey);
    } else {
      tile = tileSource.getTile(
        z,
        x,
        y,
        frameState.pixelRatio,
        frameState.viewState.projection
      );
      if (!tile) {
        return null;
      }
      tileCache.set(cacheKey, tile);
    }
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {import("../../Tile.js").default|null} Tile (or null if outside source extent).
   * @protected
   */
  getTile(z, x, y, frameState) {
    const tile = this.getOrCreateTile(z, x, y, frameState);
    if (!tile) {
      return null;
    }
    return tile;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   * @override
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);
      if (!tile || tile.getState() !== TileState.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = toSize(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);
      let image;
      if (tile instanceof ImageTile || tile instanceof ReprojTile) {
        image = tile.getImage();
      } else if (tile instanceof DataTile) {
        image = asImageLike(tile.getData());
        if (!image) {
          continue;
        }
      } else {
        continue;
      }
      const col = Math.floor(
        tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
      );
      const row = Math.floor(
        tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
      );
      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );
      return this.getImageData(image, col + gutter, row + gutter);
    }
    return null;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   * @override
   */
  prepareFrame(frameState) {
    if (!this.renderedProjection_) {
      this.renderedProjection_ = frameState.viewState.projection;
    } else if (frameState.viewState.projection !== this.renderedProjection_) {
      this.tileCache_.clear();
      this.renderedProjection_ = frameState.viewState.projection;
    }
    const source = this.getLayer().getSource();
    if (!source) {
      return false;
    }
    const sourceRevision = source.getRevision();
    if (!this.renderedRevision_) {
      this.renderedRevision_ = sourceRevision;
    } else if (this.renderedRevision_ !== sourceRevision) {
      this.renderedRevision_ = sourceRevision;
      if (this.renderedSourceKey_ === source.getKey()) {
        this.tileCache_.clear();
      }
    }
    return true;
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../extent.js").Extent} extent The extent to be rendered.
   * @param {number} initialZ The zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @param {number} preload Number of additional levels to load.
   */
  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {
    const viewState = frameState.viewState;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getRenderSource();
    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const map = tileLayer.getMapInternal();
    const minZ = Math.max(
      initialZ - preload,
      tileGrid.getMinZoom(),
      tileGrid.getZForResolution(
        Math.min(
          tileLayer.getMaxResolution(),
          map ? map.getView().getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0)) : tileGrid.getResolution(0)
        ),
        tileSource.zDirection
      )
    );
    for (let z = initialZ; z >= minZ; --z) {
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        extent,
        z,
        this.tempTileRange_
      );
      const tileResolution = tileGrid.getResolution(z);
      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
          const tile = this.getTile(z, x, y, frameState);
          if (!tile) {
            continue;
          }
          const added = addTileToLookup(tilesByZ, tile, z);
          if (!added) {
            continue;
          }
          const tileQueueKey = tile.getKey();
          wantedTiles[tileQueueKey] = true;
          if (tile.getState() === TileState.IDLE) {
            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {
              const tileCoord = createOrUpdate(z, x, y, this.tempTileCoord_);
              frameState.tileQueue.enqueue([
                tile,
                tileSourceKey,
                tileGrid.getTileCoordCenter(tileCoord),
                tileResolution
              ]);
            }
          }
        }
      }
    }
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findStaleTile_(tileCoord, tilesByZ) {
    const tileCache = this.tileCache_;
    const z = tileCoord[0];
    const x = tileCoord[1];
    const y = tileCoord[2];
    const staleKeys = this.getStaleKeys();
    for (let i = 0; i < staleKeys.length; ++i) {
      const cacheKey = getCacheKey(staleKeys[i], z, x, y);
      if (tileCache.containsKey(cacheKey)) {
        const tile = tileCache.get(cacheKey);
        if (tile.getState() === TileState.LOADED) {
          tile.endTransition(getUid(this));
          addTileToLookup(tilesByZ, tile, z);
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Look for tiles covering the provided tile coordinate at an alternate
   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid The tile grid.
   * @param {import("../../tilecoord.js").TileCoord} tileCoord The target tile coordinate.
   * @param {number} altZ The alternate zoom level.
   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.
   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.
   * @private
   */
  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {
    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(
      tileCoord,
      altZ,
      this.tempTileRange_
    );
    if (!tileRange) {
      return false;
    }
    let covered = true;
    const tileCache = this.tileCache_;
    const source = this.getLayer().getRenderSource();
    const sourceKey = source.getKey();
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        const cacheKey = getCacheKey(sourceKey, altZ, x, y);
        let loaded = false;
        if (tileCache.containsKey(cacheKey)) {
          const tile = tileCache.get(cacheKey);
          if (tile.getState() === TileState.LOADED) {
            addTileToLookup(tilesByZ, tile, altZ);
            loaded = true;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  /**
   * Render the layer.
   *
   * The frame rendering logic has three parts:
   *
   *  1. Enqueue tiles
   *  2. Find alt tiles for those that are not yet loaded
   *  3. Render loaded tiles
   *
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   * @override
   */
  renderFrame(frameState, target) {
    this.renderComplete = true;
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    const sourceKey = tileSource.getKey();
    if (!this.renderedSourceKey_) {
      this.renderedSourceKey_ = sourceKey;
    } else if (this.renderedSourceKey_ !== sourceKey) {
      this.prependStaleKey(this.renderedSourceKey_);
      this.renderedSourceKey_ = sourceKey;
    }
    let frameExtent = frameState.extent;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    this.prepareContainer(frameState, target);
    const width = this.context.canvas.width;
    const height = this.context.canvas.height;
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent);
    if (layerExtent) {
      frameExtent = getIntersection(
        frameExtent,
        fromUserExtent(layerState.extent)
      );
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tilesByZ = {};
    this.renderedTiles.length = 0;
    const preload = tileLayer.getPreload();
    if (frameState.nextExtent) {
      const targetZ = tileGrid.getZForResolution(
        viewState.nextResolution,
        tileSource.zDirection
      );
      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);
      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);
    }
    const renderExtent = getRenderExtent(frameState, frameExtent);
    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);
    if (preload > 0) {
      setTimeout(() => {
        this.enqueueTiles(
          frameState,
          renderExtent,
          z - 1,
          tilesByZ,
          preload - 1
        );
      }, 0);
    }
    if (!(z in tilesByZ)) {
      return this.container;
    }
    const uid = getUid(this);
    const time = frameState.time;
    for (const tile of tilesByZ[z]) {
      const tileState = tile.getState();
      if ((tile instanceof ReprojTile || tile instanceof ReprojDataTile) && tileState === TileState.EMPTY) {
        continue;
      }
      const tileCoord = tile.tileCoord;
      if (tileState === TileState.LOADED) {
        const alpha = tile.getAlpha(uid, time);
        if (alpha === 1) {
          tile.endTransition(uid);
          continue;
        }
      }
      this.renderComplete = false;
      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);
      if (hasStaleTile) {
        removeTileFromLookup(tilesByZ, tile, z);
        frameState.animate = true;
        continue;
      }
      const coveredByChildren = this.findAltTiles_(
        tileGrid,
        tileCoord,
        z + 1,
        tilesByZ
      );
      if (coveredByChildren) {
        continue;
      }
      const minZoom = tileGrid.getMinZoom();
      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {
        const coveredByParent = this.findAltTiles_(
          tileGrid,
          tileCoord,
          parentZ,
          tilesByZ
        );
        if (coveredByParent) {
          break;
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    const context = this.getRenderContext(frameState);
    compose(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );
    if (layerState.extent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    const zs = Object.keys(tilesByZ).map(Number);
    zs.sort(ascending);
    let currentClip;
    const clips = [];
    const clipZs = [];
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        getTopLeft(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      for (const tile of tilesByZ[currentZ]) {
        if (tile.getState() !== TileState.LOADED) {
          continue;
        }
        const tileCoord = tile.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x = Math.round(origin[0] - xIndex * dx2);
        const y = Math.round(origin[1] - yIndex * dy2);
        const w = nextX - x;
        const h = nextY - y;
        const transition = zs.length === 1;
        let contextSaved = false;
        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
        for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
          if (!transition && currentZ < clipZs[i2]) {
            const clip = clips[i2];
            if (intersects$1(
              [x, y, x + w, y + h],
              [clip[0], clip[3], clip[4], clip[7]]
            )) {
              if (!contextSaved) {
                context.save();
                contextSaved = true;
              }
              context.beginPath();
              context.moveTo(currentClip[0], currentClip[1]);
              context.lineTo(currentClip[2], currentClip[3]);
              context.lineTo(currentClip[4], currentClip[5]);
              context.lineTo(currentClip[6], currentClip[7]);
              context.moveTo(clip[6], clip[7]);
              context.lineTo(clip[4], clip[5]);
              context.lineTo(clip[2], clip[3]);
              context.lineTo(clip[0], clip[1]);
              context.clip();
            }
          }
        }
        clips.push(currentClip);
        clipZs.push(currentZ);
        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);
        if (contextSaved) {
          context.restore();
        }
        this.renderedTiles.unshift(tile);
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals$1(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.postRender(this.context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    const postRenderFunction = (map, frameState2) => {
      const tileSourceKey = getUid(tileSource);
      const wantedTiles = frameState2.wantedTiles[tileSourceKey];
      const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;
      this.updateCacheSize(tilesCount);
      this.tileCache_.expireCache();
    };
    frameState.postRenderFunctions.push(postRenderFunction);
    return this.container;
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   */
  updateCacheSize(tileCount) {
    this.tileCache_.highWaterMark = Math.max(
      this.tileCache_.highWaterMark,
      tileCount * 2
    );
  }
  /**
   * @param {import("../../Tile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   * @protected
   */
  drawTile(tile, frameState, x, y, w, h, gutter, transition) {
    let image;
    if (tile instanceof DataTile) {
      image = asImageLike(tile.getData());
      if (!image) {
        throw new Error("Rendering array data is not yet supported");
      }
    } else {
      image = this.getTileImage(
        /** @type {import("../../ImageTile.js").default} */
        tile
      );
    }
    if (!image) {
      return;
    }
    const context = this.getRenderContext(frameState);
    const uid = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== context.globalAlpha;
    if (alphaChanged) {
      context.save();
      context.globalAlpha = alpha;
    }
    context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );
    if (alphaChanged) {
      context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile.endTransition(uid);
    }
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile) {
    return tile.getImage();
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile.getKey()] = true;
  }
}
class TileLayer extends BaseTileLayer {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }
  /**
   * @override
   */
  createRenderer() {
    return new CanvasTileLayerRenderer(this, {
      cacheSize: this.getCacheSize()
    });
  }
}
const TileEventType = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};
class Source extends BaseObject {
  /**
   * @param {Options} options Source options.
   */
  constructor(options) {
    super();
    this.projection = get$1(options.projection);
    this.attributions_ = adaptAttributions(options.attributions);
    this.attributionsCollapsible_ = options.attributionsCollapsible ?? true;
    this.loading = false;
    this.state_ = options.state !== void 0 ? options.state : "ready";
    this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
    this.interpolate_ = !!options.interpolate;
    this.viewResolver = null;
    this.viewRejector = null;
    const self2 = this;
    this.viewPromise_ = new Promise(function(resolve, reject) {
      self2.viewResolver = resolve;
      self2.viewRejector = reject;
    });
  }
  /**
   * Get the attribution function for the source.
   * @return {?Attribution} Attribution function.
   * @api
   */
  getAttributions() {
    return this.attributions_;
  }
  /**
   * @return {boolean} Attributions are collapsible.
   * @api
   */
  getAttributionsCollapsible() {
    return this.attributionsCollapsible_;
  }
  /**
   * Get the projection of the source.
   * @return {import("../proj/Projection.js").default|null} Projection.
   * @api
   */
  getProjection() {
    return this.projection;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    return null;
  }
  /**
   * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
   */
  getView() {
    return this.viewPromise_;
  }
  /**
   * Get the state of the source, see {@link import("./Source.js").State} for possible states.
   * @return {import("./Source.js").State} State.
   * @api
   */
  getState() {
    return this.state_;
  }
  /**
   * @return {boolean|undefined} Wrap X.
   */
  getWrapX() {
    return this.wrapX_;
  }
  /**
   * @return {boolean} Use linear interpolation when resampling.
   */
  getInterpolate() {
    return this.interpolate_;
  }
  /**
   * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
   * @api
   */
  refresh() {
    this.changed();
  }
  /**
   * Set the attributions of the source.
   * @param {AttributionLike|undefined} attributions Attributions.
   *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
   *     or `undefined`.
   * @api
   */
  setAttributions(attributions) {
    this.attributions_ = adaptAttributions(attributions);
    this.changed();
  }
  /**
   * Set the state of the source.
   * @param {import("./Source.js").State} state State.
   */
  setState(state) {
    this.state_ = state;
    this.changed();
  }
}
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  if (!Array.isArray(attributionLike)) {
    attributionLike = [attributionLike];
  }
  return (frameState) => attributionLike;
}
const tmpTileCoord = [0, 0, 0];
const DECIMALS = 5;
class TileGrid {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(
      isSorted(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, b) => b - a
      ),
      "`resolutions` must be sorted in descending order"
    );
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      );
    }
    const extent = options.extent;
    if (extent !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }
    assert(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    );
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      );
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    );
    this.extent_ = extent !== void 0 ? extent : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map((size, z) => {
        const tileRange = new TileRange(
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (x !== void 0 && y !== void 0) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = createOrUpdate$1(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate$1(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z === tileCoordZ) {
      return createOrUpdate$1(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return createOrUpdate$1(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate$1(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return createOrUpdate$1(minX, maxX, minY, maxY, tempTileRange);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate$2(minX, minY, maxX, maxY, tempExtent);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z = this.getZForResolution(resolution);
    const scale2 = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = scale2 * (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale2 * (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    return this.fullTileRanges_[z];
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = linearFindNearest(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return clamp(z, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
}
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options) {
  const xyzOptions = options || {};
  const extent = xyzOptions.extent || get$1("EPSG:3857").getExtent();
  const gridOptions = {
    extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    )
  };
  return new TileGrid(gridOptions);
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get$1(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT$1.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate$2(-half, -half, half, half);
  }
  return extent;
}
class TileSource extends Source {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tmpSize = [0, 0];
    this.key_ = options.key || getUid(this);
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   * @override
   */
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {TileType|null} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale(tileSize, tilePixelRatio, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  /**
   * Remove all cached reprojected tiles from the source. The next render cycle will create new tiles.
   * @api
   */
  clear() {
  }
  /**
   * @override
   */
  refresh() {
    this.clear();
    super.refresh();
  }
}
class TileSourceEvent extends BaseEvent {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile) {
    super(type);
    this.tile = tile;
  }
}
const zRegEx = /\{z\}/g;
const xRegEx = /\{x\}/g;
const yRegEx = /\{y\}/g;
const dashYRegEx = /\{-y\}/g;
function renderXYZTemplate(template, z, x, y, maxY) {
  return template.replace(zRegEx, z.toString()).replace(xRegEx, x.toString()).replace(yRegEx, y.toString()).replace(dashYRegEx, function() {
    if (maxY === void 0) {
      throw new Error(
        "If the URL template has a {-y} placeholder, the grid extent must be known"
      );
    }
    return (maxY - y).toString();
  });
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}
function createFromTemplate(template, tileGrid) {
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      let maxY;
      const z = tileCoord[0];
      if (tileGrid) {
        const range = tileGrid.getFullTileRange(z);
        if (range) {
          maxY = range.getHeight() - 1;
        }
      }
      return renderXYZTemplate(template, z, tileCoord[1], tileCoord[2], maxY);
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h = hash(tileCoord);
      const index = modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}
class UrlTile extends TileSource {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile = (
      /** @type {import("../Tile.js").default} */
      event.target
    );
    const uid = getUid(tile);
    const tileState = tile.getState();
    let type;
    if (tileState == TileState.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState.ERROR ? TileEventType.TILELOADERROR : tileState == TileState.LOADED ? TileEventType.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile));
    }
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  /**
   * Deprecated.  Use an ImageTile source instead.
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
}
class TileImage extends UrlTile {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile;
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   * @override
   */
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   * @override
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   * @override
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile = new this.tileClass(
      tileCoord,
      tileUrl !== void 0 ? TileState.IDLE : TileState.EMPTY,
      tileUrl !== void 0 ? tileUrl : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile.key = key;
    tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   * @override
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const tileCoord = [z, x, y];
    const key = this.getKey();
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tile = new ReprojTile(
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    tile.key = key;
    return tile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    const key = this.getKey();
    return this.createTile_(z, x, y, pixelRatio, projection, key);
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    this.changed();
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = get$1(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
}
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
class XYZ extends TileImage {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};
    const projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
    const tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
      extent: extentFromProjection(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   * @override
   */
  getGutter() {
    return this.gutter_;
  }
}
const details_xyz_ui = make_ui("details-xyz-ui", function(element, {
  add_disabled = false,
  delete_disabled = false,
  max_zoom_level = 0,
  min_zoom_level = 0,
  name = "",
  on_add_source,
  on_delete_source,
  on_name_change,
  on_save_source,
  on_url_change,
  save_disabled = false,
  url = ""
}) {
  let name_input;
  let url_input;
  let min_zoom_input;
  let max_zoom_input;
  let detail_component;
  let add_button;
  let save_button;
  let delete_button;
  const shadow = element.attachShadow({ mode: "closed" });
  function get_details() {
    return Object.freeze({
      max_zoom_level: max_zoom_input.disabled ? void 0 : max_zoom_input == null ? void 0 : max_zoom_input.value,
      min_zoom_level: min_zoom_input.disabled ? void 0 : min_zoom_input == null ? void 0 : min_zoom_input.value,
      name: name_input == null ? void 0 : name_input.value,
      url: url_input == null ? void 0 : url_input.value
    });
  }
  function update_details(detail = {}) {
    name_input.value = detail.name ?? name;
    url_input.value = detail.url ?? url;
    min_zoom_input.value = detail.min_zoom_level ?? min_zoom_level;
    max_zoom_input.value = detail.max_zoom_level ?? max_zoom_level;
  }
  function clear_details() {
    name_input.value = "";
    url_input.value = "";
    min_zoom_input.value = 0;
    max_zoom_input.value = 0;
  }
  function disable_element(element2) {
    return function(value) {
      element2.disabled = value;
    };
  }
  name_input = dom$1("input", {
    oninput: function(event) {
      event.preventDefault();
      on_name_change(get_details());
    },
    type: "text",
    value: name
  });
  url_input = dom$1("input", {
    oninput: function(event) {
      event.preventDefault();
      on_url_change(get_details());
    },
    type: "text",
    value: url
  });
  min_zoom_input = dom$1("input", {
    type: "number",
    value: min_zoom_level
  });
  max_zoom_input = dom$1("input", {
    type: "number",
    value: max_zoom_level
  });
  add_button = dom$1("button", {
    disabled: add_disabled,
    onclick: function on_add() {
      on_add_source(get_details());
    }
  }, ["Add"]);
  save_button = dom$1("button", {
    disabled: save_disabled,
    onclick: function on_save() {
      on_save_source(get_details());
    }
  }, ["Save"]);
  delete_button = dom$1("button", {
    disabled: delete_disabled,
    onclick: function on_delete() {
      on_delete_source(get_details());
    }
  }, ["Delete"]);
  detail_component = dom$1("ul", [
    dom$1("li", [
      dom$1("label", ["Name"]),
      name_input
    ]),
    dom$1("li", [
      dom$1("label", ["URL"]),
      url_input
    ]),
    dom$1("li", [
      dom$1("input", {
        checked: true,
        id: "min_zoom",
        onchange: function(event) {
          min_zoom_input.disabled = event.target.checked === false;
        },
        type: "checkbox"
      }),
      dom$1("label", { htmlFor: "min_zoom" }, ["Min. Zoom Level"]),
      min_zoom_input
    ]),
    dom$1("li", [
      dom$1("input", {
        checked: true,
        id: "max_zoom",
        onchange: function(event) {
          max_zoom_input.disabled = event.target.checked === false;
        },
        type: "checkbox"
      }),
      dom$1("label", { htmlFor: "max_zoom" }, ["Max. Zoom Level"]),
      max_zoom_input
    ]),
    dom$1("li", [
      add_button,
      save_button,
      delete_button
    ])
  ]);
  shadow.append(detail_component);
  element.update_details = update_details;
  element.clear_details = clear_details;
  element.get_details = get_details;
  element.disable_save = disable_element(save_button);
  element.disable_add = disable_element(add_button);
  element.disable_delete = disable_element(delete_button);
});
const details_xyz_ui$1 = Object.freeze(details_xyz_ui);
const xyz_ui = make_ui("xyz-ui", function(element, {
  on_add_source,
  sources_list = [
    // make empty option first
    {
      max_zoom_level: 0,
      min_zoom_level: 0,
      name: "Custom",
      url: ""
    },
    {
      max_zoom_level: 19,
      min_zoom_level: 0,
      name: "OpenStreetMap",
      url: "https://tile.openstreetmap.org/{z}/{x}/{y}.png"
    },
    {
      max_zoom_level: 15,
      min_zoom_level: 0,
      name: "MapZen",
      url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png"
    }
  ]
}) {
  let source_select;
  let source_details;
  const shadow = element.attachShadow({ mode: "closed" });
  function on_input_change({ name, url }) {
    source_details.disable_add(false);
    source_details.disable_save(false);
    source_details.disable_delete(false);
    if (!url || !name) {
      source_details.disable_add(true);
      source_details.disable_save(true);
      source_details.disable_delete(true);
      return;
    }
    if (sources_list.some(function(source) {
      return source.name === name;
    }) === true) {
      source_details.disable_save(true);
      return;
    } else {
      source_details.disable_delete(true);
      return;
    }
  }
  function get_sources_list() {
    return sources_list;
  }
  source_select = dom$1("select", {
    onchange: function(event) {
      const source = sources_list.find(function(source2) {
        return source2.name === event.target.value;
      });
      if (source.name === "Custom") {
        source_details.clear_details();
        source_details.disable_delete(true);
        source_details.disable_add(true);
        source_details.disable_save(true);
        return;
      }
      source_details.update_details(source);
      source_details.disable_add(false);
      source_details.disable_delete(false);
      source_details.disable_save(true);
    }
  }, sources_list.map(function(source) {
    return dom$1("option", {
      value: source.name
    }, [source.name]);
  }));
  source_details = details_xyz_ui$1({
    delete_disabled: true,
    on_add_source,
    on_delete_source: function on_delete_source(source) {
      sources_list = sources_list.filter(function({ name }) {
        return name !== source.name;
      });
      const option = Array.from(
        source_select.options
      ).find(function(option2) {
        return source.name === option2.value;
      });
      option.remove();
      source_details.clear_details();
      source_details.disable_delete(true);
      source_details.disable_add(true);
      source_details.disable_save(true);
    },
    on_name_change: on_input_change,
    on_save_source: function on_save_source(source) {
      source_select.append(dom$1("option", {
        selected: true,
        value: source.name
      }, [source.name]));
      sources_list.push(source);
    },
    on_url_change: on_input_change
  });
  shadow.append(source_select, source_details);
  element.get_sources_list = get_sources_list;
});
const xyz_ui$1 = Object.freeze(xyz_ui);
function geopackage({
  db
}) {
  function get_feature_tables() {
    return db.exec(
      `
            SELECT
                c.table_name AS name,
                g.geometry_type_name AS geom_type,
                c.srs_id AS srs
            FROM
                gpkg_contents c
            INNER JOIN
                gpkg_geometry_columns g
            ON
                c.table_name = g.table_name
            WHERE
                c.data_type = "features";
            `
    );
  }
  function get_feature(table_name, column_names = []) {
    let columns = column_names.length > 0 ? column_names.join(", ") : " * ";
    return db.exec(
      `
                SELECT
                    ${columns}
                FROM
                    ${table_name};
            `
    );
  }
  return Object.freeze({
    get_feature,
    get_feature_tables
  });
}
const geopackage$1 = Object.freeze(geopackage);
const geopkg_conn_ui = make_ui("geopkg-conn-ui", function(element, {
  db,
  db_connections = [],
  on_connect,
  on_remove
}) {
  let select_box;
  let connect_button;
  let file_input;
  let new_connection_button;
  let remove_button;
  const shadow = element.attachShadow({ mode: "closed" });
  select_box = dom$1("select", db_connections.map(function({ name }) {
    return dom$1("option", {
      value: name
    }, [name]);
  }));
  connect_button = dom$1("button", {
    disabled: db_connections.length < 1,
    onclick: function on_connect_click() {
      const connection = db_connections.find(function(connection2) {
        return select_box.value === connection2.name;
      });
      on_connect(connection);
    }
  }, ["Connect"]);
  file_input = dom$1("input", {
    onchange: function on_new_click(event) {
      const reader = new FileReader();
      const [file] = event.target.files;
      if (file === void 0) {
        return;
      }
      let option = Array.from(select_box.options).find(function(option2) {
        return option2.value === file.name;
      });
      reader.onload = function reader_onload(e) {
        const buffer = e.target.result;
        const uint_8_array = new Uint8Array(buffer);
        db_connections.push({
          geopackage: geopackage$1({ db: db.sql(uint_8_array) }),
          name: file.name
        });
      };
      reader.onerror = function() {
        option == null ? void 0 : option.remove();
      };
      reader.readAsArrayBuffer(file);
      if (option) {
        option.selected = true;
        return;
      }
      option = dom$1("option", {
        selected: true,
        value: file.name
      }, [file.name]);
      select_box.append(option);
      remove_button.disabled = false;
      connect_button.disabled = false;
    },
    style: {
      display: "none"
    },
    type: "file"
  });
  new_connection_button = dom$1("button", {
    onclick: function() {
      file_input.click();
    }
  }, ["New connection"]);
  remove_button = dom$1("button", {
    disabled: select_box.options.length < 1,
    onclick: function on_remove_click() {
      const option = Array.from(
        select_box.options
      ).find(function(option2) {
        return option2.value === select_box.value;
      });
      db_connections = db_connections.filter(function({ name }) {
        return name !== select_box.value;
      });
      file_input.value = "";
      option.remove();
      if (db_connections.length < 1) {
        remove_button.disabled = true;
        connect_button.disabled = true;
      }
      on_remove();
    }
  }, ["Remove"]);
  shadow.append(
    select_box,
    connect_button,
    file_input,
    new_connection_button,
    remove_button
  );
});
const geopkg_conn_ui$1 = Object.freeze(geopkg_conn_ui);
const geopkg_table_ui = make_ui("geopkg-table-ui", function(element, {
  columns,
  on_row_click,
  rows
}) {
  let table;
  let table_rows;
  let table_columns;
  const shadow = element.attachShadow({ mode: "closed" });
  table = dom$1("table");
  table_columns = dom$1("tr", columns.map(function(column_name) {
    return dom$1("th", [
      column_name
    ]);
  }));
  table_rows = rows.map(function(row) {
    return dom$1("tr", {
      onclick: function(e) {
        e.preventDefault();
        on_row_click(row);
      }
    }, row.map(function(value) {
      return dom$1("td", [value]);
    }));
  });
  table.append(table_columns, ...table_rows);
  shadow.append(table);
});
const geopkg_table_ui$1 = Object.freeze(geopkg_table_ui);
const geopkg_controls_ui = make_ui("geopkg-controls-ui", function(element, {
  on_close
}) {
  let add_button;
  let close_button;
  const shadow = element.attachShadow({ mode: "closed" });
  function attach_listeners({ on_add }) {
    add_button.onclick = on_add;
  }
  function remove_listeners() {
    [add_button].forEach(function(button) {
      delete button.onclick;
    });
  }
  add_button = dom$1("button", [
    "Add"
  ]);
  close_button = dom$1("button", {
    onclick: function(event) {
      event.preventDefault();
      on_close();
    }
  }, [
    "Close"
  ]);
  shadow.append(add_button, close_button);
  element.attach_listeners = attach_listeners;
  element.remove_listeners = remove_listeners;
});
const geopkg_controls_ui$1 = Object.freeze(geopkg_controls_ui);
const geopkg_ui = make_ui("geopkg-ui", function(element, {
  db,
  on_add,
  on_close
}) {
  let connections;
  let table;
  let controls;
  const shadow = element.attachShadow({ mode: "closed" });
  function on_connect({ geopackage: geopackage2 }) {
    if (table) {
      table.remove();
    }
    const [result] = geopackage2.get_feature_tables();
    table = geopkg_table_ui$1({
      columns: result.columns,
      on_row_click: function(row) {
        const [table_name] = row;
        controls.remove_listeners();
        controls.attach_listeners({
          on_add: function() {
            const [feature] = geopackage2.get_feature(
              table_name
            );
            on_add(feature);
          }
        });
      },
      rows: result.values
    });
    shadow.append(table);
  }
  connections = geopkg_conn_ui$1({
    db,
    on_connect,
    on_remove: function() {
      controls == null ? void 0 : controls.remove_listeners();
      table == null ? void 0 : table.remove();
    }
  });
  controls = geopkg_controls_ui$1({
    on_close
  });
  shadow.append(connections, controls);
});
const geopkg_ui$1 = Object.freeze(geopkg_ui);
const source_manager_ui = make_ui("source-manager-ui", function(element, {
  map,
  db,
  on_add_source
}) {
  let source_content;
  let sources_container;
  const sources = [
    {
      component: xyz_ui$1({
        on_add_source: function(source) {
          const ol_layer = new TileLayer({
            source: new XYZ({
              maxZoom: source.max_zoom_level,
              minZoom: source.min_zoom_level,
              url: source.url
            })
          });
          map.addLayer(ol_layer);
          on_add_source({
            ol_layer,
            source
          });
        }
      }),
      image: "",
      name: "XYZ"
    },
    {
      component: geopkg_ui$1({
        db,
        map
      }),
      image: "",
      name: "Geopackage"
    }
  ];
  const shadow = element.attachShadow({ mode: "closed" });
  const sources_list = sources.map(function(source) {
    return dom$1("li", [
      dom$1("input", {
        id: source.name,
        name: "source",
        onchange: function() {
          source_content.innerHTML = "";
          source_content.append(source.component);
        },
        type: "radio"
      }),
      dom$1("label", {
        htmlFor: source.name
      }, [source.name])
    ]);
  });
  source_content = dom$1("div");
  sources_container = dom$1("ul", sources_list);
  shadow.append(sources_container, source_content);
});
const source_manager_ui$1 = Object.freeze(source_manager_ui);
function render_css() {
  return `
        label:hover {
            cursor: pointer;
        }
    `;
}
const layer_ui = make_ui("layer-ui", function(element, {
  is_checked = false,
  on_layer_removed,
  on_properties_clicked,
  on_visibility_checked,
  title
}) {
  let check_box;
  let label;
  let delete_button;
  const style = dom$1("style");
  const shadow = element.attachShadow({ mode: "closed" });
  style.textContent = render_css();
  check_box = dom$1("input", {
    checked: is_checked,
    onchange: function(event) {
      on_visibility_checked(event.target.checked);
    },
    type: "checkbox"
  });
  label = dom$1("label", {
    onclick: function(event) {
      event.preventDefault();
      on_properties_clicked();
    }
  }, [
    title
  ]);
  delete_button = dom$1("button", {
    onclick: function(event) {
      event.preventDefault();
      on_layer_removed();
    }
  }, [
    "Delete"
  ]);
  shadow.append(style, check_box, label, delete_button);
});
const layer_ui$1 = Object.freeze(layer_ui);
const layers_ui = make_ui("layers-ui", function(element, {
  layers = [],
  map
}) {
  let layer_switcher;
  const shadow = element.attachShadow({ mode: "closed" });
  function add_layer(source, ol_layer) {
    let layer_item;
    const layer = layer_ui$1({
      is_checked: true,
      on_layer_removed: function() {
        map.removeLayer(ol_layer);
        layer_item.remove();
      },
      on_properties_clicked: function() {
      },
      on_visibility_checked: function(checked) {
        ol_layer.setVisible(checked);
      },
      title: source.name
    });
    layer_item = dom$1("li", [layer]);
    layer_switcher.append(layer_item);
  }
  layer_switcher = dom$1("ul");
  layers.forEach(add_layer);
  shadow.append(layer_switcher);
  element.add_layer = add_layer;
});
const layers_ui$1 = Object.freeze(layers_ui);
const app_ui = make_ui("app-ui", function(element, {
  db
}) {
  let dialog;
  let map;
  let bottom_pane;
  let source_manager;
  let source_manager_button;
  let layers;
  function mount(target) {
    document.querySelector(target).append(element);
  }
  map = map_ui$1();
  bottom_pane = bottom_pane_ui({
    map: map.get_map()
  });
  dialog = dialog_ui$1({
    on_close() {
      dialog.close();
    },
    visibility: false
  });
  source_manager = source_manager_ui$1({
    db,
    map: map.get_map(),
    on_add_source: function on_add_source({ ol_layer, source }) {
      layers.add_layer(source, ol_layer);
    }
  });
  layers = layers_ui$1({
    map: map.get_map()
  });
  source_manager_button = dom$1("button", {
    onclick: function() {
      dialog.open(source_manager);
    }
  }, ["Source manager"]);
  element.append(
    map,
    source_manager_button,
    layers,
    bottom_pane,
    dialog
  );
  element.mount = mount;
  return element;
});
const app_ui$1 = Object.freeze(app_ui);
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var sqlWasm = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  var initSqlJsPromise = void 0;
  var initSqlJs = function(moduleConfig) {
    if (initSqlJsPromise) {
      return initSqlJsPromise;
    }
    initSqlJsPromise = new Promise(function(resolveModule, reject) {
      var Module = typeof moduleConfig !== "undefined" ? moduleConfig : {};
      var originalOnAbortFunction = Module["onAbort"];
      Module["onAbort"] = function(errorThatCausedAbort) {
        reject(new Error(errorThatCausedAbort));
        if (originalOnAbortFunction) {
          originalOnAbortFunction(errorThatCausedAbort);
        }
      };
      Module["postRun"] = Module["postRun"] || [];
      Module["postRun"].push(function() {
        resolveModule(Module);
      });
      module = void 0;
      var f;
      f || (f = typeof Module != "undefined" ? Module : {});
      var aa = "object" == typeof window, ba = "function" == typeof importScripts, ca = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node;
      f.onRuntimeInitialized = function() {
        function a(g, l) {
          switch (typeof l) {
            case "boolean":
              fc(g, l ? 1 : 0);
              break;
            case "number":
              gc(g, l);
              break;
            case "string":
              hc(g, l, -1, -1);
              break;
            case "object":
              if (null === l) ib(g);
              else if (null != l.length) {
                var n = da(l, ea);
                ic(g, n, l.length, -1);
                fa(n);
              } else xa(g, "Wrong API use : tried to return a value of an unknown type (" + l + ").", -1);
              break;
            default:
              ib(g);
          }
        }
        function b(g, l) {
          for (var n = [], t = 0; t < g; t += 1) {
            var w = m(l + 4 * t, "i32"), A = jc(w);
            if (1 === A || 2 === A) w = kc(w);
            else if (3 === A) w = lc(w);
            else if (4 === A) {
              A = w;
              w = mc(A);
              A = nc(A);
              for (var N = new Uint8Array(w), M = 0; M < w; M += 1) N[M] = p[A + M];
              w = N;
            } else w = null;
            n.push(w);
          }
          return n;
        }
        function c(g, l) {
          this.Ka = g;
          this.db = l;
          this.Ia = 1;
          this.eb = [];
        }
        function d(g, l) {
          this.db = l;
          l = ha(g) + 1;
          this.Xa = ia(l);
          if (null === this.Xa) throw Error("Unable to allocate memory for the SQL string");
          q(g, u, this.Xa, l);
          this.cb = this.Xa;
          this.Ta = this.hb = null;
        }
        function e(g) {
          this.filename = "dbfile_" + (4294967295 * Math.random() >>> 0);
          if (null != g) {
            var l = this.filename, n = "/", t = l;
            n && (n = "string" == typeof n ? n : ja(n), t = l ? x(n + "/" + l) : n);
            l = ka(true, true);
            t = la(t, (void 0 !== l ? l : 438) & 4095 | 32768, 0);
            if (g) {
              if ("string" == typeof g) {
                n = Array(g.length);
                for (var w = 0, A = g.length; w < A; ++w) n[w] = g.charCodeAt(w);
                g = n;
              }
              ma(t, l | 146);
              n = na(t, 577);
              oa(n, g, 0, g.length, 0);
              pa(n);
              ma(t, l);
            }
          }
          this.handleError(r(this.filename, h));
          this.db = m(h, "i32");
          lb(this.db);
          this.Ya = {};
          this.Ma = {};
        }
        var h = y(4), k = f.cwrap, r = k("sqlite3_open", "number", ["string", "number"]), z = k("sqlite3_close_v2", "number", ["number"]), v = k("sqlite3_exec", "number", ["number", "string", "number", "number", "number"]), E = k(
          "sqlite3_changes",
          "number",
          ["number"]
        ), H = k("sqlite3_prepare_v2", "number", ["number", "string", "number", "number", "number"]), mb = k("sqlite3_sql", "string", ["number"]), oc = k("sqlite3_normalized_sql", "string", ["number"]), nb = k("sqlite3_prepare_v2", "number", ["number", "number", "number", "number", "number"]), pc = k("sqlite3_bind_text", "number", ["number", "number", "number", "number", "number"]), ob = k("sqlite3_bind_blob", "number", ["number", "number", "number", "number", "number"]), qc = k("sqlite3_bind_double", "number", ["number", "number", "number"]), rc = k("sqlite3_bind_int", "number", ["number", "number", "number"]), sc = k("sqlite3_bind_parameter_index", "number", ["number", "string"]), tc = k("sqlite3_step", "number", ["number"]), uc = k("sqlite3_errmsg", "string", ["number"]), vc = k("sqlite3_column_count", "number", ["number"]), wc = k("sqlite3_data_count", "number", ["number"]), xc = k("sqlite3_column_double", "number", ["number", "number"]), pb = k("sqlite3_column_text", "string", ["number", "number"]), yc = k("sqlite3_column_blob", "number", ["number", "number"]), zc = k(
          "sqlite3_column_bytes",
          "number",
          ["number", "number"]
        ), Ac = k("sqlite3_column_type", "number", ["number", "number"]), Bc = k("sqlite3_column_name", "string", ["number", "number"]), Cc = k("sqlite3_reset", "number", ["number"]), Dc = k("sqlite3_clear_bindings", "number", ["number"]), Ec = k("sqlite3_finalize", "number", ["number"]), qb = k("sqlite3_create_function_v2", "number", "number string number number number number number number number".split(" ")), jc = k("sqlite3_value_type", "number", ["number"]), mc = k("sqlite3_value_bytes", "number", ["number"]), lc = k(
          "sqlite3_value_text",
          "string",
          ["number"]
        ), nc = k("sqlite3_value_blob", "number", ["number"]), kc = k("sqlite3_value_double", "number", ["number"]), gc = k("sqlite3_result_double", "", ["number", "number"]), ib = k("sqlite3_result_null", "", ["number"]), hc = k("sqlite3_result_text", "", ["number", "string", "number", "number"]), ic = k("sqlite3_result_blob", "", ["number", "number", "number", "number"]), fc = k("sqlite3_result_int", "", ["number", "number"]), xa = k("sqlite3_result_error", "", ["number", "string", "number"]), rb = k(
          "sqlite3_aggregate_context",
          "number",
          ["number", "number"]
        ), lb = k("RegisterExtensionFunctions", "number", ["number"]);
        c.prototype.bind = function(g) {
          if (!this.Ka) throw "Statement closed";
          this.reset();
          return Array.isArray(g) ? this.vb(g) : null != g && "object" === typeof g ? this.wb(g) : true;
        };
        c.prototype.step = function() {
          if (!this.Ka) throw "Statement closed";
          this.Ia = 1;
          var g = tc(this.Ka);
          switch (g) {
            case 100:
              return true;
            case 101:
              return false;
            default:
              throw this.db.handleError(g);
          }
        };
        c.prototype.qb = function(g) {
          null == g && (g = this.Ia, this.Ia += 1);
          return xc(this.Ka, g);
        };
        c.prototype.zb = function(g) {
          null == g && (g = this.Ia, this.Ia += 1);
          g = pb(this.Ka, g);
          if ("function" !== typeof BigInt) throw Error("BigInt is not supported");
          return BigInt(g);
        };
        c.prototype.Ab = function(g) {
          null == g && (g = this.Ia, this.Ia += 1);
          return pb(this.Ka, g);
        };
        c.prototype.getBlob = function(g) {
          null == g && (g = this.Ia, this.Ia += 1);
          var l = zc(this.Ka, g);
          g = yc(this.Ka, g);
          for (var n = new Uint8Array(l), t = 0; t < l; t += 1) n[t] = p[g + t];
          return n;
        };
        c.prototype.get = function(g, l) {
          l = l || {};
          null != g && this.bind(g) && this.step();
          g = [];
          for (var n = wc(this.Ka), t = 0; t < n; t += 1) switch (Ac(this.Ka, t)) {
            case 1:
              var w = l.useBigInt ? this.zb(t) : this.qb(t);
              g.push(w);
              break;
            case 2:
              g.push(this.qb(t));
              break;
            case 3:
              g.push(this.Ab(t));
              break;
            case 4:
              g.push(this.getBlob(t));
              break;
            default:
              g.push(null);
          }
          return g;
        };
        c.prototype.getColumnNames = function() {
          for (var g = [], l = vc(this.Ka), n = 0; n < l; n += 1) g.push(Bc(this.Ka, n));
          return g;
        };
        c.prototype.getAsObject = function(g, l) {
          g = this.get(g, l);
          l = this.getColumnNames();
          for (var n = {}, t = 0; t < l.length; t += 1) n[l[t]] = g[t];
          return n;
        };
        c.prototype.getSQL = function() {
          return mb(this.Ka);
        };
        c.prototype.getNormalizedSQL = function() {
          return oc(this.Ka);
        };
        c.prototype.run = function(g) {
          null != g && this.bind(g);
          this.step();
          return this.reset();
        };
        c.prototype.mb = function(g, l) {
          null == l && (l = this.Ia, this.Ia += 1);
          g = qa(g);
          var n = da(g, ea);
          this.eb.push(n);
          this.db.handleError(pc(this.Ka, l, n, g.length - 1, 0));
        };
        c.prototype.ub = function(g, l) {
          null == l && (l = this.Ia, this.Ia += 1);
          var n = da(g, ea);
          this.eb.push(n);
          this.db.handleError(ob(this.Ka, l, n, g.length, 0));
        };
        c.prototype.lb = function(g, l) {
          null == l && (l = this.Ia, this.Ia += 1);
          this.db.handleError((g === (g | 0) ? rc : qc)(this.Ka, l, g));
        };
        c.prototype.xb = function(g) {
          null == g && (g = this.Ia, this.Ia += 1);
          ob(this.Ka, g, 0, 0, 0);
        };
        c.prototype.nb = function(g, l) {
          null == l && (l = this.Ia, this.Ia += 1);
          switch (typeof g) {
            case "string":
              this.mb(g, l);
              return;
            case "number":
              this.lb(g, l);
              return;
            case "bigint":
              this.mb(g.toString(), l);
              return;
            case "boolean":
              this.lb(g + 0, l);
              return;
            case "object":
              if (null === g) {
                this.xb(l);
                return;
              }
              if (null != g.length) {
                this.ub(g, l);
                return;
              }
          }
          throw "Wrong API use : tried to bind a value of an unknown type (" + g + ").";
        };
        c.prototype.wb = function(g) {
          var l = this;
          Object.keys(g).forEach(function(n) {
            var t = sc(l.Ka, n);
            0 !== t && l.nb(g[n], t);
          });
          return true;
        };
        c.prototype.vb = function(g) {
          for (var l = 0; l < g.length; l += 1) this.nb(g[l], l + 1);
          return true;
        };
        c.prototype.reset = function() {
          this.freemem();
          return 0 === Dc(this.Ka) && 0 === Cc(this.Ka);
        };
        c.prototype.freemem = function() {
          for (var g; void 0 !== (g = this.eb.pop()); ) fa(g);
        };
        c.prototype.free = function() {
          this.freemem();
          var g = 0 === Ec(this.Ka);
          delete this.db.Ya[this.Ka];
          this.Ka = 0;
          return g;
        };
        d.prototype.next = function() {
          if (null === this.Xa) return { done: true };
          null !== this.Ta && (this.Ta.free(), this.Ta = null);
          if (!this.db.db) throw this.fb(), Error("Database closed");
          var g = ra(), l = y(4);
          sa(h);
          sa(l);
          try {
            this.db.handleError(nb(this.db.db, this.cb, -1, h, l));
            this.cb = m(l, "i32");
            var n = m(h, "i32");
            if (0 === n) return this.fb(), { done: true };
            this.Ta = new c(n, this.db);
            this.db.Ya[n] = this.Ta;
            return { value: this.Ta, done: false };
          } catch (t) {
            throw this.hb = ta(this.cb), this.fb(), t;
          } finally {
            ua2(g);
          }
        };
        d.prototype.fb = function() {
          fa(this.Xa);
          this.Xa = null;
        };
        d.prototype.getRemainingSQL = function() {
          return null !== this.hb ? this.hb : ta(this.cb);
        };
        "function" === typeof Symbol && "symbol" === typeof Symbol.iterator && (d.prototype[Symbol.iterator] = function() {
          return this;
        });
        e.prototype.run = function(g, l) {
          if (!this.db) throw "Database closed";
          if (l) {
            g = this.prepare(g, l);
            try {
              g.step();
            } finally {
              g.free();
            }
          } else this.handleError(v(this.db, g, 0, 0, h));
          return this;
        };
        e.prototype.exec = function(g, l, n) {
          if (!this.db) throw "Database closed";
          var t = ra(), w = null;
          try {
            var A = va(g), N = y(4);
            for (g = []; 0 !== m(A, "i8"); ) {
              sa(h);
              sa(N);
              this.handleError(nb(
                this.db,
                A,
                -1,
                h,
                N
              ));
              var M = m(h, "i32");
              A = m(N, "i32");
              if (0 !== M) {
                var K = null;
                w = new c(M, this);
                for (null != l && w.bind(l); w.step(); ) null === K && (K = { columns: w.getColumnNames(), values: [] }, g.push(K)), K.values.push(w.get(null, n));
                w.free();
              }
            }
            return g;
          } catch (O) {
            throw w && w.free(), O;
          } finally {
            ua2(t);
          }
        };
        e.prototype.each = function(g, l, n, t, w) {
          "function" === typeof l && (t = n, n = l, l = void 0);
          g = this.prepare(g, l);
          try {
            for (; g.step(); ) n(g.getAsObject(null, w));
          } finally {
            g.free();
          }
          if ("function" === typeof t) return t();
        };
        e.prototype.prepare = function(g, l) {
          sa(h);
          this.handleError(H(this.db, g, -1, h, 0));
          g = m(h, "i32");
          if (0 === g) throw "Nothing to prepare";
          var n = new c(g, this);
          null != l && n.bind(l);
          return this.Ya[g] = n;
        };
        e.prototype.iterateStatements = function(g) {
          return new d(g, this);
        };
        e.prototype["export"] = function() {
          Object.values(this.Ya).forEach(function(l) {
            l.free();
          });
          Object.values(this.Ma).forEach(wa);
          this.Ma = {};
          this.handleError(z(this.db));
          var g = ya(this.filename);
          this.handleError(r(this.filename, h));
          this.db = m(h, "i32");
          lb(this.db);
          return g;
        };
        e.prototype.close = function() {
          null !== this.db && (Object.values(this.Ya).forEach(function(g) {
            g.free();
          }), Object.values(this.Ma).forEach(wa), this.Ma = {}, this.handleError(z(this.db)), za("/" + this.filename), this.db = null);
        };
        e.prototype.handleError = function(g) {
          if (0 === g) return null;
          g = uc(this.db);
          throw Error(g);
        };
        e.prototype.getRowsModified = function() {
          return E(this.db);
        };
        e.prototype.create_function = function(g, l) {
          Object.prototype.hasOwnProperty.call(this.Ma, g) && (wa(this.Ma[g]), delete this.Ma[g]);
          var n = Aa(function(t, w, A) {
            w = b(w, A);
            try {
              var N = l.apply(
                null,
                w
              );
            } catch (M) {
              xa(t, M, -1);
              return;
            }
            a(t, N);
          }, "viii");
          this.Ma[g] = n;
          this.handleError(qb(this.db, g, l.length, 1, 0, n, 0, 0, 0));
          return this;
        };
        e.prototype.create_aggregate = function(g, l) {
          var n = l.init || function() {
            return null;
          }, t = l.finalize || function(K) {
            return K;
          }, w = l.step;
          if (!w) throw "An aggregate function must have a step function in " + g;
          var A = {};
          Object.hasOwnProperty.call(this.Ma, g) && (wa(this.Ma[g]), delete this.Ma[g]);
          l = g + "__finalize";
          Object.hasOwnProperty.call(this.Ma, l) && (wa(this.Ma[l]), delete this.Ma[l]);
          var N = Aa(function(K, O, Ra) {
            var Y = rb(K, 1);
            Object.hasOwnProperty.call(A, Y) || (A[Y] = n());
            O = b(O, Ra);
            O = [A[Y]].concat(O);
            try {
              A[Y] = w.apply(null, O);
            } catch (Gc) {
              delete A[Y], xa(K, Gc, -1);
            }
          }, "viii"), M = Aa(function(K) {
            var O = rb(K, 1);
            try {
              var Ra = t(A[O]);
            } catch (Y) {
              delete A[O];
              xa(K, Y, -1);
              return;
            }
            a(K, Ra);
            delete A[O];
          }, "vi");
          this.Ma[g] = N;
          this.Ma[l] = M;
          this.handleError(qb(this.db, g, w.length - 1, 1, 0, 0, N, M, 0));
          return this;
        };
        f.Database = e;
      };
      var Ba = Object.assign({}, f), Ca = "./this.program", B = "", Da, Ea;
      if (ca) {
        var fs = require$$2, Fa = require$$2;
        B = __dirname + "/";
        Ea = (a) => {
          a = Ga(a) ? new URL(a) : Fa.normalize(a);
          return fs.readFileSync(a);
        };
        Da = (a) => {
          a = Ga(a) ? new URL(a) : Fa.normalize(a);
          return new Promise((b, c) => {
            fs.readFile(a, void 0, (d, e) => {
              d ? c(d) : b(e.buffer);
            });
          });
        };
        !f.thisProgram && 1 < process.argv.length && (Ca = process.argv[1].replace(/\\/g, "/"));
        process.argv.slice(2);
        module.exports = f;
      } else if (aa || ba) ba ? B = self.location.href : "undefined" != typeof document && document.currentScript && (B = document.currentScript.src), B = B.startsWith("blob:") ? "" : B.substr(0, B.replace(/[?#].*/, "").lastIndexOf("/") + 1), ba && (Ea = (a) => {
        var b = new XMLHttpRequest();
        b.open("GET", a, false);
        b.responseType = "arraybuffer";
        b.send(null);
        return new Uint8Array(b.response);
      }), Da = (a) => Ga(a) ? new Promise((b, c) => {
        var d = new XMLHttpRequest();
        d.open("GET", a, true);
        d.responseType = "arraybuffer";
        d.onload = () => {
          (200 == d.status || 0 == d.status && d.response) && c(d.response);
          b(d.status);
        };
        d.onerror = b;
        d.send(null);
      }) : fetch(a, { credentials: "same-origin" }).then((b) => b.ok ? b.arrayBuffer() : Promise.reject(Error(b.status + " : " + b.url)));
      var Ha = f.print || console.log.bind(console), C = f.printErr || console.error.bind(console);
      Object.assign(f, Ba);
      Ba = null;
      f.thisProgram && (Ca = f.thisProgram);
      var Ia;
      f.wasmBinary && (Ia = f.wasmBinary);
      var Ja, Ka = false, p, u, La, D, F, Ma, Na;
      function Oa() {
        var a = Ja.buffer;
        f.HEAP8 = p = new Int8Array(a);
        f.HEAP16 = La = new Int16Array(a);
        f.HEAPU8 = u = new Uint8Array(a);
        f.HEAPU16 = new Uint16Array(a);
        f.HEAP32 = D = new Int32Array(a);
        f.HEAPU32 = F = new Uint32Array(a);
        f.HEAPF32 = Ma = new Float32Array(a);
        f.HEAPF64 = Na = new Float64Array(a);
      }
      var Pa = [], Qa = [], Sa = [];
      function Ta() {
        var a = f.preRun.shift();
        Pa.unshift(a);
      }
      var Ua = 0, Wa = null;
      function G(a) {
        var _a;
        (_a = f.onAbort) == null ? void 0 : _a.call(f, a);
        a = "Aborted(" + a + ")";
        C(a);
        Ka = true;
        throw new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info.");
      }
      var Xa = (a) => a.startsWith("data:application/octet-stream;base64,"), Ga = (a) => a.startsWith("file://"), Ya;
      function Za(a) {
        if (a == Ya && Ia) return new Uint8Array(Ia);
        if (Ea) return Ea(a);
        throw "both async and sync fetching of the wasm failed";
      }
      function $a(a) {
        return Ia ? Promise.resolve().then(() => Za(a)) : Da(a).then((b) => new Uint8Array(b), () => Za(a));
      }
      function ab(a, b, c) {
        return $a(a).then((d) => WebAssembly.instantiate(d, b)).then(c, (d) => {
          C(`failed to asynchronously prepare wasm: ${d}`);
          G(d);
        });
      }
      function bb(a, b) {
        var c = Ya;
        Ia || "function" != typeof WebAssembly.instantiateStreaming || Xa(c) || Ga(c) || ca || "function" != typeof fetch ? ab(c, a, b) : fetch(c, { credentials: "same-origin" }).then((d) => WebAssembly.instantiateStreaming(d, a).then(b, function(e) {
          C(`wasm streaming compile failed: ${e}`);
          C("falling back to ArrayBuffer instantiation");
          return ab(c, a, b);
        }));
      }
      var I, J, cb = (a) => {
        for (; 0 < a.length; ) a.shift()(f);
      };
      function m(a, b = "i8") {
        b.endsWith("*") && (b = "*");
        switch (b) {
          case "i1":
            return p[a];
          case "i8":
            return p[a];
          case "i16":
            return La[a >> 1];
          case "i32":
            return D[a >> 2];
          case "i64":
            G("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return Ma[a >> 2];
          case "double":
            return Na[a >> 3];
          case "*":
            return F[a >> 2];
          default:
            G(`invalid type for getValue: ${b}`);
        }
      }
      function sa(a) {
        var b = "i32";
        b.endsWith("*") && (b = "*");
        switch (b) {
          case "i1":
            p[a] = 0;
            break;
          case "i8":
            p[a] = 0;
            break;
          case "i16":
            La[a >> 1] = 0;
            break;
          case "i32":
            D[a >> 2] = 0;
            break;
          case "i64":
            G("to do setValue(i64) use WASM_BIGINT");
          case "float":
            Ma[a >> 2] = 0;
            break;
          case "double":
            Na[a >> 3] = 0;
            break;
          case "*":
            F[a >> 2] = 0;
            break;
          default:
            G(`invalid type for setValue: ${b}`);
        }
      }
      var db = "undefined" != typeof TextDecoder ? new TextDecoder() : void 0, L = (a, b, c) => {
        var d = b + c;
        for (c = b; a[c] && !(c >= d); ) ++c;
        if (16 < c - b && a.buffer && db) return db.decode(a.subarray(b, c));
        for (d = ""; b < c; ) {
          var e = a[b++];
          if (e & 128) {
            var h = a[b++] & 63;
            if (192 == (e & 224)) d += String.fromCharCode((e & 31) << 6 | h);
            else {
              var k = a[b++] & 63;
              e = 224 == (e & 240) ? (e & 15) << 12 | h << 6 | k : (e & 7) << 18 | h << 12 | k << 6 | a[b++] & 63;
              65536 > e ? d += String.fromCharCode(e) : (e -= 65536, d += String.fromCharCode(55296 | e >> 10, 56320 | e & 1023));
            }
          } else d += String.fromCharCode(e);
        }
        return d;
      }, ta = (a, b) => a ? L(u, a, b) : "", eb = (a, b) => {
        for (var c = 0, d = a.length - 1; 0 <= d; d--) {
          var e = a[d];
          "." === e ? a.splice(d, 1) : ".." === e ? (a.splice(d, 1), c++) : c && (a.splice(d, 1), c--);
        }
        if (b) for (; c; c--) a.unshift("..");
        return a;
      }, x = (a) => {
        var b = "/" === a.charAt(0), c = "/" === a.substr(-1);
        (a = eb(a.split("/").filter((d) => !!d), !b).join("/")) || b || (a = ".");
        a && c && (a += "/");
        return (b ? "/" : "") + a;
      }, fb = (a) => {
        var b = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a).slice(1);
        a = b[0];
        b = b[1];
        if (!a && !b) return ".";
        b && (b = b.substr(0, b.length - 1));
        return a + b;
      }, gb = (a) => {
        if ("/" === a) return "/";
        a = x(a);
        a = a.replace(/\/$/, "");
        var b = a.lastIndexOf("/");
        return -1 === b ? a : a.substr(b + 1);
      }, hb = () => {
        if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) return (c) => crypto.getRandomValues(c);
        if (ca) try {
          var a = require$$2;
          if (a.randomFillSync) return (c) => a.randomFillSync(c);
          var b = a.randomBytes;
          return (c) => (c.set(b(c.byteLength)), c);
        } catch (c) {
        }
        G("initRandomDevice");
      }, jb = (a) => (jb = hb())(a), kb = (...a) => {
        for (var b = "", c = false, d = a.length - 1; -1 <= d && !c; d--) {
          c = 0 <= d ? a[d] : "/";
          if ("string" != typeof c) throw new TypeError("Arguments to path.resolve must be strings");
          if (!c) return "";
          b = c + "/" + b;
          c = "/" === c.charAt(0);
        }
        b = eb(b.split("/").filter((e) => !!e), !c).join("/");
        return (c ? "/" : "") + b || ".";
      }, sb = [], ha = (a) => {
        for (var b = 0, c = 0; c < a.length; ++c) {
          var d = a.charCodeAt(c);
          127 >= d ? b++ : 2047 >= d ? b += 2 : 55296 <= d && 57343 >= d ? (b += 4, ++c) : b += 3;
        }
        return b;
      }, q = (a, b, c, d) => {
        if (!(0 < d)) return 0;
        var e = c;
        d = c + d - 1;
        for (var h = 0; h < a.length; ++h) {
          var k = a.charCodeAt(h);
          if (55296 <= k && 57343 >= k) {
            var r = a.charCodeAt(++h);
            k = 65536 + ((k & 1023) << 10) | r & 1023;
          }
          if (127 >= k) {
            if (c >= d) break;
            b[c++] = k;
          } else {
            if (2047 >= k) {
              if (c + 1 >= d) break;
              b[c++] = 192 | k >> 6;
            } else {
              if (65535 >= k) {
                if (c + 2 >= d) break;
                b[c++] = 224 | k >> 12;
              } else {
                if (c + 3 >= d) break;
                b[c++] = 240 | k >> 18;
                b[c++] = 128 | k >> 12 & 63;
              }
              b[c++] = 128 | k >> 6 & 63;
            }
            b[c++] = 128 | k & 63;
          }
        }
        b[c] = 0;
        return c - e;
      };
      function qa(a, b) {
        var c = Array(ha(a) + 1);
        a = q(a, c, 0, c.length);
        b && (c.length = a);
        return c;
      }
      var tb = [];
      function ub(a, b) {
        tb[a] = { input: [], output: [], Wa: b };
        vb(a, wb);
      }
      var wb = { open(a) {
        var b = tb[a.node.rdev];
        if (!b) throw new P(43);
        a.tty = b;
        a.seekable = false;
      }, close(a) {
        a.tty.Wa.fsync(a.tty);
      }, fsync(a) {
        a.tty.Wa.fsync(a.tty);
      }, read(a, b, c, d) {
        if (!a.tty || !a.tty.Wa.rb) throw new P(60);
        for (var e = 0, h = 0; h < d; h++) {
          try {
            var k = a.tty.Wa.rb(a.tty);
          } catch (r) {
            throw new P(29);
          }
          if (void 0 === k && 0 === e) throw new P(6);
          if (null === k || void 0 === k) break;
          e++;
          b[c + h] = k;
        }
        e && (a.node.timestamp = Date.now());
        return e;
      }, write(a, b, c, d) {
        if (!a.tty || !a.tty.Wa.ib) throw new P(60);
        try {
          for (var e = 0; e < d; e++) a.tty.Wa.ib(a.tty, b[c + e]);
        } catch (h) {
          throw new P(29);
        }
        d && (a.node.timestamp = Date.now());
        return e;
      } }, xb = { rb() {
        a: {
          if (!sb.length) {
            var a = null;
            if (ca) {
              var b = Buffer.alloc(256), c = 0, d = process.stdin.fd;
              try {
                c = fs.readSync(d, b, 0, 256);
              } catch (e) {
                if (e.toString().includes("EOF")) c = 0;
                else throw e;
              }
              0 < c && (a = b.slice(0, c).toString("utf-8"));
            } else "undefined" != typeof window && "function" == typeof window.prompt && (a = window.prompt("Input: "), null !== a && (a += "\n"));
            if (!a) {
              a = null;
              break a;
            }
            sb = qa(a, true);
          }
          a = sb.shift();
        }
        return a;
      }, ib(a, b) {
        null === b || 10 === b ? (Ha(L(
          a.output,
          0
        )), a.output = []) : 0 != b && a.output.push(b);
      }, fsync(a) {
        a.output && 0 < a.output.length && (Ha(L(a.output, 0)), a.output = []);
      }, Lb() {
        return { Gb: 25856, Ib: 5, Fb: 191, Hb: 35387, Eb: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      }, Mb() {
        return 0;
      }, Nb() {
        return [24, 80];
      } }, yb = { ib(a, b) {
        null === b || 10 === b ? (C(L(a.output, 0)), a.output = []) : 0 != b && a.output.push(b);
      }, fsync(a) {
        a.output && 0 < a.output.length && (C(L(a.output, 0)), a.output = []);
      } };
      function zb(a, b) {
        var c = a.Ha ? a.Ha.length : 0;
        c >= b || (b = Math.max(b, c * (1048576 > c ? 2 : 1.125) >>> 0), 0 != c && (b = Math.max(b, 256)), c = a.Ha, a.Ha = new Uint8Array(b), 0 < a.La && a.Ha.set(c.subarray(0, a.La), 0));
      }
      var Q = {
        Pa: null,
        Qa() {
          return Q.createNode(null, "/", 16895, 0);
        },
        createNode(a, b, c, d) {
          if (24576 === (c & 61440) || 4096 === (c & 61440)) throw new P(63);
          Q.Pa || (Q.Pa = { dir: { node: { Oa: Q.Fa.Oa, Na: Q.Fa.Na, lookup: Q.Fa.lookup, $a: Q.Fa.$a, rename: Q.Fa.rename, unlink: Q.Fa.unlink, rmdir: Q.Fa.rmdir, readdir: Q.Fa.readdir, symlink: Q.Fa.symlink }, stream: { Sa: Q.Ga.Sa } }, file: { node: { Oa: Q.Fa.Oa, Na: Q.Fa.Na }, stream: { Sa: Q.Ga.Sa, read: Q.Ga.read, write: Q.Ga.write, kb: Q.Ga.kb, ab: Q.Ga.ab, bb: Q.Ga.bb } }, link: {
            node: { Oa: Q.Fa.Oa, Na: Q.Fa.Na, readlink: Q.Fa.readlink },
            stream: {}
          }, ob: { node: { Oa: Q.Fa.Oa, Na: Q.Fa.Na }, stream: Ab } });
          c = Bb(a, b, c, d);
          R(c.mode) ? (c.Fa = Q.Pa.dir.node, c.Ga = Q.Pa.dir.stream, c.Ha = {}) : 32768 === (c.mode & 61440) ? (c.Fa = Q.Pa.file.node, c.Ga = Q.Pa.file.stream, c.La = 0, c.Ha = null) : 40960 === (c.mode & 61440) ? (c.Fa = Q.Pa.link.node, c.Ga = Q.Pa.link.stream) : 8192 === (c.mode & 61440) && (c.Fa = Q.Pa.ob.node, c.Ga = Q.Pa.ob.stream);
          c.timestamp = Date.now();
          a && (a.Ha[b] = c, a.timestamp = c.timestamp);
          return c;
        },
        Kb(a) {
          return a.Ha ? a.Ha.subarray ? a.Ha.subarray(0, a.La) : new Uint8Array(a.Ha) : new Uint8Array(0);
        },
        Fa: { Oa(a) {
          var b = {};
          b.dev = 8192 === (a.mode & 61440) ? a.id : 1;
          b.ino = a.id;
          b.mode = a.mode;
          b.nlink = 1;
          b.uid = 0;
          b.gid = 0;
          b.rdev = a.rdev;
          R(a.mode) ? b.size = 4096 : 32768 === (a.mode & 61440) ? b.size = a.La : 40960 === (a.mode & 61440) ? b.size = a.link.length : b.size = 0;
          b.atime = new Date(a.timestamp);
          b.mtime = new Date(a.timestamp);
          b.ctime = new Date(a.timestamp);
          b.yb = 4096;
          b.blocks = Math.ceil(b.size / b.yb);
          return b;
        }, Na(a, b) {
          void 0 !== b.mode && (a.mode = b.mode);
          void 0 !== b.timestamp && (a.timestamp = b.timestamp);
          if (void 0 !== b.size && (b = b.size, a.La != b)) if (0 == b) a.Ha = null, a.La = 0;
          else {
            var c = a.Ha;
            a.Ha = new Uint8Array(b);
            c && a.Ha.set(c.subarray(0, Math.min(b, a.La)));
            a.La = b;
          }
        }, lookup() {
          throw Cb[44];
        }, $a(a, b, c, d) {
          return Q.createNode(a, b, c, d);
        }, rename(a, b, c) {
          if (R(a.mode)) {
            try {
              var d = Db(b, c);
            } catch (h) {
            }
            if (d) for (var e in d.Ha) throw new P(55);
          }
          delete a.parent.Ha[a.name];
          a.parent.timestamp = Date.now();
          a.name = c;
          b.Ha[c] = a;
          b.timestamp = a.parent.timestamp;
        }, unlink(a, b) {
          delete a.Ha[b];
          a.timestamp = Date.now();
        }, rmdir(a, b) {
          var c = Db(a, b), d;
          for (d in c.Ha) throw new P(55);
          delete a.Ha[b];
          a.timestamp = Date.now();
        }, readdir(a) {
          var b = [".", ".."], c;
          for (c of Object.keys(a.Ha)) b.push(c);
          return b;
        }, symlink(a, b, c) {
          a = Q.createNode(a, b, 41471, 0);
          a.link = c;
          return a;
        }, readlink(a) {
          if (40960 !== (a.mode & 61440)) throw new P(28);
          return a.link;
        } },
        Ga: {
          read(a, b, c, d, e) {
            var h = a.node.Ha;
            if (e >= a.node.La) return 0;
            a = Math.min(a.node.La - e, d);
            if (8 < a && h.subarray) b.set(h.subarray(e, e + a), c);
            else for (d = 0; d < a; d++) b[c + d] = h[e + d];
            return a;
          },
          write(a, b, c, d, e, h) {
            b.buffer === p.buffer && (h = false);
            if (!d) return 0;
            a = a.node;
            a.timestamp = Date.now();
            if (b.subarray && (!a.Ha || a.Ha.subarray)) {
              if (h) return a.Ha = b.subarray(c, c + d), a.La = d;
              if (0 === a.La && 0 === e) return a.Ha = b.slice(c, c + d), a.La = d;
              if (e + d <= a.La) return a.Ha.set(b.subarray(c, c + d), e), d;
            }
            zb(a, e + d);
            if (a.Ha.subarray && b.subarray) a.Ha.set(b.subarray(c, c + d), e);
            else for (h = 0; h < d; h++) a.Ha[e + h] = b[c + h];
            a.La = Math.max(a.La, e + d);
            return d;
          },
          Sa(a, b, c) {
            1 === c ? b += a.position : 2 === c && 32768 === (a.node.mode & 61440) && (b += a.node.La);
            if (0 > b) throw new P(28);
            return b;
          },
          kb(a, b, c) {
            zb(a.node, b + c);
            a.node.La = Math.max(a.node.La, b + c);
          },
          ab(a, b, c, d, e) {
            if (32768 !== (a.node.mode & 61440)) throw new P(43);
            a = a.node.Ha;
            if (e & 2 || a.buffer !== p.buffer) {
              if (0 < c || c + b < a.length) a.subarray ? a = a.subarray(c, c + b) : a = Array.prototype.slice.call(a, c, c + b);
              c = true;
              b = 65536 * Math.ceil(b / 65536);
              (e = Eb(65536, b)) ? (u.fill(0, e, e + b), b = e) : b = 0;
              if (!b) throw new P(48);
              p.set(a, b);
            } else c = false, b = a.byteOffset;
            return { Cb: b, tb: c };
          },
          bb(a, b, c, d) {
            Q.Ga.write(a, b, 0, d, c, false);
            return 0;
          }
        }
      }, ka = (a, b) => {
        var c = 0;
        a && (c |= 365);
        b && (c |= 146);
        return c;
      }, Fb = null, Gb = {}, Hb = [], Ib = 1, S = null, Jb = true, P = class {
        constructor(a) {
          this.name = "ErrnoError";
          this.Ja = a;
        }
      }, Cb = {}, Kb = class {
        constructor() {
          this.Za = {};
          this.node = null;
        }
        get flags() {
          return this.Za.flags;
        }
        set flags(a) {
          this.Za.flags = a;
        }
        get position() {
          return this.Za.position;
        }
        set position(a) {
          this.Za.position = a;
        }
      }, Lb = class {
        constructor(a, b, c, d) {
          a || (a = this);
          this.parent = a;
          this.Qa = a.Qa;
          this.Ua = null;
          this.id = Ib++;
          this.name = b;
          this.mode = c;
          this.Fa = {};
          this.Ga = {};
          this.rdev = d;
        }
        get read() {
          return 365 === (this.mode & 365);
        }
        set read(a) {
          a ? this.mode |= 365 : this.mode &= -366;
        }
        get write() {
          return 146 === (this.mode & 146);
        }
        set write(a) {
          a ? this.mode |= 146 : this.mode &= -147;
        }
      };
      function T(a, b = {}) {
        a = kb(a);
        if (!a) return { path: "", node: null };
        b = Object.assign({ pb: true, jb: 0 }, b);
        if (8 < b.jb) throw new P(32);
        a = a.split("/").filter((k) => !!k);
        for (var c = Fb, d = "/", e = 0; e < a.length; e++) {
          var h = e === a.length - 1;
          if (h && b.parent) break;
          c = Db(c, a[e]);
          d = x(d + "/" + a[e]);
          c.Ua && (!h || h && b.pb) && (c = c.Ua.root);
          if (!h || b.Ra) {
            for (h = 0; 40960 === (c.mode & 61440); ) if (c = Mb(d), d = kb(fb(d), c), c = T(d, { jb: b.jb + 1 }).node, 40 < h++) throw new P(32);
          }
        }
        return { path: d, node: c };
      }
      function ja(a) {
        for (var b; ; ) {
          if (a === a.parent) return a = a.Qa.sb, b ? "/" !== a[a.length - 1] ? `${a}/${b}` : a + b : a;
          b = b ? `${a.name}/${b}` : a.name;
          a = a.parent;
        }
      }
      function Nb(a, b) {
        for (var c = 0, d = 0; d < b.length; d++) c = (c << 5) - c + b.charCodeAt(d) | 0;
        return (a + c >>> 0) % S.length;
      }
      function Ob(a) {
        var b = Nb(a.parent.id, a.name);
        if (S[b] === a) S[b] = a.Va;
        else for (b = S[b]; b; ) {
          if (b.Va === a) {
            b.Va = a.Va;
            break;
          }
          b = b.Va;
        }
      }
      function Db(a, b) {
        var c = R(a.mode) ? (c = Pb(a, "x")) ? c : a.Fa.lookup ? 0 : 2 : 54;
        if (c) throw new P(c);
        for (c = S[Nb(a.id, b)]; c; c = c.Va) {
          var d = c.name;
          if (c.parent.id === a.id && d === b) return c;
        }
        return a.Fa.lookup(a, b);
      }
      function Bb(a, b, c, d) {
        a = new Lb(a, b, c, d);
        b = Nb(a.parent.id, a.name);
        a.Va = S[b];
        return S[b] = a;
      }
      function R(a) {
        return 16384 === (a & 61440);
      }
      function Qb(a) {
        var b = ["r", "w", "rw"][a & 3];
        a & 512 && (b += "w");
        return b;
      }
      function Pb(a, b) {
        if (Jb) return 0;
        if (!b.includes("r") || a.mode & 292) {
          if (b.includes("w") && !(a.mode & 146) || b.includes("x") && !(a.mode & 73)) return 2;
        } else return 2;
        return 0;
      }
      function Rb(a, b) {
        try {
          return Db(a, b), 20;
        } catch (c) {
        }
        return Pb(a, "wx");
      }
      function Sb(a, b, c) {
        try {
          var d = Db(a, b);
        } catch (e) {
          return e.Ja;
        }
        if (a = Pb(a, "wx")) return a;
        if (c) {
          if (!R(d.mode)) return 54;
          if (d === d.parent || "/" === ja(d)) return 10;
        } else if (R(d.mode)) return 31;
        return 0;
      }
      function U(a) {
        a = Hb[a];
        if (!a) throw new P(8);
        return a;
      }
      function Tb(a, b = -1) {
        a = Object.assign(new Kb(), a);
        if (-1 == b) a: {
          for (b = 0; 4096 >= b; b++) if (!Hb[b]) break a;
          throw new P(33);
        }
        a.fd = b;
        return Hb[b] = a;
      }
      function Ub(a, b = -1) {
        var _a, _b;
        a = Tb(a, b);
        (_b = (_a = a.Ga) == null ? void 0 : _a.Jb) == null ? void 0 : _b.call(_a, a);
        return a;
      }
      var Ab = { open(a) {
        var _a, _b;
        a.Ga = Gb[a.node.rdev].Ga;
        (_b = (_a = a.Ga).open) == null ? void 0 : _b.call(_a, a);
      }, Sa() {
        throw new P(70);
      } };
      function vb(a, b) {
        Gb[a] = { Ga: b };
      }
      function Vb(a, b) {
        var c = "/" === b;
        if (c && Fb) throw new P(10);
        if (!c && b) {
          var d = T(b, { pb: false });
          b = d.path;
          d = d.node;
          if (d.Ua) throw new P(10);
          if (!R(d.mode)) throw new P(54);
        }
        b = { type: a, Ob: {}, sb: b, Bb: [] };
        a = a.Qa(b);
        a.Qa = b;
        b.root = a;
        c ? Fb = a : d && (d.Ua = b, d.Qa && d.Qa.Bb.push(b));
      }
      function la(a, b, c) {
        var d = T(a, { parent: true }).node;
        a = gb(a);
        if (!a || "." === a || ".." === a) throw new P(28);
        var e = Rb(d, a);
        if (e) throw new P(e);
        if (!d.Fa.$a) throw new P(63);
        return d.Fa.$a(d, a, b, c);
      }
      function V(a, b) {
        return la(a, (void 0 !== b ? b : 511) & 1023 | 16384, 0);
      }
      function Wb(a, b, c) {
        "undefined" == typeof c && (c = b, b = 438);
        la(a, b | 8192, c);
      }
      function Xb(a, b) {
        if (!kb(a)) throw new P(44);
        var c = T(b, { parent: true }).node;
        if (!c) throw new P(44);
        b = gb(b);
        var d = Rb(c, b);
        if (d) throw new P(d);
        if (!c.Fa.symlink) throw new P(63);
        c.Fa.symlink(c, b, a);
      }
      function Yb(a) {
        var b = T(a, { parent: true }).node;
        a = gb(a);
        var c = Db(b, a), d = Sb(b, a, true);
        if (d) throw new P(d);
        if (!b.Fa.rmdir) throw new P(63);
        if (c.Ua) throw new P(10);
        b.Fa.rmdir(b, a);
        Ob(c);
      }
      function za(a) {
        var b = T(a, { parent: true }).node;
        if (!b) throw new P(44);
        a = gb(a);
        var c = Db(b, a), d = Sb(b, a, false);
        if (d) throw new P(d);
        if (!b.Fa.unlink) throw new P(63);
        if (c.Ua) throw new P(10);
        b.Fa.unlink(b, a);
        Ob(c);
      }
      function Mb(a) {
        a = T(a).node;
        if (!a) throw new P(44);
        if (!a.Fa.readlink) throw new P(28);
        return kb(ja(a.parent), a.Fa.readlink(a));
      }
      function Zb(a, b) {
        a = T(a, { Ra: !b }).node;
        if (!a) throw new P(44);
        if (!a.Fa.Oa) throw new P(63);
        return a.Fa.Oa(a);
      }
      function $b(a) {
        return Zb(a, true);
      }
      function ma(a, b) {
        a = "string" == typeof a ? T(a, { Ra: true }).node : a;
        if (!a.Fa.Na) throw new P(63);
        a.Fa.Na(a, { mode: b & 4095 | a.mode & -4096, timestamp: Date.now() });
      }
      function ac(a, b) {
        if (0 > b) throw new P(28);
        a = "string" == typeof a ? T(a, { Ra: true }).node : a;
        if (!a.Fa.Na) throw new P(63);
        if (R(a.mode)) throw new P(31);
        if (32768 !== (a.mode & 61440)) throw new P(28);
        var c = Pb(a, "w");
        if (c) throw new P(c);
        a.Fa.Na(a, { size: b, timestamp: Date.now() });
      }
      function na(a, b, c) {
        if ("" === a) throw new P(44);
        if ("string" == typeof b) {
          var d = { r: 0, "r+": 2, w: 577, "w+": 578, a: 1089, "a+": 1090 }[b];
          if ("undefined" == typeof d) throw Error(`Unknown file open mode: ${b}`);
          b = d;
        }
        c = b & 64 ? ("undefined" == typeof c ? 438 : c) & 4095 | 32768 : 0;
        if ("object" == typeof a) var e = a;
        else {
          a = x(a);
          try {
            e = T(a, { Ra: !(b & 131072) }).node;
          } catch (h) {
          }
        }
        d = false;
        if (b & 64) if (e) {
          if (b & 128) throw new P(20);
        } else e = la(a, c, 0), d = true;
        if (!e) throw new P(44);
        8192 === (e.mode & 61440) && (b &= -513);
        if (b & 65536 && !R(e.mode)) throw new P(54);
        if (!d && (c = e ? 40960 === (e.mode & 61440) ? 32 : R(e.mode) && ("r" !== Qb(b) || b & 512) ? 31 : Pb(e, Qb(b)) : 44)) throw new P(c);
        b & 512 && !d && ac(e, 0);
        b &= -131713;
        e = Tb({ node: e, path: ja(e), flags: b, seekable: true, position: 0, Ga: e.Ga, Db: [], error: false });
        e.Ga.open && e.Ga.open(e);
        !f.logReadFiles || b & 1 || (bc || (bc = {}), a in bc || (bc[a] = 1));
        return e;
      }
      function pa(a) {
        if (null === a.fd) throw new P(8);
        a.gb && (a.gb = null);
        try {
          a.Ga.close && a.Ga.close(a);
        } catch (b) {
          throw b;
        } finally {
          Hb[a.fd] = null;
        }
        a.fd = null;
      }
      function cc(a, b, c) {
        if (null === a.fd) throw new P(8);
        if (!a.seekable || !a.Ga.Sa) throw new P(70);
        if (0 != c && 1 != c && 2 != c) throw new P(28);
        a.position = a.Ga.Sa(a, b, c);
        a.Db = [];
      }
      function dc(a, b, c, d, e) {
        if (0 > d || 0 > e) throw new P(28);
        if (null === a.fd) throw new P(8);
        if (1 === (a.flags & 2097155)) throw new P(8);
        if (R(a.node.mode)) throw new P(31);
        if (!a.Ga.read) throw new P(28);
        var h = "undefined" != typeof e;
        if (!h) e = a.position;
        else if (!a.seekable) throw new P(70);
        b = a.Ga.read(a, b, c, d, e);
        h || (a.position += b);
        return b;
      }
      function oa(a, b, c, d, e) {
        if (0 > d || 0 > e) throw new P(28);
        if (null === a.fd) throw new P(8);
        if (0 === (a.flags & 2097155)) throw new P(8);
        if (R(a.node.mode)) throw new P(31);
        if (!a.Ga.write) throw new P(28);
        a.seekable && a.flags & 1024 && cc(a, 0, 2);
        var h = "undefined" != typeof e;
        if (!h) e = a.position;
        else if (!a.seekable) throw new P(70);
        b = a.Ga.write(a, b, c, d, e, void 0);
        h || (a.position += b);
        return b;
      }
      function ya(a) {
        var c;
        var d = na(a, d || 0);
        a = Zb(a).size;
        var e = new Uint8Array(a);
        dc(d, e, 0, a, 0);
        c = e;
        pa(d);
        return c;
      }
      var ec;
      function Fc(a, b, c) {
        a = x("/dev/" + a);
        var d = ka(!!b, !!c);
        Hc || (Hc = 64);
        var e = Hc++ << 8 | 0;
        vb(e, { open(h) {
          h.seekable = false;
        }, close() {
          var _a;
          ((_a = c == null ? void 0 : c.buffer) == null ? void 0 : _a.length) && c(10);
        }, read(h, k, r, z) {
          for (var v = 0, E = 0; E < z; E++) {
            try {
              var H = b();
            } catch (mb) {
              throw new P(29);
            }
            if (void 0 === H && 0 === v) throw new P(6);
            if (null === H || void 0 === H) break;
            v++;
            k[r + E] = H;
          }
          v && (h.node.timestamp = Date.now());
          return v;
        }, write(h, k, r, z) {
          for (var v = 0; v < z; v++) try {
            c(k[r + v]);
          } catch (E) {
            throw new P(29);
          }
          z && (h.node.timestamp = Date.now());
          return v;
        } });
        Wb(a, d, e);
      }
      var Hc, W = {}, bc;
      function Ic(a, b, c) {
        if ("/" === b.charAt(0)) return b;
        a = -100 === a ? "/" : U(a).path;
        if (0 == b.length) {
          if (!c) throw new P(44);
          return a;
        }
        return x(a + "/" + b);
      }
      function Jc(a, b, c) {
        a = a(b);
        D[c >> 2] = a.dev;
        D[c + 4 >> 2] = a.mode;
        F[c + 8 >> 2] = a.nlink;
        D[c + 12 >> 2] = a.uid;
        D[c + 16 >> 2] = a.gid;
        D[c + 20 >> 2] = a.rdev;
        J = [a.size >>> 0, (I = a.size, 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
        D[c + 24 >> 2] = J[0];
        D[c + 28 >> 2] = J[1];
        D[c + 32 >> 2] = 4096;
        D[c + 36 >> 2] = a.blocks;
        b = a.atime.getTime();
        var d = a.mtime.getTime(), e = a.ctime.getTime();
        J = [Math.floor(b / 1e3) >>> 0, (I = Math.floor(b / 1e3), 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
        D[c + 40 >> 2] = J[0];
        D[c + 44 >> 2] = J[1];
        F[c + 48 >> 2] = b % 1e3 * 1e3;
        J = [Math.floor(d / 1e3) >>> 0, (I = Math.floor(d / 1e3), 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
        D[c + 56 >> 2] = J[0];
        D[c + 60 >> 2] = J[1];
        F[c + 64 >> 2] = d % 1e3 * 1e3;
        J = [Math.floor(e / 1e3) >>> 0, (I = Math.floor(e / 1e3), 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
        D[c + 72 >> 2] = J[0];
        D[c + 76 >> 2] = J[1];
        F[c + 80 >> 2] = e % 1e3 * 1e3;
        J = [a.ino >>> 0, (I = a.ino, 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
        D[c + 88 >> 2] = J[0];
        D[c + 92 >> 2] = J[1];
        return 0;
      }
      var Kc = void 0;
      function Lc() {
        var a = D[+Kc >> 2];
        Kc += 4;
        return a;
      }
      var Mc = (a, b) => b + 2097152 >>> 0 < 4194305 - !!a ? (a >>> 0) + 4294967296 * b : NaN, Nc = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], Oc = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Pc = {}, Rc = () => {
        if (!Qc) {
          var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: Ca || "./this.program" }, b;
          for (b in Pc) void 0 === Pc[b] ? delete a[b] : a[b] = Pc[b];
          var c = [];
          for (b in a) c.push(`${b}=${a[b]}`);
          Qc = c;
        }
        return Qc;
      }, Qc, va = (a) => {
        var b = ha(a) + 1, c = y(b);
        q(a, u, c, b);
        return c;
      }, Sc = (a, b, c, d) => {
        var e = { string: (v) => {
          var E = 0;
          null !== v && void 0 !== v && 0 !== v && (E = va(v));
          return E;
        }, array: (v) => {
          var E = y(v.length);
          p.set(v, E);
          return E;
        } };
        a = f["_" + a];
        var h = [], k = 0;
        if (d) for (var r = 0; r < d.length; r++) {
          var z = e[c[r]];
          z ? (0 === k && (k = ra()), h[r] = z(d[r])) : h[r] = d[r];
        }
        c = a(...h);
        return c = function(v) {
          0 !== k && ua2(k);
          return "string" === b ? v ? L(u, v) : "" : "boolean" === b ? !!v : v;
        }(c);
      }, ea = 0, da = (a, b) => {
        b = 1 == b ? y(a.length) : ia(a.length);
        a.subarray || a.slice || (a = new Uint8Array(a));
        u.set(
          a,
          b
        );
        return b;
      }, Tc, Uc = [], X, wa = (a) => {
        Tc.delete(X.get(a));
        X.set(a, null);
        Uc.push(a);
      }, Aa = (a, b) => {
        if (!Tc) {
          Tc = /* @__PURE__ */ new WeakMap();
          var c = X.length;
          if (Tc) for (var d = 0; d < 0 + c; d++) {
            var e = X.get(d);
            e && Tc.set(e, d);
          }
        }
        if (c = Tc.get(a) || 0) return c;
        if (Uc.length) c = Uc.pop();
        else {
          try {
            X.grow(1);
          } catch (r) {
            if (!(r instanceof RangeError)) throw r;
            throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
          }
          c = X.length - 1;
        }
        try {
          X.set(c, a);
        } catch (r) {
          if (!(r instanceof TypeError)) throw r;
          if ("function" == typeof WebAssembly.Function) {
            d = WebAssembly.Function;
            e = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
            for (var h = { parameters: [], results: "v" == b[0] ? [] : [e[b[0]]] }, k = 1; k < b.length; ++k) h.parameters.push(e[b[k]]);
            b = new d(h, a);
          } else {
            d = [1];
            e = b.slice(0, 1);
            b = b.slice(1);
            h = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
            d.push(96);
            k = b.length;
            128 > k ? d.push(k) : d.push(k % 128 | 128, k >> 7);
            for (k = 0; k < b.length; ++k) d.push(h[b[k]]);
            "v" == e ? d.push(0) : d.push(1, h[e]);
            b = [0, 97, 115, 109, 1, 0, 0, 0, 1];
            e = d.length;
            128 > e ? b.push(e) : b.push(e % 128 | 128, e >> 7);
            b.push(...d);
            b.push(
              2,
              7,
              1,
              1,
              101,
              1,
              102,
              0,
              0,
              7,
              5,
              1,
              1,
              102,
              0,
              0
            );
            b = new WebAssembly.Module(new Uint8Array(b));
            b = new WebAssembly.Instance(b, { e: { f: a } }).exports.f;
          }
          X.set(c, b);
        }
        Tc.set(a, c);
        return c;
      };
      [44].forEach((a) => {
        Cb[a] = new P(a);
        Cb[a].stack = "<generic error, no stack>";
      });
      S = Array(4096);
      Vb(Q, "/");
      V("/tmp");
      V("/home");
      V("/home/web_user");
      (function() {
        V("/dev");
        vb(259, { read: () => 0, write: (d, e, h, k) => k });
        Wb("/dev/null", 259);
        ub(1280, xb);
        ub(1536, yb);
        Wb("/dev/tty", 1280);
        Wb("/dev/tty1", 1536);
        var a = new Uint8Array(1024), b = 0, c = () => {
          0 === b && (b = jb(a).byteLength);
          return a[--b];
        };
        Fc("random", c);
        Fc("urandom", c);
        V("/dev/shm");
        V("/dev/shm/tmp");
      })();
      (function() {
        V("/proc");
        var a = V("/proc/self");
        V("/proc/self/fd");
        Vb({ Qa() {
          var b = Bb(a, "fd", 16895, 73);
          b.Fa = { lookup(c, d) {
            var e = U(+d);
            c = { parent: null, Qa: { sb: "fake" }, Fa: { readlink: () => e.path } };
            return c.parent = c;
          } };
          return b;
        } }, "/proc/self/fd");
      })();
      var Vc = {
        a: (a, b, c, d) => {
          G(`Assertion failed: ${a ? L(u, a) : ""}, at: ` + [b ? b ? L(u, b) : "" : "unknown filename", c, d ? d ? L(u, d) : "" : "unknown function"]);
        },
        h: function(a, b) {
          try {
            return a = a ? L(u, a) : "", ma(a, b), 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name) throw c;
            return -c.Ja;
          }
        },
        H: function(a, b, c) {
          try {
            b = b ? L(u, b) : "";
            b = Ic(a, b);
            if (c & -8) return -28;
            var d = T(b, { Ra: true }).node;
            if (!d) return -44;
            a = "";
            c & 4 && (a += "r");
            c & 2 && (a += "w");
            c & 1 && (a += "x");
            return a && Pb(d, a) ? -2 : 0;
          } catch (e) {
            if ("undefined" == typeof W || "ErrnoError" !== e.name) throw e;
            return -e.Ja;
          }
        },
        i: function(a, b) {
          try {
            var c = U(a);
            ma(c.node, b);
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name) throw d;
            return -d.Ja;
          }
        },
        g: function(a) {
          try {
            var b = U(a).node;
            var c = "string" == typeof b ? T(b, { Ra: true }).node : b;
            if (!c.Fa.Na) throw new P(63);
            c.Fa.Na(c, { timestamp: Date.now() });
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name) throw d;
            return -d.Ja;
          }
        },
        b: function(a, b, c) {
          Kc = c;
          try {
            var d = U(a);
            switch (b) {
              case 0:
                var e = Lc();
                if (0 > e) break;
                for (; Hb[e]; ) e++;
                return Ub(d, e).fd;
              case 1:
              case 2:
                return 0;
              case 3:
                return d.flags;
              case 4:
                return e = Lc(), d.flags |= e, 0;
              case 12:
                return e = Lc(), La[e + 0 >> 1] = 2, 0;
              case 13:
              case 14:
                return 0;
            }
            return -28;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name) throw h;
            return -h.Ja;
          }
        },
        f: function(a, b) {
          try {
            var c = U(a);
            return Jc(Zb, c.path, b);
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name) throw d;
            return -d.Ja;
          }
        },
        n: function(a, b, c) {
          b = Mc(b, c);
          try {
            if (isNaN(b)) return 61;
            var d = U(a);
            if (0 === (d.flags & 2097155)) throw new P(28);
            ac(d.node, b);
            return 0;
          } catch (e) {
            if ("undefined" == typeof W || "ErrnoError" !== e.name) throw e;
            return -e.Ja;
          }
        },
        C: function(a, b) {
          try {
            if (0 === b) return -28;
            var c = ha("/") + 1;
            if (b < c) return -68;
            q("/", u, a, b);
            return c;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name) throw d;
            return -d.Ja;
          }
        },
        F: function(a, b) {
          try {
            return a = a ? L(u, a) : "", Jc($b, a, b);
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name) throw c;
            return -c.Ja;
          }
        },
        z: function(a, b, c) {
          try {
            return b = b ? L(u, b) : "", b = Ic(a, b), b = x(b), "/" === b[b.length - 1] && (b = b.substr(0, b.length - 1)), V(b, c), 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name) throw d;
            return -d.Ja;
          }
        },
        E: function(a, b, c, d) {
          try {
            b = b ? L(u, b) : "";
            var e = d & 256;
            b = Ic(a, b, d & 4096);
            return Jc(e ? $b : Zb, b, c);
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name) throw h;
            return -h.Ja;
          }
        },
        x: function(a, b, c, d) {
          Kc = d;
          try {
            b = b ? L(u, b) : "";
            b = Ic(a, b);
            var e = d ? Lc() : 0;
            return na(b, c, e).fd;
          } catch (h) {
            if ("undefined" == typeof W || "ErrnoError" !== h.name) throw h;
            return -h.Ja;
          }
        },
        v: function(a, b, c, d) {
          try {
            b = b ? L(u, b) : "";
            b = Ic(a, b);
            if (0 >= d) return -28;
            var e = Mb(b), h = Math.min(d, ha(e)), k = p[c + h];
            q(e, u, c, d + 1);
            p[c + h] = k;
            return h;
          } catch (r) {
            if ("undefined" == typeof W || "ErrnoError" !== r.name) throw r;
            return -r.Ja;
          }
        },
        u: function(a) {
          try {
            return a = a ? L(u, a) : "", Yb(a), 0;
          } catch (b) {
            if ("undefined" == typeof W || "ErrnoError" !== b.name) throw b;
            return -b.Ja;
          }
        },
        G: function(a, b) {
          try {
            return a = a ? L(u, a) : "", Jc(Zb, a, b);
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name) throw c;
            return -c.Ja;
          }
        },
        r: function(a, b, c) {
          try {
            return b = b ? L(u, b) : "", b = Ic(a, b), 0 === c ? za(b) : 512 === c ? Yb(b) : G("Invalid flags passed to unlinkat"), 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name) throw d;
            return -d.Ja;
          }
        },
        q: function(a, b, c) {
          try {
            b = b ? L(u, b) : "";
            b = Ic(a, b, true);
            if (c) {
              var d = F[c >> 2] + 4294967296 * D[c + 4 >> 2], e = D[c + 8 >> 2];
              h = 1e3 * d + e / 1e6;
              c += 16;
              d = F[c >> 2] + 4294967296 * D[c + 4 >> 2];
              e = D[c + 8 >> 2];
              k = 1e3 * d + e / 1e6;
            } else var h = Date.now(), k = h;
            a = h;
            var r = T(b, { Ra: true }).node;
            r.Fa.Na(r, { timestamp: Math.max(a, k) });
            return 0;
          } catch (z) {
            if ("undefined" == typeof W || "ErrnoError" !== z.name) throw z;
            return -z.Ja;
          }
        },
        l: function(a, b, c) {
          a = new Date(1e3 * Mc(a, b));
          D[c >> 2] = a.getSeconds();
          D[c + 4 >> 2] = a.getMinutes();
          D[c + 8 >> 2] = a.getHours();
          D[c + 12 >> 2] = a.getDate();
          D[c + 16 >> 2] = a.getMonth();
          D[c + 20 >> 2] = a.getFullYear() - 1900;
          D[c + 24 >> 2] = a.getDay();
          b = a.getFullYear();
          D[c + 28 >> 2] = (0 !== b % 4 || 0 === b % 100 && 0 !== b % 400 ? Oc : Nc)[a.getMonth()] + a.getDate() - 1 | 0;
          D[c + 36 >> 2] = -(60 * a.getTimezoneOffset());
          b = new Date(a.getFullYear(), 6, 1).getTimezoneOffset();
          var d = new Date(a.getFullYear(), 0, 1).getTimezoneOffset();
          D[c + 32 >> 2] = (b != d && a.getTimezoneOffset() == Math.min(d, b)) | 0;
        },
        j: function(a, b, c, d, e, h, k, r) {
          e = Mc(e, h);
          try {
            if (isNaN(e)) return 61;
            var z = U(d);
            if (0 !== (b & 2) && 0 === (c & 2) && 2 !== (z.flags & 2097155)) throw new P(2);
            if (1 === (z.flags & 2097155)) throw new P(2);
            if (!z.Ga.ab) throw new P(43);
            var v = z.Ga.ab(z, a, e, b, c);
            var E = v.Cb;
            D[k >> 2] = v.tb;
            F[r >> 2] = E;
            return 0;
          } catch (H) {
            if ("undefined" == typeof W || "ErrnoError" !== H.name) throw H;
            return -H.Ja;
          }
        },
        k: function(a, b, c, d, e, h, k) {
          h = Mc(h, k);
          try {
            var r = U(e);
            if (c & 2) {
              if (32768 !== (r.node.mode & 61440)) throw new P(43);
              if (!(d & 2)) {
                var z = u.slice(a, a + b);
                r.Ga.bb && r.Ga.bb(r, z, h, b, d);
              }
            }
          } catch (v) {
            if ("undefined" == typeof W || "ErrnoError" !== v.name) throw v;
            return -v.Ja;
          }
        },
        y: (a, b, c, d) => {
          var e = (/* @__PURE__ */ new Date()).getFullYear(), h = new Date(e, 0, 1).getTimezoneOffset();
          e = new Date(e, 6, 1).getTimezoneOffset();
          F[a >> 2] = 60 * Math.max(h, e);
          D[b >> 2] = Number(h != e);
          b = (k) => {
            var r = Math.abs(k);
            return `UTC${0 <= k ? "-" : "+"}${String(Math.floor(r / 60)).padStart(2, "0")}${String(r % 60).padStart(2, "0")}`;
          };
          a = b(h);
          b = b(e);
          e < h ? (q(a, u, c, 17), q(b, u, d, 17)) : (q(a, u, d, 17), q(b, u, c, 17));
        },
        d: () => Date.now(),
        s: () => 2147483648,
        c: () => performance.now(),
        o: (a) => {
          var b = u.length;
          a >>>= 0;
          if (2147483648 < a) return false;
          for (var c = 1; 4 >= c; c *= 2) {
            var d = b * (1 + 0.2 / c);
            d = Math.min(d, a + 100663296);
            var e = Math;
            d = Math.max(a, d);
            a: {
              e = (e.min.call(e, 2147483648, d + (65536 - d % 65536) % 65536) - Ja.buffer.byteLength + 65535) / 65536;
              try {
                Ja.grow(e);
                Oa();
                var h = 1;
                break a;
              } catch (k) {
              }
              h = void 0;
            }
            if (h) return true;
          }
          return false;
        },
        A: (a, b) => {
          var c = 0;
          Rc().forEach((d, e) => {
            var h = b + c;
            e = F[a + 4 * e >> 2] = h;
            for (h = 0; h < d.length; ++h) p[e++] = d.charCodeAt(h);
            p[e] = 0;
            c += d.length + 1;
          });
          return 0;
        },
        B: (a, b) => {
          var c = Rc();
          F[a >> 2] = c.length;
          var d = 0;
          c.forEach((e) => d += e.length + 1);
          F[b >> 2] = d;
          return 0;
        },
        e: function(a) {
          try {
            var b = U(a);
            pa(b);
            return 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name) throw c;
            return c.Ja;
          }
        },
        p: function(a, b) {
          try {
            var c = U(a);
            p[b] = c.tty ? 2 : R(c.mode) ? 3 : 40960 === (c.mode & 61440) ? 7 : 4;
            La[b + 2 >> 1] = 0;
            J = [0, (I = 0, 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
            D[b + 8 >> 2] = J[0];
            D[b + 12 >> 2] = J[1];
            J = [0, (I = 0, 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
            D[b + 16 >> 2] = J[0];
            D[b + 20 >> 2] = J[1];
            return 0;
          } catch (d) {
            if ("undefined" == typeof W || "ErrnoError" !== d.name) throw d;
            return d.Ja;
          }
        },
        w: function(a, b, c, d) {
          try {
            a: {
              var e = U(a);
              a = b;
              for (var h, k = b = 0; k < c; k++) {
                var r = F[a >> 2], z = F[a + 4 >> 2];
                a += 8;
                var v = dc(e, p, r, z, h);
                if (0 > v) {
                  var E = -1;
                  break a;
                }
                b += v;
                if (v < z) break;
                "undefined" != typeof h && (h += v);
              }
              E = b;
            }
            F[d >> 2] = E;
            return 0;
          } catch (H) {
            if ("undefined" == typeof W || "ErrnoError" !== H.name) throw H;
            return H.Ja;
          }
        },
        m: function(a, b, c, d, e) {
          b = Mc(b, c);
          try {
            if (isNaN(b)) return 61;
            var h = U(a);
            cc(h, b, d);
            J = [h.position >>> 0, (I = h.position, 1 <= +Math.abs(I) ? 0 < I ? +Math.floor(I / 4294967296) >>> 0 : ~~+Math.ceil((I - +(~~I >>> 0)) / 4294967296) >>> 0 : 0)];
            D[e >> 2] = J[0];
            D[e + 4 >> 2] = J[1];
            h.gb && 0 === b && 0 === d && (h.gb = null);
            return 0;
          } catch (k) {
            if ("undefined" == typeof W || "ErrnoError" !== k.name) throw k;
            return k.Ja;
          }
        },
        D: function(a) {
          var _a;
          try {
            var b = U(a);
            return ((_a = b.Ga) == null ? void 0 : _a.fsync) ? b.Ga.fsync(b) : 0;
          } catch (c) {
            if ("undefined" == typeof W || "ErrnoError" !== c.name) throw c;
            return c.Ja;
          }
        },
        t: function(a, b, c, d) {
          try {
            a: {
              var e = U(a);
              a = b;
              for (var h, k = b = 0; k < c; k++) {
                var r = F[a >> 2], z = F[a + 4 >> 2];
                a += 8;
                var v = oa(e, p, r, z, h);
                if (0 > v) {
                  var E = -1;
                  break a;
                }
                b += v;
                "undefined" != typeof h && (h += v);
              }
              E = b;
            }
            F[d >> 2] = E;
            return 0;
          } catch (H) {
            if ("undefined" == typeof W || "ErrnoError" !== H.name) throw H;
            return H.Ja;
          }
        }
      }, Z = function() {
        var _a;
        function a(c) {
          var _a2;
          Z = c.exports;
          Ja = Z.I;
          Oa();
          X = Z.K;
          Qa.unshift(Z.J);
          Ua--;
          (_a2 = f.monitorRunDependencies) == null ? void 0 : _a2.call(f, Ua);
          0 == Ua && (Wa && (c = Wa, Wa = null, c()));
          return Z;
        }
        var b = { a: Vc };
        Ua++;
        (_a = f.monitorRunDependencies) == null ? void 0 : _a.call(f, Ua);
        if (f.instantiateWasm) try {
          return f.instantiateWasm(b, a);
        } catch (c) {
          return C(`Module.instantiateWasm callback failed with error: ${c}`), false;
        }
        Ya || (Ya = Xa("sql-wasm.wasm") ? "sql-wasm.wasm" : f.locateFile ? f.locateFile(
          "sql-wasm.wasm",
          B
        ) : B + "sql-wasm.wasm");
        bb(b, function(c) {
          a(c.instance);
        });
        return {};
      }();
      f._sqlite3_free = (a) => (f._sqlite3_free = Z.L)(a);
      f._sqlite3_value_text = (a) => (f._sqlite3_value_text = Z.M)(a);
      f._sqlite3_prepare_v2 = (a, b, c, d, e) => (f._sqlite3_prepare_v2 = Z.N)(a, b, c, d, e);
      f._sqlite3_step = (a) => (f._sqlite3_step = Z.O)(a);
      f._sqlite3_reset = (a) => (f._sqlite3_reset = Z.P)(a);
      f._sqlite3_exec = (a, b, c, d, e) => (f._sqlite3_exec = Z.Q)(a, b, c, d, e);
      f._sqlite3_finalize = (a) => (f._sqlite3_finalize = Z.R)(a);
      f._sqlite3_column_name = (a, b) => (f._sqlite3_column_name = Z.S)(a, b);
      f._sqlite3_column_text = (a, b) => (f._sqlite3_column_text = Z.T)(a, b);
      f._sqlite3_column_type = (a, b) => (f._sqlite3_column_type = Z.U)(a, b);
      f._sqlite3_errmsg = (a) => (f._sqlite3_errmsg = Z.V)(a);
      f._sqlite3_clear_bindings = (a) => (f._sqlite3_clear_bindings = Z.W)(a);
      f._sqlite3_value_blob = (a) => (f._sqlite3_value_blob = Z.X)(a);
      f._sqlite3_value_bytes = (a) => (f._sqlite3_value_bytes = Z.Y)(a);
      f._sqlite3_value_double = (a) => (f._sqlite3_value_double = Z.Z)(a);
      f._sqlite3_value_int = (a) => (f._sqlite3_value_int = Z._)(a);
      f._sqlite3_value_type = (a) => (f._sqlite3_value_type = Z.$)(a);
      f._sqlite3_result_blob = (a, b, c, d) => (f._sqlite3_result_blob = Z.aa)(a, b, c, d);
      f._sqlite3_result_double = (a, b) => (f._sqlite3_result_double = Z.ba)(a, b);
      f._sqlite3_result_error = (a, b, c) => (f._sqlite3_result_error = Z.ca)(a, b, c);
      f._sqlite3_result_int = (a, b) => (f._sqlite3_result_int = Z.da)(a, b);
      f._sqlite3_result_int64 = (a, b, c) => (f._sqlite3_result_int64 = Z.ea)(a, b, c);
      f._sqlite3_result_null = (a) => (f._sqlite3_result_null = Z.fa)(a);
      f._sqlite3_result_text = (a, b, c, d) => (f._sqlite3_result_text = Z.ga)(a, b, c, d);
      f._sqlite3_aggregate_context = (a, b) => (f._sqlite3_aggregate_context = Z.ha)(a, b);
      f._sqlite3_column_count = (a) => (f._sqlite3_column_count = Z.ia)(a);
      f._sqlite3_data_count = (a) => (f._sqlite3_data_count = Z.ja)(a);
      f._sqlite3_column_blob = (a, b) => (f._sqlite3_column_blob = Z.ka)(a, b);
      f._sqlite3_column_bytes = (a, b) => (f._sqlite3_column_bytes = Z.la)(a, b);
      f._sqlite3_column_double = (a, b) => (f._sqlite3_column_double = Z.ma)(a, b);
      f._sqlite3_bind_blob = (a, b, c, d, e) => (f._sqlite3_bind_blob = Z.na)(a, b, c, d, e);
      f._sqlite3_bind_double = (a, b, c) => (f._sqlite3_bind_double = Z.oa)(a, b, c);
      f._sqlite3_bind_int = (a, b, c) => (f._sqlite3_bind_int = Z.pa)(a, b, c);
      f._sqlite3_bind_text = (a, b, c, d, e) => (f._sqlite3_bind_text = Z.qa)(a, b, c, d, e);
      f._sqlite3_bind_parameter_index = (a, b) => (f._sqlite3_bind_parameter_index = Z.ra)(a, b);
      f._sqlite3_sql = (a) => (f._sqlite3_sql = Z.sa)(a);
      f._sqlite3_normalized_sql = (a) => (f._sqlite3_normalized_sql = Z.ta)(a);
      f._sqlite3_changes = (a) => (f._sqlite3_changes = Z.ua)(a);
      f._sqlite3_close_v2 = (a) => (f._sqlite3_close_v2 = Z.va)(a);
      f._sqlite3_create_function_v2 = (a, b, c, d, e, h, k, r, z) => (f._sqlite3_create_function_v2 = Z.wa)(a, b, c, d, e, h, k, r, z);
      f._sqlite3_open = (a, b) => (f._sqlite3_open = Z.xa)(a, b);
      var ia = f._malloc = (a) => (ia = f._malloc = Z.ya)(a), fa = f._free = (a) => (fa = f._free = Z.za)(a);
      f._RegisterExtensionFunctions = (a) => (f._RegisterExtensionFunctions = Z.Aa)(a);
      var Eb = (a, b) => (Eb = Z.Ba)(a, b), ua2 = (a) => (ua2 = Z.Ca)(a), y = (a) => (y = Z.Da)(a), ra = () => (ra = Z.Ea)();
      f.stackSave = () => ra();
      f.stackRestore = (a) => ua2(a);
      f.stackAlloc = (a) => y(a);
      f.cwrap = (a, b, c, d) => {
        var e = !c || c.every((h) => "number" === h || "boolean" === h);
        return "string" !== b && e && !d ? f["_" + a] : (...h) => Sc(a, b, c, h);
      };
      f.addFunction = Aa;
      f.removeFunction = wa;
      f.UTF8ToString = ta;
      f.ALLOC_NORMAL = ea;
      f.allocate = da;
      f.allocateUTF8OnStack = va;
      var Wc;
      Wa = function Xc() {
        Wc || Yc();
        Wc || (Wa = Xc);
      };
      function Yc() {
        function a() {
          var _a;
          if (!Wc && (Wc = true, f.calledRun = true, !Ka)) {
            f.noFSInit || ec || (ec = true, f.stdin = f.stdin, f.stdout = f.stdout, f.stderr = f.stderr, f.stdin ? Fc("stdin", f.stdin) : Xb("/dev/tty", "/dev/stdin"), f.stdout ? Fc("stdout", null, f.stdout) : Xb("/dev/tty", "/dev/stdout"), f.stderr ? Fc("stderr", null, f.stderr) : Xb("/dev/tty1", "/dev/stderr"), na("/dev/stdin", 0), na("/dev/stdout", 1), na("/dev/stderr", 1));
            Jb = false;
            cb(Qa);
            (_a = f.onRuntimeInitialized) == null ? void 0 : _a.call(f);
            if (f.postRun) for ("function" == typeof f.postRun && (f.postRun = [f.postRun]); f.postRun.length; ) {
              var b = f.postRun.shift();
              Sa.unshift(b);
            }
            cb(Sa);
          }
        }
        if (!(0 < Ua)) {
          if (f.preRun) for ("function" == typeof f.preRun && (f.preRun = [f.preRun]); f.preRun.length; ) Ta();
          cb(Pa);
          0 < Ua || (f.setStatus ? (f.setStatus("Running..."), setTimeout(function() {
            setTimeout(function() {
              f.setStatus("");
            }, 1);
            a();
          }, 1)) : a());
        }
      }
      if (f.preInit) for ("function" == typeof f.preInit && (f.preInit = [f.preInit]); 0 < f.preInit.length; ) f.preInit.pop()();
      Yc();
      return Module;
    });
    return initSqlJsPromise;
  };
  {
    module.exports = initSqlJs;
    module.exports.default = initSqlJs;
  }
})(sqlWasm);
var sqlWasmExports = sqlWasm.exports;
const init_sql = /* @__PURE__ */ getDefaultExportFromCjs(sqlWasmExports);
function base64_to_bytes$1(base64) {
  const binary_string = atob(base64);
  return Uint8Array.from(binary_string, function(m) {
    return m.codePointAt(0);
  });
}
function bytes_to_base64(bytes) {
  const binary_string = Array.from(bytes, function(byte) {
    return String.fromCodePoint(byte);
  }).join("");
  return btoa(binary_string);
}
const utils = Object.freeze({
  base64_to_bytes: base64_to_bytes$1,
  bytes_to_base64
});
const { base64_to_bytes } = utils;
function load_wasm(base64_wasm) {
  const wasm_codearray = base64_to_bytes(base64_wasm);
  const url = URL.createObjectURL(
    new Blob([wasm_codearray], { type: "application/wasm" })
  );
  return function load2(callback) {
    init_sql({
      locateFile: () => url
    }).then(function(SQL) {
      return callback(SQL);
    }).catch(function(err) {
      return callback(void 0, err);
    });
  };
}
const load_wasm$1 = Object.freeze(load_wasm);
function make_reason(factory_name, excuse, evidence) {
  const reason = new Error("parseq." + factory_name + (excuse === void 0 ? "" : ": " + excuse));
  reason.evidence = evidence;
  return reason;
}
function get_array_length(array, factory_name) {
  if (Array.isArray(array)) {
    return array.length;
  }
  if (array === void 0) {
    return 0;
  }
  throw make_reason(factory_name, "Not an array.", array);
}
function check_callback(callback, factory_name) {
  if (typeof callback !== "function" || callback.length !== 2) {
    throw make_reason(factory_name, "Not a callback function.", callback);
  }
}
function check_requestors(requestor_array, factory_name) {
  if (requestor_array.some(function(requestor) {
    return typeof requestor !== "function" || requestor.length < 1 || requestor.length > 2;
  })) {
    throw make_reason(
      factory_name,
      "Bad requestors array.",
      requestor_array
    );
  }
}
function run(factory_name, requestor_array, initial_value, action, timeout, time_limit, throttle = 0) {
  let cancel_array = new Array(requestor_array.length);
  let next_number = 0;
  let timer_id;
  function cancel(reason = make_reason(factory_name, "Cancel.")) {
    if (timer_id !== void 0) {
      clearTimeout(timer_id);
      timer_id = void 0;
    }
    if (cancel_array !== void 0) {
      cancel_array.forEach(function(cancel2) {
        try {
          if (typeof cancel2 === "function") {
            return cancel2(reason);
          }
        } catch (ignore) {
        }
      });
      cancel_array = void 0;
    }
  }
  function start_requestor(value) {
    if (cancel_array !== void 0 && next_number < requestor_array.length) {
      let number = next_number;
      next_number += 1;
      const requestor = requestor_array[number];
      try {
        cancel_array[number] = requestor(
          function start_requestor_callback(value2, reason) {
            if (cancel_array !== void 0 && number !== void 0) {
              cancel_array[number] = void 0;
              action(value2, reason, number);
              number = void 0;
              setTimeout(start_requestor, 0, factory_name === "sequence" ? value2 : initial_value);
            }
          },
          value
        );
      } catch (exception) {
        action(void 0, exception, number);
        number = void 0;
        start_requestor(value);
      }
    }
  }
  if (time_limit !== void 0) {
    if (typeof time_limit === "number" && time_limit >= 0) {
      if (time_limit > 0) {
        timer_id = setTimeout(timeout, time_limit);
      }
    } else {
      throw make_reason(factory_name, "Bad time limit.", time_limit);
    }
  }
  if (!Number.isSafeInteger(throttle) || throttle < 0) {
    throw make_reason(factory_name, "Bad throttle.", throttle);
  }
  let repeat = Math.min(throttle || Infinity, requestor_array.length);
  while (repeat > 0) {
    setTimeout(start_requestor, 0, initial_value);
    repeat -= 1;
  }
  return cancel;
}
function parallel(required_array, optional_array, time_limit, time_option, throttle, factory_name = "parallel") {
  let requestor_array;
  let number_of_required = get_array_length(required_array, factory_name);
  if (number_of_required === 0) {
    if (get_array_length(optional_array, factory_name) === 0) {
      requestor_array = [];
    } else {
      requestor_array = optional_array;
      time_option = true;
    }
  } else {
    if (get_array_length(optional_array, factory_name) === 0) {
      requestor_array = required_array;
      time_option = void 0;
    } else {
      requestor_array = required_array.concat(optional_array);
      if (time_option !== void 0 && typeof time_option !== "boolean") {
        throw make_reason(
          factory_name,
          "Bad time_option.",
          time_option
        );
      }
    }
  }
  check_requestors(requestor_array, factory_name);
  return function parallel_requestor(callback, initial_value) {
    check_callback(callback, factory_name);
    let number_of_pending = requestor_array.length;
    let number_of_pending_required = number_of_required;
    let results = [];
    if (number_of_pending === 0) {
      callback(
        factory_name === "sequence" ? initial_value : results
      );
      return;
    }
    let cancel = run(
      factory_name,
      requestor_array,
      initial_value,
      function parallel_action(value, reason, number) {
        results[number] = value;
        number_of_pending -= 1;
        if (number < number_of_required) {
          number_of_pending_required -= 1;
          if (value === void 0) {
            cancel(reason);
            callback(void 0, reason);
            callback = void 0;
            return;
          }
        }
        if (number_of_pending < 1 || time_option === void 0 && number_of_pending_required < 1) {
          cancel(make_reason(factory_name, "Optional."));
          callback(
            factory_name === "sequence" ? results.pop() : results
          );
          callback = void 0;
        }
      },
      function parallel_timeout() {
        const reason = make_reason(
          factory_name,
          "Timeout.",
          time_limit
        );
        if (time_option === false) {
          time_option = void 0;
          if (number_of_pending_required < 1) {
            cancel(reason);
            callback(results);
          }
        } else {
          cancel(reason);
          if (number_of_pending_required < 1) {
            callback(results);
          } else {
            callback(void 0, reason);
          }
          callback = void 0;
        }
      },
      time_limit,
      throttle
    );
    return cancel;
  };
}
function parallel_object(required_object, optional_object, time_limit, time_option, throttle) {
  const names2 = [];
  let required_array = [];
  let optional_array = [];
  if (required_object) {
    if (typeof required_object !== "object") {
      throw make_reason(
        "parallel_object",
        "Type mismatch.",
        required_object
      );
    }
    Object.keys(required_object).forEach(function(name) {
      let requestor = required_object[name];
      if (typeof requestor === "function" && (requestor.length === 1 || requestor.length === 2)) {
        names2.push(name);
        required_array.push(requestor);
      }
    });
  }
  if (optional_object) {
    if (typeof optional_object !== "object") {
      throw make_reason(
        "parallel_object",
        "Type mismatch.",
        optional_object
      );
    }
    Object.keys(optional_object).forEach(function(name) {
      let requestor = optional_object[name];
      if (typeof requestor === "function" && (requestor.length === 1 || requestor.length === 2)) {
        if (required_object && required_object[name] !== void 0) {
          throw make_reason(
            "parallel_object",
            "Duplicate name.",
            name
          );
        }
        names2.push(name);
        optional_array.push(requestor);
      }
    });
  }
  const parallel_requestor = parallel(
    required_array,
    optional_array,
    time_limit,
    time_option,
    throttle,
    "parallel_object"
  );
  return function parallel_object_requestor(callback, initial_value) {
    return parallel_requestor(
      // We pass our callback to the parallel requestor,
      // converting its value into an object.
      function parallel_object_callback(value, reason) {
        if (value === void 0) {
          return callback(void 0, reason);
        }
        const object = /* @__PURE__ */ Object.create(null);
        names2.forEach(function(name, index) {
          object[name] = value[index];
        });
        return callback(object);
      },
      initial_value
    );
  };
}
function race(requestor_array, time_limit, throttle) {
  const factory_name = throttle === 1 ? "fallback" : "race";
  if (get_array_length(requestor_array, factory_name) === 0) {
    throw make_reason(factory_name, "No requestors.");
  }
  check_requestors(requestor_array, factory_name);
  return function race_requestor(callback, initial_value) {
    check_callback(callback, factory_name);
    let number_of_pending = requestor_array.length;
    let cancel = run(
      factory_name,
      requestor_array,
      initial_value,
      function race_action(value, reason, number) {
        number_of_pending -= 1;
        if (value !== void 0) {
          cancel(make_reason(factory_name, "Loser.", number));
          callback(value);
          callback = void 0;
        } else if (number_of_pending < 1) {
          cancel(reason);
          callback(void 0, reason);
          callback = void 0;
        }
      },
      function race_timeout() {
        let reason = make_reason(
          factory_name,
          "Timeout.",
          time_limit
        );
        cancel(reason);
        callback(void 0, reason);
        callback = void 0;
      },
      time_limit,
      throttle
    );
    return cancel;
  };
}
function fallback(requestor_array, time_limit) {
  return race(requestor_array, time_limit, 1);
}
function sequence(requestor_array, time_limit) {
  return parallel(
    requestor_array,
    void 0,
    time_limit,
    void 0,
    1,
    "sequence"
  );
}
const parseq = Object.freeze({
  fallback,
  parallel,
  parallel_object,
  race,
  sequence
});
function init() {
  const wasm_root = document.querySelector(
    '[data-app="wasm_sql"]'
  );
  const wasm_map = JSON.parse(wasm_root.innerHTML.trim());
  return parseq.parallel([
    load_wasm$1(wasm_map.sql)
  ])(function([SQL], error) {
    if (error) {
      throw error;
    }
    const db = {
      sql: function(data) {
        return new SQL.Database(data);
      }
    };
    app_ui$1({
      db
    }).mount("#root");
  });
}
init();
</script>
                <script type="application/json" data-app="wasm_sql">{"sql":"AGFzbQEAAAABoARFYAJ/fwF/YAF/AX9gA39/fwBgA39/fwF/YAF/AGACf38AYAR/f39/AX9gBX9/f39/AX9gBH9/f38AYAR/f39+AX9gBn9/f39/fwF/YAAAYAJ/fgF/YAV/f39/fwBgBn9/f39/fwBgB39/f39/f38Bf2AAAX9gAXwBfGABfgF/YAJ/fgBgAX8BfmADf39+AX9gAn9/AX5gCH9/f39/f39/AX9gBH9+f38Bf2ACf3wAYAl/f39/f39/f38Bf2ADf35/AX9gB39/f39/f38AYAl/f39/f39/f38AYAV/f39/fgBgBX9/fn9/AX9gA39/fgBgA39+fwBgA39+fgF/YAABfGABfwF8YAR/fn5/AGAIf39/f39/f38AYAR/f35/AGALf39/f39/f39/f38AYAN8fH8BfGACfHwBfGAEfn5+fgF/YAF+AX5gBn9/f35/fwF/YAJ/fgF+YAZ/f39/f34Bf2ADf3x8AGAFf35+fn4AYAh/fn5/f39/fwF/YAJ+fAF/YAJ8fwF8YAF8AX9gC39/f39/f39/f39/AX9gAnx/AX9gB39/f39+f38BfmAJf35/fn5+fn9/AX9gBH9/f34AYAV/fn9/fwF/YAp/f39/f39/f39/AX9gAnx+AX9gA39/fAF/YAd/f39/f3x8AGAFf35+fn8Bf2AIf39+fn5/f38Bf2AEf35/fwBgDX9/f39/f39/f39/f38AYAJ/fwF8As0BIgFhAWEACAFhAWIAAwFhAWMAIwFhAWQAIwFhAWUAAQFhAWYAAAFhAWcAAwFhAWgAAAFhAWkAAAFhAWoAFwFhAWsADwFhAWwAAgFhAW0ABwFhAW4AAwFhAW8AAQFhAXAAAAFhAXEABgFhAXIAAwFhAXMAEAFhAXQABgFhAXUAAQFhAXYABgFhAXcABgFhAXgABgFhAXkACAFhAXoAAwFhAUEAAAFhAUIAAAFhAUMAAAFhAUQAAQFhAUUABgFhAUYAAAFhAUcAAAFhAUgABgPFDsMOBgQHAwIDAQUDAQABAQUFDwoFBgMUAgMMAQUIBQIBEgEBAQMBAAAVJAQAAgMEAAEGAAwGAwAEGQAEAQUEBwATAwISBgYABQgABQECAQwAAwMAAQYABQEIAgMABBMFAAIMAAADAwIDAAMCBQEBAgAEAwEWAAMEAgQBAAIVAQAfAwQCBQAM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kgEBUwCiBQFUAIMCAVUA9gIBVgDKAgFXALcMAVgAnQEBWQBDAVoArwwBXwDlBAEkAFACYWEA2QECYmEAWAJjYQBMAmRhAHYCZWEAsAwCZmEAVwJnYQA8AmhhAEcCaWEArQwCamEArAwCa2EA/AECbGEAvwECbWEAqwwCbmEAvAICb2EAowkCcGEAlQECcWEAogkCcmEAqgwCc2EAqQwCdGEAqAwCdWEApgwCdmEApQwCd2EAhQkCeGEAoQwCeWEA6wECemEA6gECQWEA+gwCQmEAwQkCQ2EAxgwCRGEAxQwCRWEAxAwJvQcBAEEBC94DI64M3wufCIEH9wv2C+IE5gKTCcULxAvDC6MMgAmgDJ8MogynDPgL6giJBOcL5gvlC+QL4wviC+EL2wvcC9AD3gvdC9cL1gvVC+MO3w7eDuEOpAzkDju2C5gDwgvBC8ALvwu+Cym9C7wLuwu6C2e5C7gLtwvTDuIOlgvUDpgD2A7XDtYO0A7PDuAO0g7RDniIC90OyQ7IDjDzAdwO2w7aDtkO1Q7ODs0Oyw7MDsoOxA6PDo4OjA6LDocOrgrJDcgN5QbkBrkNuA22DbUNtw2WCrANigrNAZkNjw2XDZQNkw2SDZENkA2ODeAL2gvZC9gL1AvSC8oLyQvyB8gLxwvGC54MhQyEDJ0MnAybDJoMmQyYDJcM+AiWDJUMlAyTDJIMkQziBJAMjwyODI0MwgzDDLwMswy+DL0Mvwy2DLEMwQyyDIwMugy0DMAMxwy5DLgMiwy1DLsMigyYA5gDiQyIDIcM7giGDIMMggyBDIAMmAP/C/4L/Qv8C/sL+gv5C/UL9AvzC/IL8QvwC+8L7gvtC+wL6wvaCOoL6QuTBpgD6AvTC9EL3AXQC88Lzgv0B80LzAvLC8cOxg7FDsMOwg7BDsAOvw6+Dr0OvA67DroOuQ64DrcOtg61DrQOsw6yDrEOsA6vDq4OrQ6sDqsOqg6pDqgOpw6mDqUOpA6jDqIOoQ6gDp8Ong6dDpwOmw6aDpkOmA6XDpYOlQ6UDpMOkg6RDpAOjQ6KDokOiA6GDoUOhA6DDoIOgQ7ACoAOvgrACv8Nvgr+Df0N/A37DfoN+Q34DfcN9g3iBPUN9A3zDfINvQq8CroK8Q3wDe8N7g3tDewN6w3qDekN6A3nDeYN5Q3kDeMN4g3hDeAN3w3eDd0N3A3bDdoN2Q3YDdcN1g3VDaoK4gTUDdMN0g3RDdANzw3ODc0NzA2oCssNyg3HDcYNrw2uDa0N2gasDasNqg2pDfwJqA2nDaYNpQ2kDaMNqgqiDaENoA2fDZ4NnQ2cDZsNxQ2fCsQN4gbDDcINwQ3ADb8Nvg29DZsKvA27DboNtA3cBYsK4gazDbIN3AWLCuIGsQ2aDZgNlg2VDY0NjA2LDYoNiQ2IDcwJhw2GDYUNhA2DDYINywmBDYAN/wz+DP0M/Az7DM8MzgzMDMgM+Qz4DPcM9gz1DPQM8wzyDPEM8AzvDO4M7QzsDOsM6gzpDOgM5wzmDOUM5AzjDOIM4QzgDN8M3gzdDNwM2wzaDNkM2AzXDNYM1QzUDNMM0gzRDNAMzQzLDMoMyQwKs7Yjww4OACAAIAEgAiADQQAQJAtPAQF/IAAEQEGAgwQoAgAEQCAAQayDBCgCABEBACEBQYC5BEGAuQQoAgAgAWs2AgBBpLkEQaS5BCgCAEEBazYCAAsgAEGkgwQoAgARBAALC3QBAX8gACgCbCIFIAAoAnBOBEAgABCWCQR/QQEFIAAgASACIAMgBBAkCw8LIAAgBUEBajYCbCAAKAJoIAVBFGxqIgBBADYCECAAIAQ2AgwgACADNgIIIAAgAjYCBCAAQQA7AQIgACABOgAAIABBADoAASAFCzMBAX8gAgRAIAAhAwNAIAMgAS0AADoAACADQQFqIQMgAUEBaiEBIAJBAWsiAg0ACwsgAAufAQECfyMAQRBrIgQkACAAKAIAIgNBfjYCRCAEIAI2AgwgAyABIAIQ8gIhASADKAJEQX5MBEAgA0F/NgJECwJAIAMtAFsEQCADIAEQKSADLQBXRQ0BIABBBzYCDCAAIAAoAiRBAWo2AiQMAQsgACAAKAIkQQFqNgIkIAMgACgCBBApIABBADYClAIgAEEBNgIMIAAgATYCBAsgBEEQaiQACykBAX8gAgRAIAAhAwNAIAMgAToAACADQQFqIQMgAkEBayICDQALCyAACw8AQQsgAEH1zwAQ5ARBCwsNACABBEAgACABEC8LCw4AIAAgASACQQBBABAkCwkAIABBARDmBAtUAQJ/A0ACQAJAIAAtAAAiAiABLQAAIgNGBEAgAg0BQQAhAgwCCyACQbDwAWotAAAgA0Gw8AFqLQAAayICDQELIAFBAWohASAAQQFqIQAMAQsLIAILFgAgAEUEQEEADwsgABA/Qf////8DcQsoACAAKAAAIgBBGHQgAEGA/gNxQQh0ciAAQQh2QYD+A3EgAEEYdnJyC2wAAkAgAEUNAAJAIAAoAuQCIAFNDQAgASAAKALcAk8EQCABIAAoAtgCNgIAIAAgATYC2AIPCyAAKALgAiABSw0AIAEgACgC0AI2AgAgACABNgLQAg8LIAAoApAERQ0AIAAgARD5CA8LIAEQIwsOACABBEAgACABENUBCwsbACAAIAAgASACIAMgBBAkIgAgBSAGEMgBIAALlAEBAX8gACgCbCIGIAAoAnBOBEAgACABIAIgAyAEECQhASAAKAIALQBXRQRAIAAoAmggAUEUbGoiACAFNgIQIABB/QE6AAELIAEPCyAAIAZBAWo2AmwgACgCaCAGQRRsaiIAIAU2AhAgACAENgIMIAAgAzYCCCAAIAI2AgQgAEEAOwECIAAgAToAACAAQf0BOgABIAYLsQEBBH8gAUF/cyECIAAoAgwiASgCOCABKAI8akEASARAIAAhBCABIgAgACgCACAAKAJAQQogACgCOCIFayIDQQJ0rRDSAyIBNgJAAkAgAUUEQCAAQQA2AjwMAQsCQCAFQaZ/Sg0AIAAoAjxB5ABtIANB5ABuTg0AIAAQoQUgACgCQCEBCyAAIAM2AjwgASACQQJ0aiAEKAJsNgIACw8LIAEoAkAgAkECdGogACgCbDYCAAtaAQF/IAAoAgBCNBBTIgQEQCAEQQBBNBAnIgRB//8DOwEiIAQgAToAACAAKAIAIAQgAiADENsHIAAgBCgCGBCpBBogBA8LIAAoAgAgAhAwIAAoAgAgAxAwIAQLFgAgAUUEQEEADwsgACABIAJBABCYBwvJAQMBfwF+AXwgAC8BECIBQSRxBEAgACkDAA8LAkAgAUEIcQRAQoCAgICAgICAgH8hAiAAKwMAIgNE////////38NjDQFC////////////ACECIANE////////30NkDQEgA5lEAAAAAAAA4ENjBEAgA7APC0KAgICAgICAgIB/DwsgAUEScUUNACAAKAIIRQ0AIwBBEGsiASQAIAFCADcDCCAAKAIIIAFBCGogACgCDCAALQASELoCGiABKQMIIQIgAUEQaiQACyACCyQBAX8jAEEQayIDJAAgAyACNgIMIAAgASACEOICIANBEGok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BSAFQfAAakQwBY7kLv8rK0TERh14aCq0pxDXASAEQeQAaiEEDAELAAsACyAFKwNwIAUrA3igIhEgEUQAAAAAAADwfyARvSINQv////////8Hg1AbIA1CgICAgICAgPj/AINCgICAgICAgPj/AFIbDAILA0AgBEGcf0oEQANAIARBdkoEQANAIARBAE4NBSAFQdAAaiAOIA1CmrPmzJmz5syZf0KZs+bMmbPm/T8Q2wEgBEEBaiEEIAUpA1ghDSAFKQNQIQ4MAAsABSAFQUBrIA4gDUKR6vLA6Nzavqt/Qtv39ezf+e3uPxDbASAEQQpqIQQgBSkDSCENIAUpA0AhDgwBCwALAAUgBUEwaiAOIA1C+c7c4o/erL19QtLAo/Ku/q/ZPhDbASAEQeQAaiEEIAUpAzghDSAFKQMwIQ4MAQsACwALIA4gDULq/vn//////29C////////v//DABD2AyEIIwBBIGsiASQAIA1C////////P4MhDwJ+IA1CMIhC//8BgyIQpyIDQYH4AGtB/Q9NBEAgD0IEhiAOQjyIhCEPIANBgPgAa60hEAJAIA5C//////////8PgyIOQoGAgICAgICACFoEQCAPQgF8IQ8MAQsgDkKAgICAgICAgAhSDQAgD0IBgyAPfCEPC0IAIA8gD0L/////////B1YiAxshDiADrSAQfAwBCyAOIA+EUCAQQv//AVJyRQRAIA9CBIYgDkI8iIRCgICAgICAgASEIQ5C/w8MAQsgA0H+hwFLBEBCACEOQv8PDAELQYD4AEGB+AAgEFAiCRsiDCADayIEQfAASgRAQgAhDkIADAELIAFBEGogDiAPIA9CgICAgICAwACEIAkbIg9BgAEgBGsQygEgASAOIA8gBBCkAyABKQMIQgSGIAEpAwAiD0I8iIQhDgJAIAMgDEcgASkDECABKQMYhEIAUnGtIA9C//////////8Pg4QiD0KBgICAgICAgAhaBEAgDkIBfCEODAELIA9CgICAgICAgIAIUg0AIA5CAYMgDnwhDgsgDkKAgICAgICACIUgDiAOQv////////8HViIDGyEOIAOtCyEPIAFBIGokAEQAAAAAAADwfyANQoCAgICAgICAgH+DIA9CNIaEIA6EvyAIQQBKGwsiETkDACALQS1HDQEgEZoLOQMACyAGRSAAIAJHciAKQQBMIAdB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ADYCAAtBASEBIAMgCSAKIAggAhEGACAGKAIIIQVFDQAgBRCfAhogBkEANgIIQQQhByAAQQQQiwEMBgsgB0HkAEYNAQsLIAUQnwIhByAGQQA2AgggBigCDCEFA0AgBSIBQQFqIQUgAS0AAEGw8wFqLQAAQQFxDQALIAAgCBApDAELC0EAIQEgBigCCCEFCyAFBEAgBRCfAhoLIAEhCAsgACAIECkgBEUgACAHEJ4BIgFFckUEQCAEQQAgABDKAhBZIgI2AgAgAg0BQQchASAAQQcQiwEMAQsgBEUNACAEQQA2AgALIAZBEGokACABCwsAIABBAUEAEKoEC4sBAQF/AkAgAS0ABkGBAXENAAJAIAEoAgwiAkUNACABLQAAQbIBRg0AIAAgAhDVAQsgASgCECICBEAgACACENUBDAELIAEoAhQhAiABLQAFQRBxBEAgACACEGcMAQsgACACEDsgAS0AB0EBcUUNACAAIAEoAiwQvAQLIAEtAAdBCHFFBEAgACABEFwLCw8AQQ4gAEHp7QAQ5ARBDgvWAQIBfwJ8IwBBMGsiAyAAKwMAIAApAABCgICAYIO/IgShOQMoIAMgASABvUKAgIBgg78iBaE5AyAgAyAFIASiOQMYIAMgBCADKwMgoiADKwMoIAWioDkDECADIAMrAxggAysDEKA5AwggAyADKwMoIAMrAyCiIAMrAxAgAysDGCADKwMIoaCgOQMAIAMgAysDACAAKwMAIAKiIAArAwggAaKgoDkDACAAIAMrAwggAysDAKA5AwAgACADKwMIIAArAwChOQMIIAAgAysDACAAKwMIoDkDCAtIAQF/IABBASABdCICIAAoApwBcjYCnAECQCABQQFGDQAgACgCACgCECABQQR0aigCBC0ACUUNACAAIAAoAqABIAJyNgKgAQsLDwAgACABIAJBACADEO0DC3IBAn8CQCAAKAIAIAAoAgxqIgJBAEwEQEEBIQIgAC0AEEEQcUUNAQtBByEBIAAgAkEBEPsCDQBBACEBIAAoAgggACgCDGpBACAAKAIAECcaIAAgACgCDCAAKAIAajYCDCAAIAAvARBB//MDcTsBEAsgAQu/CgIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgC4RCACEBUARAQoCAgICAgOD//wAhCgwDCyAKQoCAgICAgMD//wCEIQoMAgsgASALhFAEQEIAIQEMAgsgAiADhFAEQEIAIQEMAgsgC0L///////8/WARAIAVB0ABqIAEgDSABIA0gDVAiBht5IAZBBnStfKciBkEPaxDKAUEQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQygEgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiISIANCMYiEQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiANfnwiAiADVK1CIIYgAkIgiIR8IAQgAkIghnwiAiAEVK18IAIgAiAQIBJWrSAOIBZUrSAOIBBWrXx8QiCGIBJCIIiEfCICVq18IAIgAiAPIBRUrSAPIBdWrXx8IgJWrXwiBEKAgICAgIDAAINQRQRAIAZBAWohBgwBCyALQj+IIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgC0IBhiELIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQf8ATQRAIAVBMGogCyABIAZB/wBqIgYQygEgBUEgaiACIAQgBhDKASAFQRBqIAsgASAHEKQDIAUgAiAEIAcQpAMgBSkDMCAFKQM4hEIAUq0gBSkDICAFKQMQhIQhCyAFKQMoIAUpAxiEIQEgBSkDACECIAUpAwgMAgtCACEBDAILIARC////////P4MgBq1CMIaECyAKhCEKIAtQIAFCAFkgAUKAgICAgICAgIB/URtFBEAgCiACQgF8IgFQrXwhCgwBCyALIAFCgICAgICAgICAf4WEUEUEQCACIQEMAQsgCiACIAJCAYN8IgEgAlStfCEKCyAAIAE3AwAgACAKNwMIIAVB4ABqJAAL0RADBn8KfgF8AkBB0IQEKAIARQRAQdiEBEEBNgIAQdyEBCgCAEUEQEGggwQoAgBFBEAQwAkLQdi5BEEINgIAAkACQEG4hAQoAgBFDQBBvIQEKAIAQYAESA0AQcCEBCgCAEEASg0BC0G4hARCADcDAAtBvIMEKAIAQbSDBCgCABEBACIADQILQdyEBEEBNgIAQeiEBCgCAEUEQEHohARBCDYCAAtB5IQEQeSEBCgCAEEBaiIANgIAQdCEBCgCAEHUhAQoAgByRQRAQdSEBEEBNgIAQYi7BEEAQdwAECcaQfCjBEEFEO8DQcClBEEPEO8DQaCqBEEKEO8DQbCtBEEgEO8DQZCMBEHMABDvAwJAQeCEBCgCAEUEQEHsgwQoAgAiBEUEQBCsCUHsgwQoAgAhBAtB6IMEKAIAIAQRAQAiBA0BC0EBIQRB4IQEQQE2AgBBChBtIgBFBEBBByEEDAELIAAQIwNAIAFBBEcEQCABQdgAbEGwhQRqIAFFEKYJGiABQQFqIQEMAQsLQYCLBEH+lwEQvQk2AgBBhIsEQYWYARC9CTYCAEEAEPgEIgBFDQAgACgCBCEBQayLBCAANgIAQZyLBEEMIAEgAUEMTRs2AgBBmIsEQQAQpgkiBA0AQQAhBEGovAQoAgAEQEHQvARBwIQEKAIAQQBBuIQEKAIAIgAbIgM2AgBBuLwEIAM2AgBBtLwEQbyEBCgCAEF4cUEAIAMbIgI2AgBBwLwEIAA2AgBBvLwEQQogA0EKbUEBaiADQdoAShs2AgBB1LwEQQA2AgBBzLwEQQA2AgBBACEBA0AgAwRAIAAgATYCAEHMvAQgADYCACADQQFrIQMgAiAAIgFqIQAMAQsLQcS8BCAANgIAC0HQhARBATYCAAtB1IQEQQA2AgBB5IQEKAIAIQALQeSEBCAAQQFrNgIAIABBAUwEQEHohARBADYCAAsjAEEwayIAJAAgAEEgaiAEQQFqtyIQRJqZmZmZmbk/okQAAAAAAADwP6AQ6wQgAEEQaiAQRAAAAAAAADlAokQAyE5nbcGrQ6AQ6wQgACIDKQMgIQggACkDKCEJIAApAxAiDSEGIAApAxgiDiEHIwBB8ABrIgIkACAHQv///////////wCDIQoCQAJAIAhQIgAgCUL///////////8AgyILQoCAgICAgMD//wB9QoCAgICAgMCAgH9UIAtQG0UEQCAGQgBSIApCgICAgICAwP//AH0iDEKAgICAgIDAgIB/ViAMQoCAgICAgMCAgH9RGw0BCyAAIAtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgCUKAgICAgIAghCEHIAghBgwCCyAGUCAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIAdCgICAgICAIIQhBwwCCyAIIAtCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgCSAGIAiFIAcgCYVCgICAgICAgICAf4WEUCIAGyEHQgAgCCAAGyEGDAILIAYgCkKAgICAgIDA//8AhYRQDQEgCCALhFAEQCAGIAqEQgBSDQIgBiAIgyEGIAcgCYMhBwwCCyAGIAqEUEUNACAIIQYgCSEHDAELIAYgCCAGIAhWIAogC1YgCiALURsiBRshCiAHIAkgBRsiDEL///////8/gyELIAkgByAFGyIPQjCIp0H//wFxIQEgDEIwiKdB//8BcSIARQRAIAJB4ABqIAogCyAKIAsgC1AiABt5IABBBnStfKciAEEPaxDKASACKQNoIQsgAikDYCEKQRAgAGshAAsgCCAGIAUbIQYgD0L///////8/gyEIIAEEfiAIBSACQdAAaiAGIAggBiAIIAhQIgEbeSABQQZ0rXynIgFBD2sQygFBECABayEBIAIpA1AhBiACKQNYC0IDhiAGQj2IhEKAgICAgICABIQhCCALQgOGIApCPYiEIAcgCYUhBwJ+IAZCA4YiBiAAIAFGDQAaIAAgAWsiAUH/AEsEQEIAIQhCAQwBCyACQUBrIAYgCEGAASABaxDKASACQTBqIAYgCCABEKQDIAIpAzghCCACKQMwIAIpA0AgAikDSIRCAFKthAshCUKAgICAgICABIQhCyAKQgOGIQoCQCAHQgBTBEBCACEGQgAhByAJIAqFIAggC4WEUA0CIAogCX0hBiALIAh9IAkgClatfSIHQv////////8DVg0BIAJBIGogBiAHIAYgByAHUCIBG3kgAUEGdK18p0EMayIBEMoBIAAgAWshACACKQMoIQcgAikDICEGDAELIAkgCnwiBiAJVK0gCCALfHwiB0KAgICAgICACINQDQAgCUIBgyAHQj+GIAZCAYiEhCEGIABBAWohACAHQgGIIQcLIAxCgICAgICAgICAf4MhCSAAQf//AU4EQCAJQoCAgICAgMD//wCEIQdCACEGDAELQQAhAQJAIABBAEoEQCAAIQEMAQsgAkEQaiAGIAcgAEH/AGoQygEgAiAGIAdBASAAaxCkAyACKQMAIAIpAxAgAikDGIRCAFKthCEGIAIpAwghBwsgB0I9hiAGQgOIhCEIIAdCA4hC////////P4MgAa1CMIaEIAmEIQcCQAJAIAanQQdxIgBBBEcEQCAHIAggCCAAQQRLrXwiBlatfCEHDAELIAcgCCAIIAhCAYN8IgZWrXwhBwwBCyAARQ0BCwsgAyAGNwMAIAMgBzcDCCACQfAAaiQAIAMpAwAgAykDCCANIA4Q9wMhACADQTBqJABBioMEIABBAEc6AAALIAQPC0HwuQRCADcDAEHouQRCADcDAEHguQRCADcDAEHYuQRCADcDACAAC10CAn8BfiMAQRBrIgQkAAJAIAEgACgCACIFTQRAIABBADYCAAwBCyAAIAUgBEEIahB7IAAoAgBqNgIAIAMgAykDAEIAIAQpAwgiBn0gBiACG3w3AwALIARBEGokAAtXAQR/IAEoAgAiBSECA0AgAkEBaiEDIAIsAAAiAiAEwHIEQCACQYABcSEEIAMhAgwBCwsgAARAIAAgACgCACAFIAMgBWsiABAlIABqNgIACyABIAM2AgALPQECfyABBEAgAUEIaiED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IAinEIgEGiAALQAjDQIgACgCBCEFCyAAKAIAIgYgAWogBGogBiABIAJqIgJqIAUgAmsQhAEaIAAgB6ciAiAAKAIEajYCBCAAIAAoAiggAmo2AigLIANFIARFcg0AIAAoAgAgAWogAyAEECUaCwsMACAAEPcGIAAQuwoLEgAgAUUEQEIADwsgACABEJYFC0YCAX4CfwJAIAFFBEAMAQsgAUEIaiEEA0AgAyABKAIATg0BIAAgBCADQQR0aigCABCBAiAChCECIANBAWohAwwACwALIAILEAAgACABEM8CECsgABDOAguiAQEDfwJAA0ACQAJAIAAtAAAiAUGtAWsOBAAAAwEDCyAAKAIMIQAMAQsLIAAtAAIhAQsCQCABQfUARiABQZkBa0EDSXINACABQacBRgRAQQEhAiAALQAGQSBxDQEgACgCLCIBRQ0BQQAhAiAALgEgIgBBAEgNASABKAIEIgNFDQEgACABLgEiTg0BIAMgAEEMbGotAARBD3FFDwtBASECCyACC/pvAh9/CH4jAEGgAWsiESQAIAAoAgghCiAAKAIAIRkgEUEANgI8IBFCADcCNCADBEAgBkH//QFxIAYgAygCAEE/SiIJGyEGQQAgAyAJGyEPCwJAAkAgASgCACIDQcEATgRAIBFBwAA2AgAgAEHe1wAgERAmDAELIBlB2AZBASADIAZBIHEbIg5B4ABsIglB/wVqQXhxIA5BAUwbIg1ByABqrRBTIQggGS0AVwRAIBkgCBApDAELIAggBDYCDCAIIA82AgggCCABNgIEIAggADYCACAIIA46ACwgCEJ/NwIUIAAgACgCOEEBayIDNgI4IAggBzsBKiAIIAY7ASggCCADNgIgIAggAzYCHCAALgGcASEDIAggBTYCECAIIAM2AiQgCEEtakEAQSMQJyEMIAhB+AVqQQAgCUHIAGoQJyEiIAhCgICAgNBzNwL0AyARIAggDWoiAzYCMCARIAhB0ABqIho2AiwgESAINgIoIANBAzsBMCADQQA7ASwgAyADQTxqNgI0IANBADYCKCAIQQA6AFkgCEEANgJkIAhBADYCVCAIIAhB8ABqNgJoIAhCgICAgIABNwJcIAggCDYCUCAaIAJBLBCdBQJAIA4EQCAIQfgDaiETIAFBCGohEEEAIQwDQCAQIAxBBnRqIgIoAighAyAIIAgoAvQD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AkACfwJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIAIgMgAWotAABBD3EODQABAgMEAwUGBgcICQoLCyACQenaAEEEEJcBIAFBAWoMEAsgAkGg5QBBBBCXASABQQFqDA8LIAJBtekAQQUQlwEgAUEBagwOCyAGKAIMIgVFDQogAiADIAhqIAFqIAUQlwIMDAsgBigCDCIFRQ0JQQIhAAJAAkACQCADIAhqIAFqIgQtAABBK2sOAwECAAILIAJBLRBqC0EDIQALIAAgBSAAIAVLGyEJA0ACQCAAIAlHBEAgACAEai0AACIDQbDzAWotAABBCHENASACIAItABlBAnI6ABkLIAYgCjcDAEHkACACQcOzAUHMDiAHGyAGEIcEDA0LAkAgCkL//////////w9WBEBBASEHDAELIANBAXTAQQd2QQlxIANqQQ9xrSAKQgSGhCEKCyAAQQFqIQAMAAsACyAGKAIMIgVFDQhBACEAIAMgCGogAWoiAy0AACIEQS1GBEAgAkEtEGogAy0AASEEQQEhAAsgBEH/AXFBLkcNBkEADAcLIAJBIhBqIAIgACgCACAIaiABaiAGKAIMIgUQlwIgAkEiEGoMCQsgBigCDCEFIAJBIhBqIAMgCGogAWohByAFIQMCQANAQQAhACADRQ0BAkADQCAAIANGDQEgACAHaiIELQAAIglBIkYgCUHcAEZyRQRAIABBAWohAAwBCwsCQCAARQRAIAchBAwBCyACIAcgABCXASADIABrIQMLIAQtAABBIkYEQCACQa7oAUECEJcBIANBAWshAyAEQQFqIQcMAgsgA0EBTQRAIAIgAi0AGUECcjoAGQwDCwJAAkACQAJAAkAgBC0AASIAQQprDgQEAwMBAAsCQAJAAkACQCAAQfYAaw4DAQYCAAsgAEHiAUYNBCAAQTBGDQIgAEEnRw0FIAJBJxBqDAYLIAJB27MBQQYQlwEMBQsgA0EDTQRAQQIhAyACIAItABlBAnI6ABkMBQsgAkGbvwFBBBCXASACIARBAmoiBEECEJcBIANBAmshAwwECyACQbHAAUEGEJcBDAMLIANBAkYEQEECIQMMAwsgBEEBaiAEIAQtAAJBCkYiABshBCADIABrIQMMAgsCQAJAIANBBEkNACAELQACQYABRw0AIAQtAANB/gFxQagBRg0BC0EC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IAAtAAAiBwRAIABBAWohAAJAIAdBsPABai0AACACQQh0ciICQeLesZMGRwRAIAJB8sKhmwZGBEBBwgAhAyAAIQQMBgsgAkH08JWjB0cgAkHi3rGbBkdxDQFBwgAhAwwFCwJAIAYOAwABAAELIAAgBCAALQAAQShGGyEEQcEAIQMMBAsgAkHswpWTB0cgAkHh3rGzBkdxIAJB4uq9owZHcSADQcMAR3INAUHFACEDDAMLIAFFDQZBACEAIAVBADYCDCADQcIASw0FIAQNA0EEIQAMBQsgAkH///8HcUH03KUDRw0ACwsgAQ0BQcQAIQMMAwsDQCAELQAAIgJFDQIgAkE6a0F2TwRAIAQgBUEMahC7AhogBSgCDEEEbSEADAMFIARBAWohBAwBCwALAAtBACEAQcQAIQMLIAFB/gEgACAAQf4BThtBAWo6AAYLIAVBEGokACADwAtGAQF/IwBBEGsiBCQAIAQgAzYCDAJAIAAgAiADEPICIgNFBEBBByECDAELIAAgASADEOwFIQIgACADEC8LIARBEGokACACC50BAQJ/IwBBEGsiBSQAAkAgASAAKAIwSwRAIAJBADYCAEGjtgQQKCEDDAELIAAoAgAiBCABIAVBDGogAyAEKALcAREGACIDBEAgAkEANgIADAELAkAgBSgCDCIDKAIIIgQtAAANACADIAEgABCGBhogBBCXAyIDRQ0AIAQQiwIgAkEANgIADAELIAIgBDYCAEEAIQMLIAVBEGokACADCzgBAX8gAQRAIAAgASgCHCICKAIUEDAgACACKAIYEDsgACACKAIIEGcgACABKAIMEDAgACABEC8LC/wCAwN/A34BfCMAQSBrIgMkAEEBIQICQCABvSIFQoCAgICAgID4/wCDQoCAgICAgID4/wBRIAVC/////////weDQgBScQ0AQYqDBC0AAARAQgAhBSMAQRBrIgIkACADIABQBH5CAAUgAiAAIABCP4ciBYUgBX0iBUIAIAV5pyIEQTFqEMoBIAIpAwhCgICAgICAwACFQb6AASAEa61CMIZ8IABCgICAgICAgICAf4OEIQUgAikDAAs3AxAgAyAFNwMYIAJBEGokACADIAEQ6wQgAykDECIAIAMpAxgiBSADKQMAIgYgAykDCCIHEPcDIQJBfyAAIAUgBiAHEPYDQQBKIAJBAEgbIQIMAQsg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QAJAAkACQAJAIANBpAFrDgMAAQIDCyANIAFBBmo2AogKQTshFyANQYgKaiIDENwEQTtHDQNBpAFBOyADENwEQRhGGyEXDAMLIA0gAUEEajYCiAogF0EXR0E7IRcNAkGlAUGlAUE7IA1BiApqENwEIgNBFkYbIANBO0YbIRcMAgsgDSABQQZqNgKICiAXQRdGBEBBpgEhFyANQYgKahDcBEEWRg0CC0E7IRcMAQsgDSAaNgKMCiANIAE2AogKIA0gDUGICmo2AjAgAEHG6AEgDUEwahAmDAILIA0gFzYC9AkLIAAgGjYC1AEgACABNgLQASANIAApANABIiA3A/gJIA0oAjgvAQAhBSANKAI8IQQCQANAIAVB//8DcSIDQcIETQRAIANBAXQiBUHApgJqLwEAIQggFyEDAn8CQANAIANB//8DcSIGIAhqQQF0IgNB0K8Cai8BACAGRg0BIAZBAXRBoKACai8BACIDDQALAkAgBkUNACAIQeUAakEBdCIDQdCvAmovAQBB5QBHDQAgA0Gw0wJqDAILIAVBoPQCagwBCyADQbDTAmoLLwEAIQULIAVB//8DcSIGQd4JTwRAAkAgBkHCmQJqLQAADQAgDSgCOCANKALwCUkNACANQThqEI4JDAMLIA0gDSkD+Ak3AxhBACEDQQAhBUEAIQhBACELIwBBgAZrIgckACANKAI4IQICQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA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gpIuscW4sz+iRFkBjRtsBua/oKJEyIpZnOUqAECgokRLLYocJzoDwKCiRAAAAAAAAPA/oKML0wECAX8CfkF/IQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQAgACAChCAFIAaEhFAEQEEADwsgASADg0IAWQRAIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPCyAAIAJWIAEgA1UgASADURsNACAAIAKFIAEgA4WEQgBSIQQLIAQL2wECAX8CfkEBIQQCQCAAQgBSIAFC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBRGw0AIAJCAFIgA0L///////////8AgyIGQoCAgICAgMD//wBWIAZCgICAgICAwP//AFEbDQAgACAChCAFIAaEhFAEQEEADwsgASADg0IAWQRAIAAgAlQgASADUyABIANRGwRAQX8PCyAAIAKFIAEgA4WEQgBSDwsgACACViABIANVIAEgA1EbBEBBfw8LIAAgAoUgASADhYRCAFIhBAsgBAuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XTxtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaE0bQZIPaiEBCyAAIAFB/wdqrUI0hr+iCwkAIAC9QjSIpwuTAwMCfgN8An8CQAJ/AkAgAL0iAUL/////////B1cEQCAARAAAAAAAAAAAYQRARAAAAAAAAPC/IAAgAKKjDwsgAUIAWQ0BIAAgAKFEAAAAAAAAAACjDwsgAUL/////////9/8AVg0CQYF4IQYgAUIgiCICQoCAwP8DUgRAIAKnDAILQYCAwP8DIAGnDQEaRAAAAAAAAAAADwtBy3chBiAARAAAAAAAAFBDor0iAUIgiKcLQeK+JWoiB0EUdiAGarciBEQAAOD+Qi7mP6IgAUL/////D4MgB0H//z9xQZ7Bmv8Daq1CIIaE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BSACQRBqIQIgA0EBaiEDDAALAAsLcwEEfwJAIAFFDQAgAUEIaiECIAEoAgAhBQNAIAMgBU4NAQJAIAIoAihBAE4NACAAIAAoAigiBEEBajYCKCACIAQ2AiggAigCFCIERQ0AIAAgBCgCIBCnBCABKAIAIQULIAJBQGshAiADQQFqIQMMAAsACwuMAQEDfyAFQQA2AgAgAUEAIAAQmQsbRQRAQaLSCBCNAQ8LIAAQ5gEDQAJAIAAgASACIAMgBCAFIAYQkQkiCEUNACAALQBXDQAgByEJIAhBEUcEQCAIQYEERw0BIAlBAWohByAJQRlIDQIMAQsgAEF/EOYDQQEhByAJRQ0BCwsgACAIEJ4BIABBADYCyAMLPAEDfyMAQRBrIgIkACABIAAoAgAoAoQBIgRKBEAgAiAENgIAIABByccBIAIQJkEBIQMLIAJBEGokACADCz8BAX8jAEEgayIDJAAgAyACNgIcIANBPjYCDCADQT82AgggAyABOwEYIANBBGogABBPGiADLwEYIANBIGokAAt1AQN/IAFBACABQQBKGyEFIAIoAgQgA0EBdGovAQAhBkEAIQEDQAJAIAEgBUcEfyAAKAIEIAFBAXRqLwEAIAZHDQEgACgCICABQQJ0aigCACACKAIgIANBAnRqKAIAECwNAUEBBUEACw8LIAFBAWohAQwACwAL9wEBBH8jAEEQayIEJAAgACgCACEDIAAoAoACBEAgAEGpyQBBABAmCyAAQQE6AJ8BAkAgA0KQARA5IgJFBEAgAyABEDsMAQsgACACNgKQASACIAE2AgQgAiAANgIAIABBLSACEKABGiADLQBXDQAgBCAANgIAQSggAkHoAGpB2s0AIAQQswEhBSACQQE6ABIgAkGWBTsBECACIAU2AgggAygCECgCHCEAIAIgATYCRCACIAJBCGoiATYCMCACQZYBOgAsIAIgAkEsajYCJCACIAA2AiAgAiAANgIcIABBKGogBSABEKYBIAFHDQAgAxBOCyAEQRBqJAALPgACQCABRSACRXINACABLQAAQfkARw0AIAAtANwBQQFLDQAgACgCACACIAM6AAAgAigCEBAwIAJBADYCEAsLvgEBBX8jAEEQayIEJAACQCABKAI0RQ0AQQEhBSABIQICQAJ/A0AgAiIDIAY2AjggAyADKAIEQYACcjYCBCADKAI0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IgFBAEgEQCAFIARBDGoQcgwBCyAEIAE2AgxBAQtqIgE2AggLIAACfyABIANqIgMsAAAiBUEASARAIAMgBEEIahByDAELIAQgBTYCCEEBCyABaiIFNgIIQYsCIQEgAiAEKAIMIgJIDQAgBCgCCCIDIAYgBWtKIANFcg0AIABBGGogAiADaiIFIARBBGoQywEgBCgCBCIBDQBBACEBIAAoAhgiBkUNACACIAZqIAAoAgAgACgCCGogAxAlGiAAIAU2AhwgACAAKAIIIANqIgI2AgggACkDEEIAUg0AAkAgACgCACACaiIBLAAAIgNBAEgEQCABIABBKGoQciEBIAAoAighAyAAKAIIIQIMAQsgACADNgIoQQEhAQsgACABIAJqIgI2AghBiwIhASAAKAIEIAJrIANIDQAgACACIANqNgIIIAAgACgCACACajYCJEEAIQELIARBEGokACABC3oBBH8jAEEQayICJAACQCAAKAIAIgQtAAAiA0ECTwRAAkAgA8BBAEgEQCAEIAJBDGoQciEFIAIoAgwhAwwBC0EBIQULIAAgBCAFajYCACABIAEpAwAgA6x8QgJ9NwMADAELIAFC////////////ADcDAAsgAkEQaiQAC0YAIAAgACgCAAJ+AkAgAQRAIAMoAgANAQsgBCACKQMAfQwBCyACKQMAIAR9CxBuIAAoAgBqNgIAIAIgBDcDACADQQE2AgALaAICfwN+IABBCmohBCAAIQMDQAJAIAVCP1YEQCAEIQMMAQtCACEGIAEgA0sEQCADMQAAIQYLIANBAWohAyAGQv8AgyAFhiAHfCEHIAVCB3whBSAGQv8AVg0BCwsgAiAHNwMAIAMgAGsLVgEDfwNAIAEgACgChAJORQRAIAAoAogCIAFBGGxqIgJBDGohAyACQQRqA0AgAygCACIDBEAgAygCCBAjDAELCxCABSABQQFqIQEMAQsLIABBADYCkAILPAEBfwJAENwBDQBB0LkEIQEDQCAARSABKAIAIgFFcg0BIAAgASgCEBCPAUUNASABQQxqIQEMAAsACyABC5QBAQN/IAEtAAdFBEBBAA8LAkACQCABEP0JIgINACABKAIAIgMgAygCOEEBajYCOCABKAIMQQEgASkDIBBIGiABQQA6AAcgASgCDBBBIAMgAygCOEEBazYCOEHkAEYNASABKAIMEDoi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CSARckH/AXENAEEAIQkMAQsgCCkDCCAohCIoQn+FISNCACEfA38gHyAhUQR/QQEFAkBCASAfhiImICCDQgBSDQAgGCAQIB+nQQR0aigCACIBEIECIilQBEAgARDUAUUNAQsgJkIAICMgKYNQGyAghCEgCyAfQgF8IR8MAQsLIQkLICJCAXwhIgwACwALQQAhAQsgAcALtwMBBX8CQCAALQBhQacBRw0AIAAQxgkNACAAQQAQ6QIgABD7AwNAIAAoAhAhAiABIAAoAhRORQRAAkAgAiABQQR0aiIDKAIEIgJFDQAgAhCUAiADQQA2AgQgAUEBRg0AIANBADYCDAsgAUEBaiEBDAELCyACKAIcIgIEQCACEIkECyAAEIYFIAAQ6gYgAEGoA2ohAwNAIAMoAgAiAwRAIAMoAgghAQNAIAAgARDCCSABKAIMIAAgARApIgENAAsMAQsLIABBoANqEJMCIABBuANqIQQDQCAEKAIAIgQEQCAEKAIIIQVBACEBA0AgAUEDRwRAIAUgAUEUbGoiAygCECICBEAgAygCCCACEQQACyABQQFqIQEMAQsLIAAgBRApDAELCyAAQbADahCTAiAAQYwDaiEBA0AgASgCACIBBEAgACABKAIIIgIQuwYgACACELgGDAELCyAAQYQDahCTAiAAQQAQiwEgACgCoAIQkAEgAEHVAToAYSAAIAAoAhAoAhwQKSAAKAKAAiICBEAgACgC/AEgAhEEAAsgAEHOAToAYSAALQC4AgRAIAAoAuACECMLIAAQIwsLkQsBE38jAEEQayIPJAAgACgCCCERAkACQAJAAkACQAJAAkAgASgCACIKLQAAIgZBMmsOBAIDAwEACyAGQS1HDQILIAAgCigCECAFEPQBIQUMAgsgEUHLAEEAIAUQIhoMAQsCQCACKAJQIgstAClBBHENACALKAIgIgZFDQAgBigCHCADai0AAEUNACAERSEEC0EAIQYgA0EAIANBAEobIQcDQAJAIAYgB0YEQCADIAsvASwiBiADIAZKGyEIQQAhByADIQYDQCAGIAhGDQIgByALKAI0IAZBAnRqKAIAKAIAIApGaiEHIAZBAWohBgwACwALIAsoAjQgBkECdGooAgAiCARAIAgoAgAgCkYNBAsgBkEBaiEGDAELCyAPQQA2AgwCQAJAIAooAgQiBkGAIHEEQCAK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AAsgCCAbOgAACyAEKAKEARBKIAAgGDYCLCAAIBk2AiggACAaNgIgIA9BAWohBgsgBEGQAWokACAGC2wCAn8CfiMAQRBrIgMhAgJAA0AgACkDACEEA0AgASkDACIFIARZBEAgBCAFUwRAIAIgADYCCCAAIQILIAAoAggiAA0CDAMLIAIgATYCCCABIgIoAggiAQ0ACwsgACEBCyACIAE2AgggAygCCAu+AgECfyAALQAFIQICQAJAIAAtAA9FDQAgAUECaw4DAAEAAQsgASACRg0AIAAgAToABQJAIAFBAXEgAkEFcUEBR3INACAALQAEDQAgACgCRCIBKAIAIgIEQCABIAIoAgQRAQAaIAFBADYCAAsgAC0AEkECTwRAIAAoAgAiASgCHCICRQ0CIAEgACgCvAFBACACEQMAGgwCC0EAIQEgAC0AESICIQMCQCACBH8gAwUgABDICCEBIAAtABELQQFGBH8gAEECEK8CBSABCw0AIAAoAgAiASgCHCIDBEAgASAAKAK8AUEAIAMRAwAaCyACQQFHDQAgAEEBENwCGgwCCyACDQEgABDTBAwBCwJAIAFBAmsOAwABAAELIAAoAkQiASgCACICRQ0AIAEgAigCBBEBABogAUEANgIACyAALQAFC40CAQN/IAAoAgAhAiAAKAJ0IgEEQCABIAAvAZIBQQF0EK8DIAIgACgCdBBcCyAAKALoASEBA0AgAQRAIAEoAhggAiABKAIAIAEoAgQQnQogAiABEC8hAQwBCwsCQCAALQCXAUUNACAAKAJkIAAuARAQrwMgACgCgAEiAQRAIAIgARBcCyAAKALUASIBRQ0AIAIgARBcCyACIAAoAmggACgCbBCdCiAAKALIASIBBEAgAiABEFwLIAIgACgCzAEQKSAAKALQASEBA0AgAQRAIAEoAgAgAiABEC8hAQwBCwsCQCACKAKQBA0AIAAoAgQgACgCCCIBNgIAIAFFDQAgASAAKAIENgIECyACIAAQXAt5AQJ/AkAgAEUNACAALQAIQQJHDQAgACgCBCIDIAAoAgA2AgQgAUECRgRAIANBAEEAEMACIgQNAQsgAygCACABIAIQ0ggiBA0AAkAgAkEATg0AIAMtABhBEHFFDQAgA0EANgIwCyADEPsGIQQgAyADKAIMEMgJCyAECxsBAX8DQCABBEAgASgCBCAAIAEQ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AwAgAkEBayECIABEAAAAAAAAcD6iIQAgBA0ACyADIQQDQEQAAAAAAAAAACEAQQAhAiAKIAMgBGsiBiAGIApKGyIHQQBOBEADQCACQQN0QcD+A2orAwAgBSACIARqQQN0aisDAKIgAKAhACACIAdHIAJBAWohAg0ACwsgBUGgAWogBkEDdGogADkDACAEQQBKIARBAWshBA0ACwtEAAAAAAAAAAAhACADQQBOBEAgAyECA0AgAiIEQQFrIQIgACAFQaABaiAEQQN0aisDAKAhACAEDQALCyAJIACaIAAgDBs5AwAgBSsDoAEgAKEhAEEBIQIgA0EASgRAA0AgACAFQaABaiACQQN0aisDAKAhACACIANHIAJBAWohAg0ACwsgCSAAmiAAIAwbOQMIIAVBsARqJAAgCEEHcQwCC0EBIQIDQCACIgRBAWohAiAFQeADaiAKIARrQQJ0aigCAEUNAAsgAyAEaiEEA0AgBUHAAmogAyALaiIIQQN0aiADQQFqIgMgEGpBAnRB8OgDaigCALc5AwBBACECRAAAAAAAAAAAIQAgC0EASgRAA0AgDyACQQN0aisDACAFQcACaiAIIAJrQQN0aisDAKIgAKAhACACQQFqIgIgC0cNAAsLIAUgA0EDdGogADkDACADIARIDQALIAQhAwwACwALIQMgCSsDACEAIBlCAFMEQCABIACaOQMAIAEgCSsDCJo5AwhBACADayEDDAELIAEgADkDACABIAkrAwg5AwgLIAlBMGokACADCzMBAX8gASABKAIIQQFrIgI2AgggAkUEQCABKAIQIgIEQCABKAIMIAIRBAALIAAgARApCwv6AwMDfAJ/AX4gAL0iBkIgiKdB/////wdxIgRBgIDAoARPBEAgAEQYLURU+yH5PyAApiAAvUL///////////8Ag0KAgICAgICA+P8AVhsPCwJAAn8gBEH//+/+A00EQEF/IARBgICA8gNPDQEaDAILIACZIQAgBEH//8v/A00EQCAEQf//l/8DTQRAIAAgAKBEAAAAAAAA8L+gIABEAAAAAAAAAECgoyEAQQAMAgsgAEQAAAAAAADwv6AgAEQAAAAAAADwP6CjIQBBAQwBCyAEQf//jYAETQRAIABEAAAAAAAA+L+gIABEAAAAAAAA+D+iRAAAAAAAAPA/oKMhAEECDAELRAAAAAAAAPC/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ASICKAIEIgENAAsgAigCDAUgDAsgCkEobGoiARCNA0ENIQcgASkDACIoQv///////////wBRDUAgBC0ABUECcQ1AICggBikD4AIiKVkEQCAGIChCAXwiKTcD4AILIAEgKTcDAAsCQCAELQAFQQJxBEBBACEBA0ACQEEIIAZB4AJqEOQBIAYgBikD4AJC//////////8/g0IBfCIoNwPgAiAEKAIkIChBACAGQdADahCDAyICIAYoAtADIgpyDQAgAUHjAEkgAUEBaiEBDQELCyACDQFBACELIApFDQELIARBADYCGCAEQQA6AAMgBSAGKQPgAjcDAAw7CyACQQ0gAhshBww/CyAAIAMQfyAAKAJgIAMoAgRBAnRqKAIAIgIgAikDECIoQgF8NwMQICg3AwAMOQsgAygCDCEBDAELIAwgAygCDCIBQShsaiICLQAQQSRxDQAgBkHgAmoiASACQSgQJRogAUHDACATEOMBIAYvAfACQQRxRQ00IAYpA+ACDAELIAwgAUEobGopAwALISggACgCYCADKAIEQQJ0aigCACIBKAIkQQAhCyAGQQA2AtACIChBACAGQdACahCDAyEHIAFBADYCGCABICg3AzggAUEAOwECIAEgBigC0AIiATYCHCABBEAgAygCCARAIAchCww0C0GJ/gUQKCEHDDsLIAdFDTUMOgsgAygCECAAKAJgIAMoAgRBAnRqKAIALwEGTA00CyAAKAJgIAMoAgRBAnRqKAIAIQEgBiAMIAMoAgxBKGxqIgI2AuQCIAYgAygCECIHOwH0AgJAIAdB//8DcQRAIAEoAighAiAGQQA6APYCIAYgAjYC4AIgASgCJCAGQeACaiABQRxqEIUDIQcMAQsgAi0AEUEEcQRAIAIQ2gENNwsgASgCKBDABCICRQ02IAEoAiggBigC5AIiBygCDCAHKAIIIAIQ0QMgAkEAOgAWIAEoAiQgAiABQRxqEIUDIQcgCCACEC8LIAcNOCABQQA2AhggAUEAOgADIAEgASgCHCICQQBHOgACIAMtAAAiC0EdRgRAIAJFDQYMFwsgAg0FAkACQCALQRprDgIBABgLQQAhASAGKALkAiECIAYvAfQCIQsDQCABIAtGDRggAUEobCEEIAFBAWohASACIARqLQAQQQFxRQ0ACwwGCyABIAMoAhA7AQYMFgsgACgCYCAD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BCIDRQ0AIAMgASgCABAsDQAgBSAGRw0CIAItAAoNAgsgAi0ACEGWAUcNAAsgASgCACEDIAIgBzYCGCACIAM2AgQLIAIgBDYCIAwBCwsgBAuJAQEEfyAAIAIgAUECdEEHakF4cSIEIAEgAUEBdCICaiACQQJqIgVqQQdqQXhxakHIAGoiBmqsEDkiAARAIAAgATsBNCAAIABByABqIgc2AiAgACABQQFrOwEyIAAgBCAHaiIBNgIIIAAgASAFaiIBNgIEIAAgASACajYCHCADIAAgBmo2AgALIAALMwACQAJAAkAgAC0AAEHxAGsOBQACAgIBAgsgACgCDCIALQAAQfUARw0BCyAAQTs6AAALCyEAIABBoOUAECxFBEBBgICAgAEPCyAAQbXpABAsRUEddAsqACAAIAAoAgRBgIGAIEGAgIAgIAAoAggiAC0AAEEiRhtyNgIEIAAQkgILowIBBX8gASgCACEDA0ACQCACIARqLQAAIgdFDQAgB0HfAEcEQCAHQbDzAWotAABBBnFFDQELIARBAWohBAwBCwsCfwJAIAItAABBOmtBdUsNACMAQRBrIgYkAEE7IQUgBkE7NgIMIARBAk4EQCACIAQgBkEMahCLCRogBigCDCEFCyAGQRBqJAAgByAERXINAEEAIAVBO0YNARoLIAAgA2pBIjoAACADQQFqIQNBAQtBACEEA0AgAiAEaiIHLQAAIgUEQCAAIANqIAU6AAAgA0EBaiEFIActAABBIkcEfyAFBSAAIAVqQSI6AAAgA0ECagshAyAEQQFqIQQMAQsLBEAgACADakEiOgAAIANBAWohAwsgACADakEAOgAAIAEgAzYCAAs5AQJ/A0ACQCAALQAAIgJBIkcEQCACDQEgAUECag8LIAFBAWohAQsgAEEBaiEAIAFBAWohAQwACwALZgEGfyAALwE0IQQgACgCDCgCBCEFA0AgASAERkUEQEEBIQMgACgCBCABQQF0ai4BACIGQQBOBEAgBSAGQQxsai0ABiEDCyABQQFqIQEgAiADaiECDAELCyAAIAJBAnStELwBOwEwC24CA38BfiAALwE0IQEgACgCDCEDA0AgAUEASgRAIAAoAgQgAUEBayIBQQF0ai4BACICQQBIIAJBPktyDQEgAygCBCACQf//A3FBDGxqLwEKQSBxDQFCASACrYYgBIQhBAwB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AhDaBQwBCwsgCSgCECAHQQR0aigCDCIAIAAvAU5B/f8DcTsBTgsgCCABEH4gBkHQAGokAAskACABBEAgASACNgJAIAAgARCuBCABDwsgACgCACACELoEIAELwgEBBn8CQCAARQ0AIAAoAgAiA0ECSA0AIABBCGohAiADIQEDQCACIAFBAWsiBkEGdGogAUEGdCACakHcAGstAAAiBToAJCAEIAVyIQQgAUECSyAGIQENAAsgAEEAOgAsIARBEHFFDQADQAJAIAMiAUECSARAQQEhAQwBCyACIAFBAWsiA0EGdGotACRBEHFFDQELCyABQQJrIQEDQCACIAFBBnRqIgAgAC0AJEHAAHI6ACQgAUEASiABQQFrIQENAAsLC0sAAkAgAEUNACAAKAIAQQR0IABqIgAgAUEAIAFBf0cbIgE6AAAgAkF/Rg0AIAAgAC8AAUEgcjsAASABIAJGDQAgACABQQJyOgAACwthAQF/IAIEfyAAIAEgAigCAEEBELgFIgNFBEAgACgCACACEH4gAQ8LIANByABqIAJBCGogAigCAEEGdBAlGiAAKAIAIAIQLyADIAMtACwgAy0AbEHAAHFyOgAsIAMFIAELCz0BAX8jAEEQayIDJAACQCABRQ0AIAEoAgAgACgCACgCgAFMDQAgAyACNgIAIABB9TMgAxAmCyADQRBqJAALogIBBn8jAEEQayIGJAAgAQR/IAEoAgAFQQALIQggACgCACEHAkAgAkUgA0VyDQACQCADLQAAQYoBRg0AIAIoAgAiBCADEIwBIgVGDQAgBiAFNgIEIAYgBDYCACAAQc0pIAYQJgwBCyACQQhqIQlBACEEA0AgBCACKAIAIgVORQRAAkAgACADIAQgBRCnByIFRQ0AIAAgASAFEFUiAUUEQEEAIQEMAQsgASgCAEEEdCABakEEayAJIARBA3RqIgUoAgA2AgAgBUEANgIACyAEQQFqIQQMAQsLIActAFcNACABRSADLQAAQYoBR3INACABIAhBBHRqKAIIIgQgBTYCHCAEIAM2AhBBACEDCyAAIAMQ3QcgByACEN8BIAZBEGokACABCzsAAkAgAigCBEUNACAAKAIAQfEAIAIgAxB0IgBFDQAgACABNgIMIAAgACgCBEGAxAByNgIEIAAPCyABC4QBACABRQRAIAAgAhAwIAAgAxAwDwsgASAD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BEBBihohA0HKASAEEQEADQELIAIgACgCAEEAIAFBniAgAkEMahC7CCIDNgIMIAMNACACQgA3AwAgASgCACIAKAIAIgFFBEBBACEDDAELIABBEiACIAEoAigRAwAaIAIoAgwhAwsgAkEQaiQAIAMLrwEBBH8jAEEQayIDJAAgA0EANgIMIANBADYCCCADQQxqIQQCQANAIAJBCGohBQJAA0AgACADQQhqIAFBCGogASgCACAFIAIoAgAgACgCKBEKAEEASg0BIAQgATYCACABIgZBBGohBCABKAIEIgENAAsgBiACNgIEDAILIAQgAjYCACACKAIEIANBADYCCCACIgVBBGohBCICDQALIAUgATYCBAsgAygCDCADQRBqJAAL3wMBDX8jAEHgAGsiBSQAIAEgASACaiICIAEgAkobIQwgACgCOCILIAAoAjQoAigiDWohDiAALQAKIAsgAC0ACWpqQQhqIQ8DQAJAAkACQAJAIAEgDEYEQEEAIQIgBEEAIARBAEobIQEDQCABIAJGDQIgACACQQJ0IgMgBUEwamooAgAiBEH//wNxIAMgBWooAgAgBGtB//8DcRDnBRogAkEBaiECDAALAAsgAygCCCABQQJ0aigCACICIA9JIAIgDk9yDQMgAiALa0H//wNxIgkgAygCDCABQQF0ai8BAGohCEEAIQIgBEEAIARBAEobIQoCQANAIAIgCkYNASAIIAJBAnQiBiAFQTBqaiIQKAIARgRAIBAgCTYCAAwFCyACQQFqIQIgBSAGaiIGKAIAIAlHDQALIAYgCDYCAAwDC0EAIQIgBEEKTgRAA38gAiAERgR/QQAFIAAgAkECdCIKIAVBMGpqKAIAIgZB//8DcSAFIApqKAIAIAZrQf//A3EQ5wUaIAJBAWohAgwBCwshBAsgBSAEQQJ0IgJqIAg2AgAgBUEwaiACaiAJNgIAIAggDUwNAUEAIQcLIAVB4ABqJAAgBw8LIARBAWohBAsgB0EBaiEHCyABQQFqIQEMAAsAC8MDARB/IAMoAkAhCyADKAI0IgQoAgAoAuABIg8gAygCOCIKIAMtAAlqIggtAAVBCHQgCC0ABnIiBUEAIAUgBCgCKCIETRsiBWogBSAKaiIQIAQgBWsQJRogAEEoaiEMIAEgAmohESAEIApqIQUDQAJAIAdBBkYNACAMIAdBAnRqKAIA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Bn0iAqdqIQELIAAgATYCWAJAIAAoAmQiAQ0AQQAhASACIANTDQAgByACIAN9IgKnaiEBCyAAIAE2AmQCQCAAKAJcIgENAEEAIQEgAiAEUw0AIAcgAiAEfSICp2ohAQsgACABNgJcAkAgACgCYCIBDQBBACEBIAIgBVMNACAHIAIgBX2naiEBCyAAIAE2AmAMAgsgCi0AV0UNAQsgAEEAOwEQIABCADcCFAwBCyAAIA87ARAgACANNgIYIAAoAmQgDyAKQQEQqQYgACAINgIUIAAoAlggCCAKQQAQqQYgACgCYEEAIAsQJxoLIAAQngsgDEEQaiQAC3EBA38gACgCACICQvABEFMiAQRAIAFB6ABqQQBBiAEQJxogASACNgIAIAIoAgQiAwRAIAMgAUEIajYCBAsgASACQQRqNgIEIAEgAzYCCCACIAE2AgQgASAANgIMIAAgATYCCCABQQhBAEEBECIaCyABC5wBAwF8AX4BfwJAIAAvARAiA0EgcUUEQAJ+AkAgACsDACIBRP///////9/DYw0AQv///////////wAgAUT////////fQ2QNARogAZlEAAAAAAAA4ENjRQ0AIAGwDAELQoCAgICAgICAgH8LIgJC////////////AHxCfVYgASACuWJyDQEgACACNwMACyAAIANBwOQDcUEEcjsBEAsLPAACf0EBIABEAAAAAAAAAABhDQAaQQAgAL0gAbm9UiABQoCAgICAgIB8U3INABogAUKAgICAgICABFMLCx4AIAAQlgEgACABQSgQJRogAUEANgIYIAFBATsBEAtTAQR/IAAEQCAAKAIEIQVBAiEDA0ACQCAAIANBAnRqIgRBCGoiBiABIAIQowMNACACIAZqLQAADQAgBCgCAA8LIAQoAgQgA2oiAyAFSA0ACwtBAAseAQF/IABFIAFFcgR/QQAFIAAoAoABIAEgAhCfCQsLQQEDfyAABEAgACgCBCEEQQIhAgNAIAEgACACQQJ0aiIDKAIARgRAIANBCGoPCyADKAIEIAJqIgIgBEgNAAsLQQALEgAgACABIAIgA6wgBEEBEK4GCygBAX8gACABQQFrIgEQ6AEiA0UEQCAAKAJkIAFBKGxqIAIQqgkLIAMLMgEBfyAAIAEQzwIiAS8BECICQYDAAHEEQCABIAJB/78CcUGAgAFyOwEQCyAAEM4CIAELYQECfkJ/IQICQBDcAQ0AQeC5BCkDACECIABCAFMNAEHguQRB6LkEKQMAIgEgASAAIAAgAVUbIABQGyAAIAFCAFUbIgA3AwBB8LkEIABBgLkENQIAVyAAQgBVcTYCAAsgAguMAQEEfxDcASIERQRAAkAgACICRQ0AIAJB0LkEKAIAIgBGBH9B0LkEBSAARQ0BA0AgACIDKAIMIgBBACAAIAJHIgUbDQALIAUNASADQQxqCyACKAIMNgIAC0HQuQQhAyACIAFB0LkEKAIAIgBFcgR/IAAFIABBDGohAyAAKAIMCzYCDCADIAI2AgALIAQLMgEBfwJAIAAQrQIiAkEQRwRAIAINASABQQA2AgAgABD2BQ8LIAFBATYCAEEAIQILIAILogEBAn8CQCAALwEQIgFBgsQBcUECRw0AIAAtABJBAUcNACAAKAIIIgJFDQACQAJ/IAFBgCBxBEAgACgCJCIBQQFGBH8gAkGsgwQoAgARAQAgACgCDCIBQQFqTwRAIAAoAgggAWoMAwsgACgCJAUgAQtBCUYNAgwDCyAAKAIMIgEgACgCGE4NAiABIAJqC0EAOgAACyAAIAAvARBBgARyOwEQCws4ACAAELMGIAAgA0EIIAMbNgIkIABB8AA6ABMgAEGBNDsBECAAIAE2AgggACACQd7uASACGzYCAAtHAQF+IAAQXSABvSICQoCAgICAgID4/wCDQoCAgICAgID4/wBRIAJC/////////weDQgBScUUEQCAAQQg7ARAgACABOQMACwsZACABQQFqQQJPBEAgACABEQQACyACEOcCCyQBAX8jAEEQayIAJAAgAEH0mwM2AgBBEiAAEIoJIABBEGokAAtdAQF/QQchASAAIAAoAgxBA2pBARD7AgR/QQcFIAAoAgggACgCDGpBADoAACAAKAIIIAAoAgxqQQA6AAEgACgCCCAAKAIMakEAOgACIAAgAC8BEEGABHI7ARBBAAsLowEBAX8CQAJAIAAvARAiAkEScQRAIAAgAkGACHEEfyAAENoBDQMgAC8BEAUgAgtBAnI7ARAgAUH3AXEiAiAALQASRwRAIAAgAhDBARoLAkAgAUEIcUUNACAALQAIQQFxRQ0AIAAQvgINAwsgAC8BEEGCBHFBAkcNASAAEK0JGgwBCyAAIAFBABCOAxoLIAAtABIgAUH3AXFHDQAgACgCCA8LQQALeAECfwJAAkAgAC8BECICQQJxRQ0AIAAtABIiAyABRg0BIAFBAUYNACADQQFHDQELAn8gAkEQcQRAIAAoAgwiASACQYAIcUUNARogACgCACABag8LQQAgAkEBcQ0AGiAAIAEQrgkEfyAAKAIMBUEACwsPCyAAKAIMC0wBAXwgAUEBRgRAIAIoAgAQUEEFRgRAIAAQVw8LIAIoAgAQSSEHQZC9BEEANgIAIAAgByAGoiAFoxBYDwtBurkBQcKLASAEIAMQAAALMgECfwJAIAAgARBHIgJFDQAgAigCCCIDRQ0AIAAgAxDpASACKAIIEJABIAJBADYCCAsLFAAgAEHfAHEgACAAQeEAa0EaSRsL2gECAXwBfgJAIACZIgG9IgJCgICAgLD95PA/WgRAIAJCgICAgJCAgJrAAFoEQEQAAAAAAAAAgCABo0QAAAAAAADwP6AhAQwCC0QAAAAAAADwP0QAAAAAAAAAQCABIAGgEPEDRAAAAAAAAABAoKOhIQEMAQsgAkKAgICA8JWW6D9aBEAgASABoBDxAyIBIAFEAAAAAAAAAECgoyEBDAELIAJCgICAgICAgAhUDQAgAUQAAAAAAAAAwKIQ8QMiAZogAUQAAAAAAAAAQKCjIQELIAGaIAEgAL1CAFMbC58DAwJ8AX4CfyAAvSIFQoCAgICA/////wCDQoGAgIDwhOXyP1QiBkUEQEQYLURU+yHpPyAAmaFEB1wUMyamgTwgASABmiAFQgBZIgcboaAhAEQAAAAAAAAAACEBCyAAIAAgACAAoiIEoiIDRGNVVVVVVdU/oiAEIAMgBCAEoiIDIAMgAyADIANEc1Ng28t1876iRKaSN6CIfhQ/oKJEAWXy8thEQz+gokQoA1bJIm1tP6CiRDfWBoT0ZJY/oKJEev4QERERwT+gIAQgAyADIAMgAyADRNR6v3RwKvs+okTpp/AyD7gSP6CiRGgQjRr3JjA/oKJEFYPg/sjbVz+gokSThG7p4yaCP6CiRP5Bsxu6oas/oKKgoiABoKIgAaCgIgOgIQEgBkUEQEEBIAJBAXRrtyIEIAAgAyABIAGiIAEgBKCjoaAiACAAoKEiACAAmiAHGw8LIAIEfEQAAAAAAADwvyABoyIEIAS9QoCAgIBwg78iBCADIAG9QoCAgIBwg78iASAAoaGiIAQgAaJEAAAAAAAA8D+goKIgBKAFIAELC4QBAQJ/IwBBEGsiASQAAkAgAL1CIIinQf////8HcSICQfvDpP8DTQRAIAJBgICA8gNJDQEgAEQAAAAAAAAAAEEAELQJIQAMAQsgAkGAgMD/B08EQCAAIAChIQAMAQsgACABELcGIQIgASsDACABKwMIIAJBAXEQtAkhAAsgAUEQaiQAIAALgQIBAn8CQAJAAkACQCABIAAiA3NBA3ENACACQQBHIQQCQCABQQNxRSACRXINAANAIAMgAS0AACIEOgAAIARFDQUgA0EBaiEDIAJBAWsiAkEARyEEIAFBAWoiAUEDcUUNASACDQALCyAERQ0CIAEtAABFDQMgAkEESQ0AA0BBgIKECCABKAIAIgRrIARyQYCBgoR4cUGAgYKEeEcNAiADIAQ2AgAgA0EEaiEDIAFBBGohASACQQRrIgJBA0sNAAsLIAJFDQELA0AgAyABLQAAIgQ6AAAgBEUNAiADQQFqIQMgAUEBaiEBIAJBAWsiAg0ACwtBACECCyADQQAgAhAnGiAACwoAIABoQQAgABsLlQEBBn9BBCECIwBBgAJrIgUkACABQQJOBEAgACABQQJ0aiIHIAU2AgADQCAHKAIAIAAoAgBBgAIgAiACQYACTxsiBBAlGkEAIQMDQCAAIANBAnRqIgYoAgAgACADQQFqIgNBAnRqKAIAIAQQJRogBiAGKAIAIARqNgIAIAEgA0cNAAsgAiAEayICDQALCyAFQYACaiQACyEAIABBAWsQtwkiAAR/IAAFIAEQtwkiAEEgakEAIAAbCwviAQECfyACQQBHIQMCQAJAAkAgAEEDcUUgAkVyDQAgAUH/AXEhBANAIAAtAAAgBEYNAiACQQFrIgJBAEchAyAAQQFqIgBBA3FFDQEgAg0ACwsgA0UNASABQf8BcSIDIAAtAABGIAJBBElyRQRAIANBgYKECGwhAwNAQYCChAggACgCACADcyIEayAEckGAgYKEeHFBgIGChHhHDQIgAEEEaiEAIAJBBGsiAkEDSw0ACwsgAkUNAQsgAUH/AXEhAQNAIAEgAC0AAEYEQCAADwsgAEEBaiEAIAJBAWsiAg0ACwtBAAs7AQF/IwBBEGsiAiQAIAAgAacgAUIgiKdBACACQQhqEAwQ9AMhACACKQMIIQEgAkEQaiQAQn8gASAAGwvqAQEDfwJAAkACQCABQf8BcSICIgMEQCAAQQNxBEADQCAALQAAIgRFIAIgBEZyDQUgAEEBaiIAQQNxDQALC0GAgoQIIAAoAgAiAmsgAnJBgIGChHhxQYCBgoR4Rw0BIANBgYKECGwhBANAQYCChAggAiAEcyIDayADckGAgYKEeHFBgIGChHhHDQIgACgCBCECIABBBGoiAyEAIAJBgIKECCACa3JBgIGChHhxQYCBgoR4Rg0ACwwCCyAAED8gAGoPCyAAIQMLA0AgAyIALQAAIgJFDQEgAEEBaiEDIAIgAUH/AXFHDQALCyAAC30BBH8gACAAQT0QvAkiAUYEQEEADwsCQCAAIAEgAGsiBGotAAANAEGEwQQoAgAiAUUNACABKAIAIgJFDQADQAJAIAAgAiAEEKMDRQRAIAIgBGoiAi0AAEE9Rg0BCyABKAIEIQIgAUEEaiEBIAINAQwCCwsgAkEBaiEDCyADCxgBAX8jAEEQayIBIAA5AwggASsDCCAAogsoACABRAAAAAAAAMB/oiAARIvdGhVmIJbAoBC8BqJEAAAAAAAAwH+iCyQBAX8jAEEQayIAJAAgAEHUmwM2AgBBBCAAEIoJIABBEGokAAuxAwEFfyAAQQhNBEAgARDrAQ8LAn9BECECAkBBECAAIABBEE0bIgMgA0EBa3FFBEAgAyEADAELA0AgAiIAQQF0IQIgACADSQ0ACwsgAUFAIABrTwRAQZC9BEEwNgIAQQAMAQtBAEEQIAFBC2pBeHEgAUELSRsiAyAAakEMahDrASICRQ0AGiACQQhrIQECQCAAQQFrIAJxRQRAIAEhAAwBCyACQQRrIgUoAgAiBkF4cSAAIAJqQQFrQQAgAGtxQQhrIgIgAEEAIAIgAWtBD00baiIAIAFrIgJrIQQgBkEDcUUEQCABKAIAIQEgACAENgIEIAAgASACajYCAAwBCyAAIAQgACgCBEEBcXJBAnI2AgQgACAEaiIEIAQoAgRBAXI2AgQgBSACIAUoAgBBAXFyQQJyNgIAIAEgAmoiBCAEKAIEQQFyNgIEIAEgAhDtBAsCQCAAKAIEIgFBA3FFDQAgAUF4cSICIANBEGpNDQAgACADIAFBAXFyQQJyNgIEIAAgA2oiASACIANrIgNBA3I2AgQgACACaiICIAIoAgRBAXI2AgQgASADEO0ECyAAQQhqCws3AQF/AkAgASgCJCIBRQ0AIAEgASgCAEEBayICNgIAIAINACABKAIIIAEoAgQRBAAgACABEC8LCzkBAX8DQCAABEAgACgCACIDBEAgAyABIAIQwwkLIAAoAgggACkDECACIAERIQAgACgCBCIADQELCwsKACAAKAIAEL0GCw4AIAAoAgAgASACEMMJC1oBBH8CQAJAIAAoAgQNACAAKAIUIgFBACABQQBKGyEDQQAhAQNAIAEgA0YNAiAAKAIQIAFBBHRqKAIEIgQEQCAEKAIQDQILIAFBAWohAQwACwALQQEhAgsgAgvVAQEDfwJAA0AgACADai0AACICRQ0BIAJBIHJB+wBrQWVNBEAgA0EBaiEDDAELCyABIAIQsgk6AABBASECA0ACQCACQQNKDQAgACADai0AACIERQ0AIARB/wBxQeDBA2otAAAiBARAIAEgAmogBEEwajoAACACQQFqIQILIANBAWohAwwBCwtBBCACIAJBBEwbIQADQCAAIAJGRQRAIAEgAmpBMDoAACACQQFqIQIMAQsLIAAgAWpBADoAAA8LIAFBvL8BLQAAOgAEIAFBuL8BKAAANgAACyEAIAAgASgCOEEcahAuIgEEfyABBSAAKAIAKAIcCzYCMAuvAQEIfyMAQRBrIgMkACAAKAI4IQECQCAAKAIEDQAgAC0AFUUgAUECSXINACAAKAIsIgdBAWohCCAAQagBaiEEA0ACQCAHIAFBAWsiAWoiBS0AACIGQdsARyAGQS5HcQ0AIAVBADoAACAEQQAgCEEAEPABIQIgBSAGOgAAIAJBfU8NACAEIAIgA0EMahBhIAJqIAAoAghGDQILIAFBAk8NAAtBASEBCyADQRBqJAAgAQuGAgEFfyMAQTBrIgEkAAJAIAAtABRBC0YEQCABIAAoAiAgACgCGEEYbGpBCGspAwA3AwBBHiAAQShqQaiPASABEIcEDAELIAFBADYCLCAAQagBaiAAKAIIIgIgAUEsahBhIAIgACgCqAFqaiEEAkACQCABKAIsIgJFDQAgBC0AAEGw8wFqLQAAQQJxRQ0AA0AgAiADRg0CIAMgBGogA0EBaiEDLQAAQbDzAWotAABBBnENAAsLIAEgBDYCFCABIAI2AhAgAkEEaiAAQShqQbXkASABQRBqEIcEDAELIAEgBDYCJCABIAI2AiAgAkECaiAAQShqQesuIAFBIGoQhwQLIAFBMGokAAtPAQF/IAAoAgxC4AEQOSICRQRAQQcPCyAAKAIMIQAgAkEBOgBAIAJCADcDOCACQuQANwMwIAIgAkHCAGo2AiwgAiAANgIkIAEgAjYCAEEAC1YBAX8gACAAKAIMQQFqNgIMIAAoAgggAEEQaiAAQRRqIABBGGogAEEcaiAAQSBqIAAoAgAoAgwoAhQRCgAiAUUEQEEADwsgABDABiABQQAgAUHlAEcbC6YBAQV/IAJFIQUCQANAIABFDQEgACgCBCICIAAoAgA2AgQgAkEIaiECA0AgAigCACIDBEACQAJAIAUNACADLQABQQFxDQACQCADLQAADgMAAgACCyADEMMIIgJFDQFBASEFIAcgAiAEGyEHIAIhAUEBIQQMBAsgAxDHBCADIAE2AgQgA0EEOgAACyADEJEDIANBGGohAgwBCwsLIAdBACAEGyEGCyAGC4ACAQZ/IwBBEGsiBSQAA0AgAARAAkAgACgCFCICRQ0AIAIoAhwiAkUNAEEAIQMgBUEANgIMA0BBACEGQQAhBANAIAYgAi0AACIHQf4BcXIEQCACQQFqIQIgBCAGRWohBCAHQYABcSEGDAELCyAAKAIoIANBDGxqIgNBBGogAygCBCAEajYCACADIAMoAgggBEEAR2o2AgggAi0AAEUNASACQQFqIQQCQCACLAABIgNBAEgEQCAEIAVBDGoQciECIAUoAgwhAwwBCyAFIAM2AgxBASECCyACIARqIQIgASADSg0ACwsgACgCDCABEM4JIAAoAhAhAAwBCwsgBUEQaiQAC0QBBH8gACgCACEBA0AgAS0AACIEQf4BcSADcgRAIARBgAFxIQMgAUEBaiEBIARBB3ZFIAJqIQIMAQsLIAAgATYCACACC1cBAn8CQANAIAAoAgAiBUEFRwRAIAAoAgwgASACIAMQ0AkiBCAFQQJGcg0CIAAoAhAhAAwBCwsgACABKAIAIAMgAhEDACEEIAEgASgCAEEBajYCAAsgBAtyAgN/AX4jAEEQayIDJAACQCAARQRAQQEhAQwBCyAAKAIIIgEgA0EIahB7IQICfyADKQMIIgRCAlQEQEEAIQJBAQwBCyAAIAAoAgwgBKdqQQJrNgIMIAEgAmohAkEACyEBIAAgAjYCCAsgA0EQaiQAIAELhgMBB38jAEEQayIEJAACQANAQQAhAyAALQAgDQEgACkDGCABKAIAIgIpAyBSDQEgACgCDCIDBEAgAyABENIJIgMNAiAAKAIQIQAMAQsLIAIoAgAhByAEIAAoAhQiCCgCHCIFNgIMQQAhAyAEQQA2AgggASgCBCECIAAoAiQgAkEfakEgbSACIAEtABgiBkH5AEcbIAVFDQBsIQNBACEAIAZB+QBHIQYDQCAEQQxqEM8JIQICQCAAIAgoAkQiBUcEQCAFIAcoAhhIDQELIAZFBEAgASgCHCADQQJ0aiAAQQJ0aiACNgIADAELIAJFDQAgASgCHCADQQJ0aiAAQQFqQSBtQQJ0aiICIAIoAgBBASAAdHI2AgALIAQoAgwiAC0AAEEBRwRAQQAhAwwCCyAAQQFqIQUCQCAALAABIgBBAEgEQCAFIARBCGoQciECIAQoAgghAAwBCyAEIAA2AghBASECCyAEIAIgBWo2AgwgACABKAIESA0AC0GLAiEDCyAEQRBqJAAgAwuRAwEGfyMAQSBrIgQkAAJAAkAgACACEMIBIAJGDQBBkIgEKAIAIAAoAiRuQQFqIAJGDQAgACgCDCgCOEEkahAuRQRAQeUAIQUMAgsgACACIARBH2ogBEEYahDZAyIFDQECQAJAAkAgBC0AHyIGQQFrDgIAAQILQYLDBBAoIQUMAwsgAw0BIAAgBEEQaiAEQRRqIAJBARCMAiIFDQIgBCgCEBBKDAELIAAgAiAEQRBqQQAQqAEiBQ0BQQAgASADGyEHIANFQQF0IQgDQCAAKAIwIAAgBEEMaiAEQRRqIAcgCBCMAiIFBEAgBCgCEBBKDAMLIAQoAgwQSiAEKAIUIgVJBEAgBCgCEBBKQbbDBBAoIQUMAwsgA0EAIAEgBUkbDQALIAAgBCgCECIBIAYgBCgCGCAFIAMQhQYhBSABEEogBQ0BC0EAIQUgAw0AQZCIBCgCACAAKAIkbkECaiEBA0AgASACRiACQQFrIQINACAAIAIQwgEgAkYNAAsgACACNgIwIABBAToAEwsgBEEgaiQAIAULKQAgACgCACABOgAAIAAgAlAEf0EBBSAAKAIAQQFqIAIQbkEBags2AgQLqQICBH8BfiMAQdAAayIGJAAgBkEANgIYIAZCADcDECAGQQA2AgwCQCABQQBMBEBBiwIhBwwBCyAALQAAIAIgASAGQQxqEMsBIAYoAgwiBw0AIAJBADYCBCAGQSBqIAAgARDGBiEHQQBHIQgDQAJAIAcNACAGKAIgRQ0AIAYoAjwhASAGKAI4IQcCQCACKAIERQRAIAcgASADIAQQ1wkiCUEASCAIIAlFcXINASACIAAsAAAgBikDMCIKENQJIAUgCjcDAAsgAiAGQRBqIAcgASAGKAJEIAYoAkgQ1gkiBw0BCyAGQSBqEPMEIQcMAQsLIAIoAgRFBEAgAiAALAAAIAYpAzAiChDUCSAFIAo3AwALIAYoAjgQIyAGKAIQECMLIAZB0ABqJAAgBwucAgEFfyMAQRBrIgckACAHQQA2AgwgASgCBCEJIAEgAyAHQQxqEMsBAkAgBygCDCIGDQAgAyABKAIAIgogASgCBCACIAMQgAQiCGsiBkEATARAQYsCIQYMAQsgCiACIAMQJRogASADNgIEAkAgCUUEQCAAKAIEIQEMAQsgACAAKAIAIAAoAgRqIAisEG4gACgCBGoiATYCBAsgACAAKAIAIAFqIAatEG4gACgCBGoiATYCBCAAKAIAIAFqIAIgCGogBhAlGiAAIAAoAgQgBmoiATYCBEEAIQYgBEUNACAAIAAoAgAgAWogBawQbiAAKAIEaiIBNgIEIAAoAgAgAWogBCAFECUaIAAgACgCBCAFajYCBAsgB0EQaiQAIAYLOAEBfwJAIAJFIABFckUEQCABIAMgASADSBsiBA0BCyABIANrDwsgACACIAQQTSIAIAEgA2sgABsLswEBAn8jAEEQayIGJAAgBkEANgIIIAYgAyAEIAUQ+wQiBzYCDCAHBEAgACAAKAKQAiAHKAIAIAVqa0EUazYCkAILAkACQCAGQQxqIAApA5gCIAGsIAKsIAZBCGoQ4QlFDQAgAyAEIAUgBigCDCIBEIYEIAFHDQAgARAjQQchBAwBCyAGKAIIIgQNACAAIAAoApACIAUgBigCDCgCAGpqQRRqNgKQAkEAIQQLIAZBEGokACAEC8MBAgJ+AX8gACABEIMCIgAEQEEAIQEDQCAAIAFqLQAAIgZBMGtB/wFxQQlLRQRAIARCCn4gBq1CD4N8IQQgAUEBaiEBDAELCyACIAQ3AwBCASEFA0AgACABai0AACICQSBHBEAgAkEtRgRAQn8hBSABQQFqIQELQgAhBANAIAAgAWotAAAiAkEwa0H/AXFBCUtFBEAgBEIKfiACrUIPg3whBCABQQFqIQEMAQsLIAMgBCAFfjcDAAUgAUEBaiEBDAELCwsLSgECfwJAIABFDQAgACgCCCIAKAIAENoJA0AgAEUNASAAKAIEIAAoAiQiAiAAQShqRwRAIAIQIwsgACgCHBAjIAAQIyEADAALAAsL6gICBX8BfiMAQSBrIgMkAAJAIABBJSADQRxqQQAQUSIFDQAgAygCHCIEQQEgAUIBfBBIGiAEQQIgAUKACH9CCoZC/weEEEgaIAJCA35CAn8hAgNAAkAgByEGIAQQQUHkAEcNACADQgA3AxAgBEECIANBCGogA0EQahDZCUEAIQYgAykDECIIQgBXDQBBASEHIAIgCFkNAQsLIAQQOiEFIAZFDQAgA0EANgIQIANBADYCCCAFDQAgAEEmIANBEGpBABBRIgUNACAAQScgA0EIakEAEFEiBQ0AIARBASABEEgaIAMoAhAhAEEAIQYCQANAIAQQQUHkAEcNASAAQQEgBhCVARogAEECIARBABC3ARCVARogAEEDIARBARC3ARCVARogABBBGiAGQQFqIQYgABA6IgVFDQALIAQQOhoMAQsgBBA6IgUNACADKAIIIgBBASABEEgaIAAQQRogABA6IQULIANBIGokACAFCy0BAn8gACgCJEEKIAIQwwEiA2siBGogAToAACAAKAIkIANrQQtqIAIQbhogBAtlAQF/IAEgAiAAIAEQwgEgAiABa2ogACgCKEEFbiICaiACbmprIgJBkIgEKAIAIAAoAiRuQQFqIgMgAUkgAiADSXFrIQIDQCACIgFBAWshAiAAIAEQwgEgAUYgASADRnINAAsgAQthAQF/IwBBEGsiAiQAAkAgASkDCFAEQEEAIQAMAQsgAEERIAJBDGpBABBRIgANACACKAIMIgBBASABKQMIEEgaIABBAiABKQMYEEgaIAAQQRogABA6IQALIAJBEGokACAAC0cBAn8gAEEAIABBAEobIQVBACEAA0AgBCAFRkUEQCAAIAJqIAEgBEECdGo1AgAQbiAAaiEAIARBAWohBAwBCwsgAyAANgIAC84CAQZ/IwBBIGsiBSQAIAMoAgAhCCAEKAJAIQYgBSAEKAIcIgc2AgwgBSAHNgIIIAUgATYCHCACKAIAIQkgBSABNgIYIAVBGGogACAGakEAQQAgAiAFQQxqIgoQpwMaIAUgBSgCGCIGNgIU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aiEKAn8gBCwAASIFQQBIBEAgCiAIQQxqEHIMAQsgCCAFNgIMQQELIAQhBSAKaiEEDAELCwJAIAFFDQAgCSAFIAZqIgFrIgBBAEwNACABQQAgABAnGgsgAiAFNgIAIAMgBjYCACAIQRBqJAALNwEBfyABIAApAxhVBEAgACABQgGGIgE3AxggACgCECABEIEBIgJFBEBBBw8LIAAgAjYCEAtBAAuTAQEBfyMAQRBrIgIkAAJAAkAgAC0A7wFFDQAgASgCOEUNAEEAIQAgAUEANgJUIAFCADcDWEEAIAEoAkggASgCTCABQdAAaiABQdgAaiABQdQAaiACQQ9qEPwEDAELIAEgASgCSEEKEP8EIgANACABIAEoAkggAUHYAGoQeyABKAJIajYCUEEAIQALIAJBEGokACAAC3gBAn8CQCAAKQMYIAJCFHxZBEAgAqchAyAAKAIQIQQMAQsgACgCECACpyIDQQF0QRRqrCICEIEBIgRFBEBBBw8LIAAgAjcDGCAAIAQ2AhALIAQgASADECUaIAAoAhAgA2oiAEIANwAAIABBADYAECAAQgA3AAhBAAuCAQECfwJAIAAoAjQgACgCMCICIAAoAihqQYAgIAAoAiwgAmsiASABQYAgThsiASACEJQJIgINACAAIAAoAjAgAWoiATYCMCAAKAIoIAFqIgFCADcAACABQQA2ABAgAUIANwAIIAAoAjAgACgCLEcNACAAKAI0EOAEIABCADcDMAsgAgswACAAKAIoRQRAQQAPCyAAKAJAIAEgACgCPCIAIAIgACACSBsQTSIBIAAgAmsgARsL7AUCBX8BfiMAQRBrIgQkAAJAAkACQAJ/IAEoAkgiAkUEQCABKAIoDAELIAIgASgCTGoLIgIEQCACIAEoAiggASgCLGpJDQELIAEoAjgiAgRAIAIoAgAhAyABKAIoECNBACEAIAFBADYCKCADRQ0DIAMoAggiBSgCACABKAJAIQAgAygCECICIAEoAkROBEAgABAjIAEgAqxCAYZCAnwQQCIANgJAIABFDQMgASACQQF0QQJqNgJECyAAIAMoAgwgAhAlGkEAIQAgASgCQCACakEAOgAAIAEgAjYCPEEBaiICrBBAIgNFDQIgASADIAUoAgQgAhAlIgM2AkggASACNgIsIAEgAjYCTCABIAM2AiggASABKAI4QQRqNgI4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EkEBaiESIAQhAiAFIQQgBiEFDAELCwJAIAIEQEEBIAIgAkEBTBshBSAGIQNBASECA0AgAiAFRgRAIABB+AVqIQZBACECA0AgAiAJRkUEQCAGIAJB4ABsaiIFIAMoAhggAkECdGooAgAiBDYCUCAFIAQtABAiBDoAPCAFIAAoAgQgBEEGdGooAjA2AgQgAkEBaiECDAELCwJAIAFFIAAvAShBgANxQYACR3INACAALQAvDQAgACAAKAIMIANBgAEgCUEBayIBQf//A3EgAygCGCABQQJ0aigCACAIQQhqEJkFIAAoAgwoAgBHDQAgAEECOgAvCyAAIAAtADAiBkH7AXE6ADACQCAAKAIIIgJFDQAgACADLAAWIgE6AC0CQCAALwEoIgVBgAFxBEAgASACKAIARgRAIABBAjoALwsgACgCECgCMCIGRQ0BIAEgBigCACIBTA0BIAAgAToALQwBCyAAIAMpAwg3A0ggAUEATARAIABBADoALSAJRQ0BIAMoAhggCUEBayIBQQJ0aigCACIGKAIoIgRBgCBxIARBhAJxQYQCRnINASAIQgA3AwggACACIANBgBAgAUH//wNxIAYgCEEIahCZBSAAKAIIIgIoAgBGBEAgACAALQAwQQRyOgAwIAAgCCkDCDcDSAsgAC8BKCEFDAELIAVBA3FFIAlFIAFBAUdycg0AIAAgBkEEcjoAMAsgBUGABHFFIAlFcg0AIAIoAgAgACwALUcNACAIQgA3AwggACACIANBACAJQQFrIgFB//8DcSADKAIYIAFBAnRqKAIAIAhBCGoQmQUgACgCCCgCAEcNACAAIAAtADBBCHI6ADAgACAIKQMINwNICyAAIAMvARA7ATIMAwUgBiACQQV0aiIEIAMgAy4BEiAELgESShshAyACQQFqIQIMAQsACwALIBRB0s8AQQAQJgsgFCgCACAVEC8LIAhBEGokAAs/AQJ/IAEoAjQiAiABQTxqIgNHBEAgACACEC8gAUEDOwEwIAEgAzYCNAsgACABENoKIAFBADYCKCABQQA7ASwLGwEBfyAAKAIABH9BAAVBFUHZFkEAEIABQQELC6wGARN/IwBB4ARrIgMkACAAKAIAIQQgACgCCCEGIAAoAgQiCygCGCEJIAsoAgwhByADQfAAakEAQTgQJxoCQCAEKAIEIAYtABBBBnRqIg4tACxB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IAUoAghBnM8CELoBGgwECyAPEEAiB0UEQEEHIQYMBAsgB0EAIAMQJxoLQQAhAANAIAAgC0cEQCAFKAIYIABBAnRqIAUvARRBAnRqIAcgACACbGo2AgAgAEEBaiEADAELCyAFIAUvARQgCGoiADsBFAwACwALQYomIQZBiiZBjuYAIAUoAghBgc8CELoBGgsgBCABIAUvARRIBH8gBSgCGCABQQJ0aigCAAVBAAs2AgAgBkEIIAYgBS0AFhsgBhshBwsgCkHwAGokACAHCwwAIAAQ8gggACgCMAsMACAAEPIIIAAoAiwLiQQCAn8FfiMAQYABayIDJABBDCEEAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBAWsOFAALCwEDAgsLCwQLBgULCwcLCwsICQsgAiAALQAQNgIADAkLIAIgACgCFDYCAAwICyAAIAIoAgA2AigMBwsgACgCKEEATA0GIAIpAwAgACgCDCADQSBqQeCIBCgCABEAAARAQYoOIQQMCAsgADQCKCIFfEIBfSIGIAYgBYF9IgYgAykDOCIFVw0GIAZCAX0iCCADNAJAIgd8IQkgBSAFIAeBQn+FfCEFA0AgBSAHfCIFIAlZDQcgACAFIAggBSAGUxsiBUHe7gFBARD2CEEBRg0AC0GKBiEEDAcLIABBBCACEPQIDAULIABBECACEPQIDAQLIAMgACgCBCgCEDYCACACQZ/FACADEEY2AgAMAwtBACEEIAAoAgQ0AggQQCIBRQ0DIAAoAgQoAgggARCvCBogAiABNgIADAMLIAIgABDzCDYCAAwBCyABQShHDQFBACEEIAJBADYCACAAKAIkIgBFDQEgACgCACADQgA3AzggA0IFNwMwIANC+wA3AyggA0IANwMgIANBATsBICgCDCADIANBIGo2AhBBDCADQRBqQfiIBCgCABEDAEEASARAQYoeIQQMAgsgAiADLwEgQQJHNgIADAELQQAhBAsgA0GAAWokACAEC5gBAQN/IwBBMGsiAiQAAn8Cf0EBIAAoAggiAy0AHEEBSw0AGkEAIAMtAB0NABogAkIBNwMgIAJBATYCECACQZCIBCgCAEEBaqw3AxggACgCDCACIAJBEGo2AgBBDCACQfiIBCgCABEDAARAIABBkL0EKAIANgIUQYocDAILIAIvARBBAkcLIQRBAAsgASAENgIA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IAasIASsfiELQdy8BCgCACIABEAgABELAAsgCxBjIQBB4LwEKAIAIgYEQCAGEQsACwJAIABFBEBBACEADAELIABBrIMEKAIAEQEArCELC0EAIAMgCRshByAEQYADTwRAIAsgAyALIANBgANqrX+nIgZsrH1CgAF/pyEIDAILIARBgAJPBEAgCyADIAsgA0GAAWqtf6ciBmysfUKAAX+nIQgMAgsgCyADrX+nIQYMAQtBACEGCyACQgA3AswCIAIgADYC4AIgAiAHOwG2AiACIAc7AbQCAn8gAARAQQAhAyAGQQAgBkEAShshCUEAIQQDQCAEIAlHBEAgACADNgIAIAIgADYCzAIgBEEBaiEEIAcgACIDaiEADAELCyACIAA2AtwCIAJCADcC1AJBACEDIAhBACAIQQBKGyEHQQAhBANAIAQgB0cEQCAAIAM2AgAgAiAANgLUAiAEQQFqIQQgACIDQYABaiEADAELCyACQQA2ArACIAIgADYC5AIgAkEBOgC4AiAGIAhqDAELIAJCADcC1AIgAkEAOgC4AiACQQA7AbQCIAJBATYCsAIgAkEANgLkAiACQgA3AtwCQQAhAEEACyEDIAIgADYC6AIgAiADNgK8AkEABUEFCxogAkHoBzYCkAIgAkESNgKMAgsCQCACEKIGIgNB/wFxQQdGBEAgAkEAEIkJGkEAIQIMAQsgA0UNACACQboBOgBhCyABIAI2AgAgBSgCJBCfBgsgBUEwaiQAIAMLtAEAAkAgACADSg0AQdy8BCgCACIABEAgABELAAsjAEEQayIAJABBDCEDAkACQCACRQ0AIAItAABFDQAgASACENQCIgNBAE4NACAAIAI2AgBBASECIAFBAUHYPyAAEM4BDAELIAFBADYCyAMgASABIANBAEEAQQAQggkiAhCLAQsgASACEJ4BGiABKAK4AUUEQCABQQA2AqgCCyAAQRBqJABB4LwEKAIAIgBFDQAgABELAAtBAAsyACMAQRBrIgEkACABIAAoAgQoAgg2AgAgAEH5ECABEEYiAEF/EEwgABAjIAFBEGokAAt0AQJ/IAAoAvQDIQMCfyABQQtMBEAgAUGwnQNqLQAAIQIgAUGknQNqLQAADAELIAFB5ABsQegGayECQeQACyEBAkAgASACaiADTA0AIAMgAmsiAUEASg0AQQAPCyAAKAIAIgAg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A0AgAEEAIANBQGsQARB3CyADQYABaiQACwwAIAAgASACEAYQdwuAAgEEfyMAQSBrIgQkAAJ/IAAgARAIIgNBeEcEQCADEHcMAQsjAEEgayIDJAAgACADQQhqEA8iAgR/QZC9BCACNgIAQQAFQQELIANBIGokAEUEQEF4EHcMAQtBACECA0AgAiAEaiIDIAJB8sEBai0AADoAACACQQ5HIAJBAWohAg0ACwJAIAAEQEEOIQIgACEDA0AgAkEBaiECIANBCUsgA0EKbiEDDQALIAIgBGpBADoAAANAIAQgAkEBayICaiAAQQpuIgNB9gFsIABqQTByOgAAIABBCUsgAyEADQALDAELIANBMDoAACAEQQA6AA8LIAQgARAHEHcLIARBIGokAAsTACAAEAQiAEEAIABBG0cbEPQDCw8AQZx/IAAgAUEAECEQdwsEACMACxAAIwAgAGtBcHEiACQAIAALBgAgACQACwQAQQALiwECAXwCfiACKAI8QQBMBEACQCACKwMYIgMgASACKQMgIgF8IgSnt2VFDQAgAikDECIFuSADoSAFIAF9p7dlBEAgAiACKQMoQgF8NwMoIAIpAzBQBEAgAiACKQMAIAA0AgB8NwMADAILIAIgACsDACACKwMIoDkDCAwBCyACQQE2AjwLIAIgBDcDIAsLLAEBfyAAQQAQRyIBBEAgASABKQMQQgN+uUQAAAAAAADQP6I5AxggABC+BgsLKQEBfyAAQQAQRyIBBEAgASABKQMQuUQAAAAAAADQP6I5AxggABC+BgsLKQEBfyAAQQAQRyIBBEAgASABKQMQuUQAAAAAAADgP6I5AxggABC+BgsLiAECAX4BfAJAAkAgAikDMFAEQCABIAIpAyAiA1EEQAwDCyABIANXDQEgADQCACEDIAJCATcDKCACIAE3AyAgAiADNwMADwsgASACKQMgIgNRBEAMAgsgASADVw0AIAArAwAhBCACQgE3AyggAiABNwMgIAIgBDkDCAsPCyACIAIpAyhCAXw3AygLXAECfwJAIABBABBHIgFFDQAgASgCOCICRQ0AIAJBrwMgARDFCSABKAI4EMQJIAEoAjgQ6gEgASkDKEIBUg0AIAEpAzBQBEAgACABKQMAEGAPCyAAIAErAwgQWAsLIAECfEF/QQEgACsDACICIAErAwAiA2MbQQAgAiADYhsL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AkACQAJAAkACQCACDgQAAQIDBAsgASAAKAIEQX9BfxA8DAQLIAEgACgCECAAKAIUQX8QPAwDCyABIAAoAhgQdgwCCyABIAAoAhwQdgwBCyABIAAoAiAQdgtBAAsIACAAKAIQRQudAQEBfyAAKAIAIQMgABDABkEBIQICQCABQQFHDQAgBCgCABArIQUgACAEKAIAEEMiAUEBaqwQQCICNgIEIAJFBEBBBw8LIAFBAEoEfyACIAUgARAlGiAAKAIEBSACCyABakEAOgAAIAMoAhAgACgCBCABIABBCGogAygCDCgCDBEGACICDQAgACgCCCADKAIQNgIAIAAQzAkhAgsgAgsNACAAEMAGIAAQI0EACx4AQSQQbSIARQRAQQcPCyABIABBAEEkECc2AgBBAAsZACAAKAIQIAAoAgwoAggRAQAaIAAQI0EAC5EBAQJ/QQAhACABKAIAIgJBACACQQBKGyEDAkADQCAAIANHBEACQCABKAIEIABBDGxqIgItAAVFDQAgAigCAA0AIAItAARBAkcNACABQQE2AhQgASgCECAAQQN0aiIAQQE6AAQgAEEBNgIAIAFCgICAgICAgPg/NwMoDAMLIABBAWohAAwBCwsgAUEANgIUC0EAC8IDAQh/IwBBEGsiBiQAIAZBADYCDCAAQcbFARDlAyIARQRAQbftACEJAkACQCACQQNrIghFDQAgA0EMaiEKQQAhAyAIQQAgCEEAShshC0EAIQADQCAAIAtGRQRAIAogAEECdGooAgAQPyADakEBaiEDIABBAWohAAwBCwsgAyAIQQJ0IgBqrRBAIgdFBEBBACEHQQchAAwCCyAAIAdqIQNBACEAA0AgACALRkUEQCAKIABBAnQiCGoiDCgCABA/IQ0gByAIaiADNgIAIAMgDCgCACANQQFqIgMQJSIIEK0DIABBAWohACADIAhqIQMMAQsLIAJBBEgNACAHKAIAIQkLQQEhACABIAkgCRA/QQFqEPsEIgNFBEAgBiAJNgIAIAVB5TwgBhDEAQwBCwJAAkAgAkEEa0EAIAJBBEoiABsgB0EEakEAIAAbIAZBDGogAygCBBEDACIABEAgBigCDCECDAELQRQQbSEBIAYoAgwhAiABDQFBByEACyACRQ0BIAIgAygCCBEBABoMAQsgAUIANwIAIAEgAjYCECABIAM2AgxBACEA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CAsgA0EQaiQAIAILzxICF38MfiMAQdABayIDJAACQCABQQdOBEAgAEG9zwFBfxBMDAELIABB1xogAigCACADQQxqEPIEDQBBDyEOQX8hDEHbqQEhE0HhqQEhFUHXqQEhFgJAAkACQAJAAkACQCABQQJrDgUEAwIBAAULIAIoAhQQNqchDgsgAigCEBA2pyEMCyACKAIMECshEwsgAigCCBArIRULIAIoAgQQKyEWCyATRSAVRXJBASAWGwRAIAAQWgwBCyAORQRAIABB3u4BQX9BABA8DAELIAAgAygCDCIKEPkEDQAgCigCACEYIANBADYCgAEgA0IANwN4IAooAhBFBEAgAEHe7gFBAEEAEDwMAQtBwABBQCAOIA5BQEwbIgEgAUHAAE4bIgFBAWshGUEAIAFrIRRBASENA0AgFCEPIA5BAE4EQCANIBlqIA1tIQ8LQQAhEEIAIR5CACEdAkADQCANIBBHBEAgA0EQaiAQQRhsaiIJQgA3AwAgCUIANwMQIAlCADcDCEEAIQtBfyERA0ACQAJAIBgoAhggC0oEQCALIAxHIAxBAE5xDQIgCiADQcgBakEAEPEEIgQNBiADIAMoAsgBQShsrRDvASIBNgKYASABRQRAQQchBAwHCyADIA82ApABIAMgCzYCjAEgA0F/NgKcASADIAMoAsgBNgKUASADIAo2AogBIAooAhBB7wAgA0GIAWoQvwIhBCADKAKYASEHIAQEQEIAIR9BACEBQQAhEkIAISBBACEIDAILQQAhBiADKALIASIBQQAgAUEAShshAkEAIQEDQCABIAJGBEBBfyEBQgAhG0IAIRwFQgEgAUE/ca2GQgAgByABQShsaigCEBsgHoQhHiABQQFqIQEMAQsLA0AgASEIIBwhICAbIR8gBiESA0ACQAJAIAMoApwBQQBOBEBBACEBIAMoApQBIgJBACACQQBKGyEGQf////8HIQUgAygCmAEhBwNAIAEgBkYNAiAHIAFBKGxqIhcoAhAEQCAXKQMIIhunIAUgGyAFrFMbIQULIAFBAWohAQwACwALQQAhASADQQA2ApwBA0AgASADKAKUASICTg0CIAMoApgBIAFBKGxqIgJBEGogAkEIaiADKAKQARDFBiABQQFqIQEMAAsACyAFQf////8HRgRAIAshAQwFCyADIAUgAygCkAFrQQFqIgY2ApwBIAVBAWohBUEAIQEDQCABIAJODQEgAygCmAEgAUEobGoiAkEQaiACQQhqIAUQxQYgAkEgaiACQRhqIAYQxQYgAUEBaiEBIAMoApQBIQIMAAsACyADKAKcASIGrCEhQQAhB0IAIRxCACEbQQAhAQNAAkAgAiAHSgRAIAMoApgBIAdBKGxqIgUoAiAiF0UNASADIBc2AswBIAMgBSkDGCIaNwOgAUIBIAdBP3GthiIjIBuEISIDQAJAIBogIVMgGiADKAKQASAGaqxZckUEQCAbIB2EICODIRtCASAaICF9hiEkIAUoAgAiAkEAIAJBAEobrSElQgAhGgNAIBogJVFFBEAgJCAaiCAchCEcIBpCAXwhGgwBCwtB6AdBASAbUBsgAWohASADKALMAS0AAEECTw0BICIhGwsgAygClAEhAgwDCyADQcwBaiADQaABahD/AyADKQOgASEaICIhGwwACwALIAEgCEwNAgwDCyAHQQFqIQcMAAsACwALAAsgEEEBaiEQIAkpAwggHYQhHQwECyAHECMgBA0EIAggEUwNACAJICA3AxAgCSAfNwMIIAkgEjYCBCAJIAE2AgAgCCERCyALQQFqIQsMAAsACwsgDUEERyAdIB5ScUUEQCANQQFrIQdBACEEQQAhBgNAIAYgDU8gBHINAiAKKAIAIQsgA0EANgK8ASADQRBqIAZBGGxqIgEpAxAhGiABKAIEIQUgCigCDCABKAIAQQFqIgEQgwIhCCAKKAIMIQICQCAIRQRAQQdBACACIAEQ9gJBBUcbIQQMAQsgAiABEL8BIREgCygCJCIBKAIAIRIgASAKKAIUIAggESADQbgBahDCAiIEDQBBACECIAMoArgBIRRBACEMA0BBACEEA0ACQCAEDQAgA0F/NgKwASADQQA2AqwBIANBADYCqAEgFCADQbQBaiADQbABaiADQawBaiADQagBaiADQbwBaiASKAIUEQoAIgQEQCAEQeUARw0BIANB+ABqIAggDGpBfxCVAiEEDAELQQAhBCADKAK8ASIBIAVIDQECQCACDQBCACEcAkACQAJAIBpQBEBCACEaDAELIAggAygCrAEiBGohCSAKKAIUIQ4DQCAcIhtCAXwhHEEAIQEgGiAbiEIBg1ANAAsDQCABIgJBAWohASAaIA8gAkF/c2qtiEIBg1ANAAsgG6cgAmsiAUECbSABQQJIDQAgA0EANgKIASALKAIkIhAoAgAhASAQIA4gCSARIARrIANBoAFqEMICIgQNASAPaiEJQQAhBCADKAKgASECAkADQCAERQRAIAkgAygCiAFMBEAgAiABKAIQEQEAGgwDBSADQQA2AsgBIANBADYCxAEgA0EANgLAASACIANBzAFqIANByAFqIANBxAFqIANBwAFqIANBiAFqIAEoAhQRCgAhBAwCCwALCyACIAEoAhARAQAaIARB5QBHDQILIAMoAogBIARBAEcgD2tqIgFBACABQQBKGyIBIAVqIQUgGiABrYghGgsCfyAGRSAFQQBMcUUEQCADQfgAaiATQX8QlQIMAQsgAygCrAEiAUUNAiADQfgAaiAIIAEQlQILIgRFDQELQQEhAgwDCyADKAK8ASIBIAVODQBBASECDAMLIAUgD2ogAUwEQEEAIQQgBiAHRw0BIANB+ABqIBNBfxCVAiEEBUEAIQQgASAFSgRAIANB+ABqIAggDGogAygCrAEgDGsQlQIhBAsgBEIBIAEgBWuthiAagyIbUHJFBEAgA0H4AGogFkF/EJUCIQQLAkAgBA0AIANB+ABqIgIgCCADKAKsASIBaiADKAKoASABaxCVAiIEIBtQcg0AIAIgFUF/EJUCIQQLQQEhAiADKAKoASEMDAILCwsLIBQgEigCEBEBABoLIAZBAWohBgwACwALIA1BAWohDQwBCwsgGBDuASAEBEAgACAEEMkBIAMoAngQIwwBCyAAIAMoAnhBf0EBEDwLIANB0AFqJAALrQEBAX8jAEEgayIDJAAgA0EANgIcAkAgBAJ/IAAgA0EcahD1CSIERSAEQYsCRnJFBEAgAC0A7AEhBSADIAQQ5QI2AgwgAyACNgIIIAMgATYCBCADQQRBAyAFGzYCAEGJPCADEEYMAQsgAygCHA0BIAAtAOwBIQQgAyACNgIYIAMgATYCFCADQQRBAyAEGzYCEEHWMSADQRBqEEYLNgIACyAAEO4BIANBIGokAEEACzIBAn8DQCABQQVGBEBBAA8LIAFBAnQhAiABQQFqIQEgACACQbC6A2ooAgAQXw0AC0EBCxUAIAEgACgCgAJIBEAgABD3BAtBAAsMACAAIAE2AoACQQALngEBA38jAEEQayIDJAACQCAALQDwAQ0AIAAoAogCKAIIQQBKBEAgACgC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RyICBEAgAikDECEDIAIoAgQhBkEAIQFBASEAAkADQCADIACtIgRYDQEgACAGaiIILQAAIgdBLEcgAXIgBXIEQAJAAkAgB0HcAEcEQCAHQSJHDQEgAUUhAQwCCyAAQQFqIQAMAQsgAQRAQQEhAQwBCyAFIAdB3wFxIgFB2wBGaiABQd0ARmshBUEAIQELIABBAWohAAwBCwsgAiADIAR9IgM3AxAgBkEBaiAIQQFqIAOnQQFrEIQBGiAGIAIoAhBqQQA6AAAPCyACQgE3AxALCwkAIABBABCzCgsJACAAQQEQswoLcgEBfyAAQYABEEciAQRAAkACQCABKAIERQRAIAEgADYCACABQQE7ARggAUIANwMQIAFC5AA3AwggASABQRpqNgIEQdsAIQMMAQtBLCEDIAEpAxBCAlQNAQsgASADEGoLIAEgADYCACABIAIoAgAQiwQLC6kCAgJ/AX4jAEFAaiIEJABBASEDAkACQCABQQJGBEAgAigCBBA2IgVCAX1CDlYNASAFpyEDCwJAAkACQCACKAIAIgEvARBBP3FB0PIBai0AAEEEaw4CAAQBCyABEIoERQ0AIANBBHEEQEEBIQEMAgsgA0EIcUUEQEEAIQEMAgsgBEEQakEAQTAQJxogBCACKAIAEJ0BNgIIIAQgAigCABBDIgE2AgwgBEEIakEAIAFBARCLBUUhAQwBC0EAIQEgA0EDcUUNACAAIAIoAgBBAhDFAiICBEACQCACLQAjBEAgABBaDAELIAItACINACADQQJxRQRAIAItACUNAQtBASEBCyACEJgBDAELIAAQWgsgACABEHYMAQsgAEH5tQFBfxBMCyAEQUBrJAALmAEBAn8gACACKAIAQQAQxQIiBARAAkACQAJAIAFBAkcNACACKAIEECsiAUUNAiABLQAAQSRHDQEgBEEAIAFBAWpBABDwASIDQX1JDQACQCADQQNqDgICAwALIABBoZsBQX8QTAwCCyAAIAQoAgAgA2otAABBD3FBAnRBkJsDaigCAEF/QQAQPAwBCyAAIAEQjQQLIAQQmAELCygAIAFBAEoEQCABQQFxRQRAIABBvfMAELUKDwsgACABIAJBAhC0CgsLaQAjAEGAAWsiASQAIAFBATsBGCABQgA3AxAgAULkADcDCCABIAFBGmo2AgQgASAANgIAIAEgAigCABCLBCAB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IAEpAoQBNwMQIAEgASsDkAE5AxggAUEAOwE8IAFBADYCOCABQoCAgIDADDcCMCABQgA3AiggASADNgIAIAEgBDYCBCABIAI2AgggASABKAKAAUEBazYCDCABQShqIgJBlOMAIAEQNyAAIAIQkQULIAFBoAFqJAALuQoDBH8BfgF8IwBB8AJrIgMkAAJAIAFFDQAgAigCABArIgZFDQAgACABQQFrIAJBBGogA0HAAmoiAhDGAg0AIAAoAgAoAhQoAnghASADQQA7AbwCIANBADYCuAIgAyABNgK0AiADQQA2ArACIANCADcCqAIgAhB8IAIQgAJBACECQQAhAQNAAkAgASAGai0AACIFQSVHBEAgBQ0BIAEgAksEQCADQagCaiACIAZqIAEgAmsQPgsgACADQagCahCRBQwDCyABIAJLBEAgA0GoAmogAiAGaiABIAJrED4LIAFBAmohAgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAYgAUEBaiIBai0AACIFQcYAaw4yARACAwUQEAcQEAgQCQsMEBAEEA4QEBAQEBAQEBAQEREAEBAQBAIDBhAQCBAQChANEA0PCyADRB1aZDvf/01AIAMrA+ACIgggCEQdWmQ73/9NQGQbOQMQIANBqAJqQa/jACADQRBqEDcMEgsgAyADKALIAjYCICADIAMpAswCNwIkIANBqAJqQZKBASADQSBqEDcMEQsgAyADKALUAjYCMCADQagCakGcgQFBoYEBIAVByABGGyADQTBqEDcMEAsgAyADKALUAiIEQQxrIAQgBEEMShsiBEEMIAQbNgJAIANBqAJqQZyBAUGhgQEgBUHJAEYbIANBQGsQNwwPCyADQfgBaiIEIANBwAJqQTAQJRogA0KBgICAEDcChAIgA0EAOgCgAiAEEHwgAykDwAJCgNzMFHwiByADKQP4AX1CgLiZKX+nIQQgBUHXAEYEQCADIAQgB0KAuJkpf0IHgadrQQdqQQdtNgJQIANBqAJqQZyBASADQdAAahA3DA8LIAMgBEEBajYCYCADQagCakH+gAEgA0HgAGoQNwwOCyADIAMpA8ACuUQAAAAAcJmUQaM5A3AgA0GoAmpBlOIAIANB8ABqEDcMDQsgAyADKALMAjYCgAEgA0GoAmpBnIEBIANBgAFqEDcMDAsgAyAD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AnStEIEBIgFFDQELIAMoAhgiAEEASgRAIABBAnQgAWpBBGsgBDYCAAsgBSABNgIADAELIANBBxCWAwsgAyADKAIYQQFqNgIYIAIoAgAQKyEAIAIoAgAQQyEBIABFDQAgAyAAIAEQPgsLPgAgAEEIEEchAAJAIAEEQELVqtWq1arVqtUAIAIoAgAzARCIQgGDUA0BCyAARQ0AIAAgACkDAEIBfTcDAAsLGQAgACAAQQAQRyIABH4gACkDAAVCAAsQYAs+ACAAQQgQRyEAAkAgAQRAQtWq1arVqtWq1QAgAigCADMBEIhCAYNQDQELIABFDQAgACAAKQMAQgF8NwMACwt+AwF/An4DfAJAIABBABBHIgFFDQAgASkDGCICQgBXDQAgAAJ8IAEtACAEQCABKwMAIgQgASsDCCIFoCIGIAYgBCAFvSIDQv////////8Hg1AbIANCgICAgICAgPj/AINCgICAgICAgPj/AFIbDAELIAEpAxC5CyACuqMQWAsLcwIDfAF+IAACfEQAAAAAAAAAACAAQQAQRyIARQ0AGiAALQAgBEAgACsDACIBIAArAwgiAqAiAyADIAEgAr0iBEL/////////B4NQGyAEQoCAgICAgID4/wCDQoCAgICAgID4/wBSGwwBCyAAKQMQuQsQWAumAQIBfgF/IABBKBBHIgBFIAIoAgAQ5AIiBEEFRnJFBEAgACAAKQMYQgF9NwMYIAAtACBFBEAgAigCABA2IQMgACAAKQMQIAN9NwMQDwsgAigCACEBIARBAUYEQCABEDYiA0KAgICAgICAgIB/UgRAIABCACADfRCQBQ8LIABC////////////ABCQBSAARAAAAAAAAPA/ELADDwsgACABEEmaELADCwuRAQMBfwJ8AX4CQCAAQQAQRyIBRQ0AIAEpAxhCAFcNACABLQAgBEAgAS0AIQRAIABBjQ1BfxBMDwsgASsDACECIAErAwgiA70iBEKAgICAgICA+P8Ag0KAgICAgICA+P8AUSAEQv////////8Hg0IAUnFFBEAgACADIAKgEFgPCyAAIAIQWA8LIAAgASkDEBBgCwvlAQEBfyMAQRBrIgEkAAJAIABBKBBHIgBFIAIoAgAQ5AIiA0EFRnINACAAIAApAxhCAXw3AxggAC0AIEUEQCADQQFHBEAgACAAKQMQEMUKIABBAToA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A2oMAQsgASADQT9xQYABcjoAAyABIANBEnZB8AFyOgAAIAEgA0EGdkE/cUGAAXI6AAIgASADQQx2QT9xQYABcjoAASABQQRqCyEBIARBAWohBAwBCwsgAUEAOgAAIAAgBSABIAVrrEEBEL0CDwsgABBaCzwAIwBBEGsiASQAIAEgAigCABArIgI2AgwCQCACRQ0AIAItAABFDQAgACABQQxqEKcBEHYLIAFBEGokAAulAQEDfyMAQTBrIgMkAAJAIAFBAEwNACAAKAIAKAIUIQQgAigCABArIgVFDQAgA0EANgIoIAMgAkEEajYCLCADIAFBAWs2AiQgBCgCeCEBIANBgAQ7ASAgA0EANgIcIAMgATYCGCADIAQ2AgwgA0IANwIQIAMgA0EkajYCACADQQxqIgIgBSADEDcgAygCHCEBIAAgAhC7ASABQQUQPAsgA0EwaiQAC7MDAgd/An5BASEDQqrVqtWq1arVqn8gAigCACIBMwEQIgqIQqrVqtWq1arVqn8gAigCBDMBECILiISnQQFxRQRAIAEQQyEEAkACQCACKAIEEEMiBkEATARAQQAhAgwBCwJAAkACQAJAAkACQAJ/QoGAhICAgMAAIApCP4MiCohCgYCEgICAwAAgC0I/gyILiIOnIghBAXEEQCACKAIAEJ0BIQEgAigCBBCdAQwBCyACKAIAIQFC/v/7////v38gCohCAYNQQv7/+////79/IAuIQgGDUHINASABECshASACKAIEECsLIgcNAwwBCyABEO4DIgUQKyIBDQELQQAhAgwDCyAFEEMhBCACKAIEEO4DIgIQKyIHRQ0CIAIQQyEGDAELIARFBEBBACECDAELQQAhAiABRQ0BCyAHLQAAIQkDQCAEIAZIBEBBACEDDAMLAkAgAS0AACAJRw0AIAEgByAGEE0NAAwDCyADQQFqIQMDQCABQQFqIQEgBEEBayEEIAhBAXENASABLQAAQcABcUGAAUYNAAsMAAsACyAAEFoMAQsgACADEHYLIAUQkAEgAhCQAQsLeAACQAJAAkACQCACKAIAIgEvARBBP3FB0PIBai0AAEEBaw4EAQECAAMLIAAgARBDEHYPCyAAKAIAKAIULQBUIQIgACABEEOsIAJBAUuthhBgDwsgAS0AEkEBTQRAIAAgARBDEHYPCyAAIAFBAhCvCRB2DwsgABBXC5IBAQF/AkACQAJAAkAgAigCACIBLwEQQT9xQdDyAWotAABBAWsOBAAAAQACCyAAIAEQQxB2DwsgARArIgFFDQEgASECA0AgAi0AACIDBEAgAkEBaiECIANBwAFJDQEDQCACLQAAQcABcUGAAUcNAiABQQFqIQEgAkEBaiECDAALAAsLIAAgAiABaxB2DwsgABBXCwsiAEEAIQEgACACKAIAIgItABFBCHEEfyACLQATBUEACxB2CygAIAAgAigCAC8BEEE/cUHQ8gFqLQAAQQJ0QcyUA2ooAgBBf0EAEDwLCQAgAEEBEMcKCwkAIABBABDHCguwAQECfyACKAIAIQICQAJAIABBKBBHIgFFDQAgAS8BECEDQqrVqtWq1arVqn8gAjMBEIhCAYNQRQRAIANFDQEMAgsgAwRAIAAoAgQoAgghAyABIAIgACgCDCgCaCAAKAIQQRRsakEEaygCABCMAyIEQQBOIARBAEwgAxtFBEAgASACEOwDGg8LDAILIAEgACgCACgCFDYCFCABIAIQ7AMaCw8LIABBAToAGSAAQX82AhQLvgEBBX8CQEKq1arVqtWq1ap/IAIoAgAzARCIp0EBcQ0AQX9BACAAKAIEKAIIGyEEIAAoAgwoAmggACgCEEEUbGpBBGsoAgAhBUEBIAEgAUEBTBshBkEBIQEDQCABIAZHBEBCqtWq1arVqtWqfyACIAFBAnRqKAIAIgczARCIp0EBcQ0CIAMgASACIANBAnRqKAIAIAcgBRCMAyAEc0EASBshAyABQQFqIQEMAQsLIAAgAiADQQJ0aigCABDpAQsLugQBCH8CQEKq1arVqtWq1ap/IAIoAgAiAzMBEIinQQFxDQAgAxArIghFDQAgAigCABBDIQYCQAJAAkAgAUEBRgRAQciUAyEKQcyUAyEHQQEhBAwBCyACKAIEECsiA0UNAyADIQIDQCACLQAAIgcEQCACQQFqIgUhAiAHQcABTwRAA0AgBSICQQFqIQUgAi0AAEHAAXFBgAFGDQALCyAEQQFqIQQMAQsLIARFDQEgACAErUIDhhDxAiIHRQ0DIAcgBEECdGohCkEAIQQDQCADLQAABEAgByAEQQJ0IglqIAM2AgAgA0EBaiIFIQIgAy0AAEHAAU8EQANAIAUiAkEBaiEFIAItAABBwAFxQYABRg0ACwsgCSAKaiACIANrNgIAIARBAWohBCACIQMMAQsLIARFDQELAkAgACgCBCgCCCIDQQFxRSAGRXINAANAQQAhAkEAIQUDQAJAIAIgBEYNACAGIAogAkECdCIJaigCACIFTwRAIAggByAJaigCACAFEE1FDQELIAJBAWohAgwBCwsgAiAETw0BIAUgCGohCCAGIAVrIgYNAAtBACEGCwJAIANBAnFFIAZFckUEQANAIAYhA0EAIQIDQCACIARGDQMCQCAKIAJBAnQiCWooAgAiBSADTQRAIAggAyAFayIGaiAHIAlqKAIAIAUQTUUNAQsgAkEBaiECDAELC0EAIQMgBg0ADAILAAsgBiEDCyABQQFGDQEgBxAjDAELIAYhAwsgACAIIANBfxA8CwsuAEEAIQEgACACKAIAEDanIgJBKU0EfyACQQJ0QdC7A2ooAgAFQQALQX9BABA8C38BAX8gAigCABArIgEEQCAAAn8gAUEAQQcgAUG2jgFBBxBEG2oiAhAtIQFBACEAA0ACQCAAQSpHBH8gAiAAQQJ0QdC7A2ooAgAiAyABEEQNASABIANqLQAAQbDzAWotAABBxgBxDQFBAQVBAAsMAgsgAEEBaiEADAALAAsQdgsLDQAgAEGACEF/QQAQPAvjAQICfwN+IwBBMGsiASQAIAIoAgAQnQEiAygCICEEQQAhAiABQQA7ASwgAUEANgIoIAFBADYCICABQgA3AhggASAEQeQAbEHkAGo2AiQgASADQQhBECADLQAkG2opAwA3AxAgAUEYakHMDiABQRBqEDcDQCACIAMoAiBORQRAIAFCAkIBIAMpAxAiBUIKfiADKAIoIAJBA3RqKQMAIgZCAXwiB0ILflYbIAUgBnwgB4AiBSAFQgJRGzcDACABQRhqQcsOIAEQNyACQQFqIQIMAQsLIAAgAUEYahCRBSABQTBqJAALswECAX4CfyACKAIAEJ0BIQEgAigCBBA2IQMgASABKQMQUAR+QgEFIAEoAhwiBCADpyICIAIgBEgbIQQDQCACIARGRQRAIAEoAiggAkEDdGoiBSAFKQMAQgF8NwMAIAJBAWohAgwBCwsgASkDEEIBfAsiAzcDEAJAIAEoAhgiAkUNACADIAKsIAEtACQiAq1C/wGDQgF8flgNACABIAJBAWo6ACQgACABKAIoKQMAQgBSEHYLCwsAIAAoAgAgABAvC5YBAgJ+An8gACgCACgCFCEFIAIoAgAQNiEDIAIoAgQQNiEEIAUgA6ciBkEDdEEwaqwQOSIBRQRAIAAQWg8LIAEgBTYCACACKAIIEDYhAyABQgA3AxAgASADNwMIIAIoAgwQNiEDIAEgAUEwajYCKCABQQA6ACQgASAEPgIgIAEgBjYCHCABIAM+AhggACABQTBB2wAQ2QELnAIBBn8jAEGQAWsiASQAIAIoAgAQKyEDQQAhAiAAKAIAKAIUIgUoAhQiBEEAIARBAEobIQcgA0He7gEgAxshBgJAAkADQCACIAdGBEBBicAAIQIMAgsCQCAFKAIQIgggAkEEdGoiAygCBCIEBEAgBSACIAYQuAQNAQsgAkEBaiECDAELCyACQQJJBEBByjUhAgwBC0HB/QAhAiAELQAIDQAgBCgCEA0AIAgoAhxBMGohAgNAIAIoAgAiAgRAIAIoAggiACgCGCADKAIMRw0BIAAgACgCFDYCGAwBCwsgBBCUAiADQQA2AgwgA0EANgIEIAUQ6gYMAQsgASAGNgIAIABBgAEgAUEQaiACIAEQswFBfxBMCyABQZABaiQAC40JAQd/IwBBQGoiAyQAIAAoAgAoAhQhASADQQA2AjwgA0EANgI4IANBADYCMCACKAIAECsiBEHe7gEgBBshCCACKAIEECshAgJAAkACQAJAAkACQAJAAkACQCABLQCyAUEEcQRAIANBADYCNCADQeiMARD4BCICNgIsIAJFDQkgAkGMjAMgASADQTRqQQBBgAIQ4QMiAg0IIAEgAygCNCICENgEIgUEQCABKAIQIAEtALABQQR0aiIEKAIEIgYEQCAGEJQCCyAEIAU2AgwgBCACNgIEIAFBADoAXwwCCyACEJQCQQchAgwICwJAIAMCfyABKAIUIgQgASgClAEiBUECakgEQCACQd7uASACGyEFQQAhAiAEQQAgBEEAShshBgNAIAIgBkYNAyABIAIgBRC4BCACQQFqIQJFDQALIAMgBTYCECABQfjoACADQRBqEDgMAQsgAyAFNgIgIAFB1YQBIANBIGoQOAsiBDYCMEEAIQIMBQsCQCABKAIQIgIgAUHMA2pGBEAgAUIwEFMiAkUNCiACIAEoAhAiBCkCADcCACACIAQpAhg3AhggAiAEKQIQNwIQIAIgBCkCCDcCCAwBCyABIAIgBEEEdEEQaq0QnAEiAkUNCQsgASACNgIQIAIgASgCFEEEdGoiBEIANwIAIARCADcCCCADIAEoAjw2AjQgASgCACgCECAIIANBNGogA0EsaiADQTxqIANBOGoQ/wgiAgRAIAJBB0YEQCABEE4LIAAgAygCOCIAQX8QTCAAECMMCQsgAyADKAI0QYACciICNgI0IAMoAiwgAygCPCIHIAEgBEEEakEAIAIQ4QMhAiABIAEoAhRBAWo2AhQgBCABIAUQWTYCACABQQA6AF8gAkETRg0BIAINAiAEKAIEIQILIAQgASACENgEIgU2AgwCQCAFRQRAQQchAkEAIQYMAQtBACECQQEhBiAFLQBMRQ0AIAUtAE0gAS0AVEYNAEEAIQYgAyABQfHpAEEAEDg2AjBBASECCyAEKAIEIgUoAgQiCSAFKAIANgIEIAkoAgAgAS0AWRCkBxogBCgCBCABKAIQKAIEQX8QrQUQrQUaIAQoAgQgASgCIEE4cUEDchDtBSAEQQM6AAggBkUNAkEAQQcgBCgCABshAgwCCyADIAFB6f8AQQAQODYCMEEBIQILIARBAzoACAsgBxCfBiACRQRAIAEQ5gEgAUEAOgCwASABIAEoAhhBb3E2AhggAS0AsgFBBHENBSABIANBMGoQngYiAkUNBQsgAS0AsgFBBHEEQCADKAIwIQQMAQsgASgCECABKAIUQQFrIgRBBHRqKAIEIgUEQCAFEJQCIAEoAhAgBEEEdGoiBUEANgIMIAVBADYCBAsgARCbAiABIAQ2AhQgAwJ/IAJBihhHIAJBB0dxRQRAIAEQTiABIAMoAjAQKSABQf4IQQAQOAwBCyADKAIwIgQNAiADIAg2AgAgAUHtPyADEDgLIgQ2AjALIARFDQELIAAgBEF/EEwgASADKAIwECkLIAJFDQELIAAgAhDJAQsgA0FAayQACzoAAkAgAS0AAEGnAUcNACABLgEgIgFBAEgNACAAIAAvARQgACgCGCgCBCABQQxsai8BCnI7ARQLQQALQgACQCABLQAAQacBRw0AIAAgAS4BICIBQQBIBH9BAgUgACgCGCABQQJ0aigCAEEASA0BQQELIAAvARRyOwEUC0EACwIAC0MBAn8CQCABLQAAQacBRw0AIAEoAhwgACgCGCIDKAIERw0AIAMoAgAgAS4BIBD5AUEATg0AIABBATsBFEECIQILIAIL7QEBBH8gACgCGCIDKAIAIQICQAJAAkAgAS0AAEGnAWsOAwABAAELIAEoAhwgAygCBEcNASACLwE0IQQgAigCBCECQQAhAANAIAAgBEcEQCAAQQF0IQUgAEEBaiEAIAIgBWovAQAgAS8BIEcNAQwDCwsgA0EBOgAJQQIPCyACLQA4QRBxRQ0AIAMoAgQhBUEAIQACQANAIAAgAi8BNE8NAQJAIAIoAgQgAEEBdGovAQBB/v8DRgRAQQAgASACKAIoIABBBHRqKAIIIAUQZEUNAQsgAEEBaiEADAELC0EBIQQgA0EBOgAICyAEDwtBAAssAQF/A0AgASgCACICBEAgASACKAIUNgIAIAAgAigCABAwIAAgAhAvDAELCwuCAQEFfyAAKAIYIgVBCGohBgJAA0AgBSgCACACSgRAQQAgASAGIAJBBHRqKAIAIgNBfxBkQQFNBEBBASEEIAAoAgAgAxCeAiIDRQ0DIAMoAgxBD0YNAwsgAkEBaiECDAELCyABLQAFQRBxBEAgAEEAOwEUQQIPCyAAIAEQlgshBAsgBAuBBAEGfyABLQAAIQQgACgCACEFAkACQAJAIAAoAhgiAygCEEUNACAEQacBRw0BQQAhACADKAIEIgcoAgAiBkEAIAZBAEobIQIgB0EIaiEHA0ACQCAAIAJHBH8gASgCHCAHIABBBnRqKAIoRw0BIAAFIAILIAZGDQMMAgsgAEEBaiEADAALAAsCQAJAAkAgBEGnAWsOBgICAwMDAAELIAEtAAdBAXFFDQIgAyECA0AgAigCACIARQ0CIABBJGohAkEBIQQgASgCLCAARw0ACwwDCyAEQbMBRw0BC0ECIQQgBSgCACIALQBXDQECfwJAAkAgAygCCCICBH9BACEAA0AgAigCACAASgRAQQAgAiAAQQR0aigCCCABQX8QZEUNBCAAQQFqIQAgAygCCCECDAELCyAFKAIABSAACyABQQAQNSIARQ0AIAAtAABBqAFHDQAgAEGsAToAAAsgAyAFIAMoAgggABBVIgI2AghBfyEAQQEMAQsgAygCCCECQQALIQYgAgRAIAEgASgCBCICQYCAgMAAcjYCBCAFKAIAIAEQ1QEgAUEAQTQQJyIBQacBOgAAIAEgBgR/IAMoAggoAgBBAWsFIAALOwEgIAEgAygCACgCMDYCHCADKAIMIQAgASACQYAEcTYCBCABIAA2AiwLIAUoAgAtAFcNAQtBACEECyAECzABAn8gASAAKAIYIgIoAhAiA0YEQEEADwsgAiABNgIQIAAgARBmGiACIAM2AhBBAQuFBwEHfyMAQUBqIgckACAAKAIYIgIoAgghBiACKAIEIQMgAigCACEFAkACQAJAAkACQAJAAkAgAS0AACIEQacBaw4DAQQBAAsgBEGzAUYNACACLQAaQQJxRQ0BIAUoAkgiAkUNAQNAIAJFDQICQCACKAIEIgBBAE4EQEEAIAEgAigCACAAEGRFDQELIAIoAhQhAgwBCwsgAS0AB0EDcQ0BQQAhACADKAIAIgRBACAEQQBKGyEEA0AgACAERg0CIABBAWohACADKAIwIAIoAgRHDQALIAEoAigNAUECIQQgBSgCJA0FIAdBDGoiAEEAQTQQJxogB0GpAToADCAHIAIoAgg2AiggByACKAIMOwEsIAUgBiAAENQKIAUoAiQNBSAGKAIUIAcuAS4iAEEEdGogATYCBCABIAA7ASIgASAGNgIoDAQLIAMNAQtBACEEDAMLQQAhBCADKAIAIgBBACAAQQBKGyEIIANBCGohAEEAIQIDQCACIAhGDQMgASgCHCAAKAIoRgRAIAUgBiABENQKDAQFIABBQGshACACQQFqIQIMAQsACwALQQAhBCACLQAaQQJxDQEgACgCECABLQACRw0BIAEoAigNASAGQSRqIQMgBigCICEAQQAhAgNAAkACQCACIAMoAgAiBE4NACAAKAIAIgggAUYNAEEAIAggAUF/EGQNASADKAIAIQQLAkAgAiAESA0AIAUoAgAiAC0AVCEEIAYgACAGKAIgQRggAyAHQQxqENMKIgM2AiBBACEAIAcoAgwiAkEASA0AIAMgAkEYbGoiAyABNgIAIAEoAhQiCARAIAgoAgAhAAsgAyAFKAIAIAEoAgggACAEQQAQ+wEiBDYCBAJAAkAgASgCDCIIRQ0AIAQtAARBIHENACAFIAUoAigiBEEBajYCKCADIAQ2AhACQAJAIABBAUcNACAIKAIUIgAoAgBBAUcNAEEAIAAoAgggASgCFCgCCEEAEGQNACADQQA6ABQgAyABLQAEQQJ2QQFxOgAVDAELIANBAToAFAsgAyADKAIEKAIEQRR2QQFxOgAWDAELIANBfzYCEAtBfyEAAkAgAS0ABEEEcUUNACADLQAVDQAgBSAFKAIoIgBBAWo2AigLIAMgADYCCAsgASAGNgIoIAEgAjsBIgwCCyAAQRhqIQAgAkEBaiECDAALAAtBASEECyAHQUBrJAAgBAspAQF/AkAgAS0AAEGsAUcNACABLQAGQRBxDQAgAEEAOwEUQQIhAgsgAgsqACAAKAIAIgBBACABEJsBIAEtAAdBA3FFBEAgAEEAIAFBLGoQmwELQQALlQIBB38gACgCACIGKAIkBEBBAg8LIAEvAQZBoAhxBEBBAQ8LAkAgASgCHCIDRQ0AIANBCGohBANAIAIgAygCAE4NAQJAIAQgAkEEdGoiBSgCBCIHRQ0AIAUtAAlBA3ENACAGQQAgBxCbAQsgAkEBaiECDAALAAsCQCABKAIgIgVFDQAgBUEIaiEHQQAhAwNAIAMgBSgCAE4NASAGQQAgByADQQZ0aiICKAIIEJsBIAIoAiwhBAJAIAItACZBBHFFBEAgACAEEE8aDAELIARBCGohCEEAIQIDQCACIAQoAgBODQEgBkEAIAggAkEDdGooAgAQmwEgAkEBaiECDAALAAsgA0EBaiEDDAALAAsgACABEJEHQQALFwAgAS0AB0EBcQRAIAEoAiwQ6QULQQALfgEEfwJAIAEoAgQiAkGAAXENACABIAJBgAFyNgIEIAEoAiAiAkEIaiEBIAAoAgAhA0EAIQADQCAAIAIoAgBODQECQCABKAIQIgQtAB1BwABxRQ0AIAEoAhQiBUUNACADIAQgBUHAABCXBwsgAUFAayEBIABBAWohAAwACwALC/UiAh9/AX4jAEHwAWsiBSQAIAAoAgAiAygCACEOIAEgASgCBCIRQcAAcjYCBEECIQkCQCAOLQBXDQAgEUHAAHEEQEEBIQkMAQsgAC8BFARAIAMgAygCbEEBaiICNgJsIAEgAjYCEAsgASgCQCECIAEoAhwhFyABKAIgIRYCQAJAIAMoApQCRSARQYCAgAFxRXJFBEAgAkUEQCABIA5CJBA5IgI2AkAgAkUNBAsgAkEBNgIEDAELIAJFDQELIAMoAiQNACACIAMoApQCNgIIIAMgAjYClAILIAMgFhCnBCAWQQhqIhwhBANAAkACQAJAAkACQAJAAkACQCAWKAIAIApKBEAgBCgCEA0HIAQoAggiBkUEQCAAIAQoAhQQZg0LIAQoAhQhAiAEIAMoAgBCwAAQOSIHNgIQIAdFDQsgB0EBNgIYIAMoAgAhBiAHAn8gBCgCDCIIBEAgBiAIEFkMAQsgBSAENgIAIAZBnZcBIAUQOAs2AgADQCACIgYoAjQiAg0ACyADIAYoAhwgB0EiaiAHQQRqEKAFIAdByAE7ASYgB0H//wM7ASAgByAHKAIcQYCEAXI2AhwgAygCJEUNBgwLCwJAIAMoApQCIg9FDQAgAygCJA0AIAQoAgQNACAELQAmQQJxDQADQCAPRQ0BQQAhAiAPKAIAIgdBACAHQQBKGyEHIA9BDGohCAJAAkADQCACIAdGDQEgAkEYbCENIAJBAWohAiAGIAggDWoiDSgCACIJECwNAAsgDSgCDCICRQ0BIAUgCTYCcCADIAIgBUHwAGoQJgwKCyAPKAIEDQIgDygCCCEPDAELCyADKAIAIQJBAiEJIAMgBBCACw0LIAJCwAAQOSILRQ0LIA0oAhAiCEUEQCANIAJCFBA5Igg2AhACQCAIBEAgA0E0IAgQoAENAQsgAiALEC8MDQsgCCANLQAUOgASCyAEIAs2AhAgC0EBNgIYIAIgDSgCABBZIQYgC0HIATsBJiALQf//AzsBICALIAY2AgAgCyALKAIcQYCEAXI2AhwgBCACIA0oAghBABDGASIGNgIUIAItAFcNCyAGIAYoAgRBgICAIHI2AgQgBC8AJSICQQJxBEAgBSAEKAI4NgJgIANByOcBIAVB4ABqECYMDAsgBCAINgI8IAQgAkGAAnI7ACUgCCAIKAIAQQFqNgIAQX8hDCAGLQAAIgIhCCAGIQcCQCACQf4BcUGGAUciEA0AA0AgCEH/AXEgAkH/AXFHDQFBACECIAcoAiAiCCgCACISQQAgEkEAShshEiAIQQhqIRQDQCACIBJHBEACQCAUIAJBBnRqIggoAgQNACAIKAIIIhNFDQAgEyANKAIAECwNACAIIAs2AhAgCyALKAIYQQFqNgIYIAggCC8AJUHAAHI7ACUgBygCBCITQYDAAHENByAHIBNBgMAAcjYCBCAMQQBIBEAgAyADKAIoIgxBAWo2AigLIAggDDYCKAsgAkEBaiECDAELCyAHLQAFQSBxRQ0BIAYtAAAhAiAHKAI0IgctAAAhCAwACwALIA1B3MIANgIMIAMoApQCIQggAyAPNgKUAgJAIAYtAAVBIHEEQCAHIAYoAkA2AkAgACAHEGYgB0EANgJARQ0BDAsLIAAgBhBmDQoLIAMgDzYClAIgBiECA0AgAiIHKAI0IgINAAsgBygCHCEHIA0oAgQiAkUEQCAHIQIMBgsgB0UNBSAHKAIAIgcgAigCACIPRg0FIA0oAgAhACAFIA82AkggBSAHNgJEIAUgADYCQCADQb4oIAVBQGsQJgwJCyAEIANBACAEEIcCIgI2AhBBAiEJIAJFDQogAigCGCIGQf//A08EQCAFIAIoAgA2AhAgA0HStQEgBUEQahAmIARBADYCEAwLCyACIAZBAWo2AhggAi0AK0EBRwRAIAMgBBCACw0LIAItACtFDQYLIAAtABQhBiADIAIQhgINCgJAAkACQCACLQArQQFrDgIBAAILAkAgDi0AI0GAAXENACACKAI8IA4oAhAoAhxGDQAgBSACKAIANgIgIANBrvkAIAVBIGoQJgsgBCAOIAIoAixBABDGATYCFAwBCyAELQAlQYABcUUNACACKAI0IgdFDQAgBy0AEiAOKAIgQQd2QQFxTQ0AIAUgAigCADYCMCADQfXmASAFQTBqECYLIAIvASIhByACQf//AzsBIiAAQQE7ARQgACAEKAIUEGYaIAAgBjsBFCACIAc7ASIMBQsgAygCJA0FIAEoAiAiAkHIAGohCSACQQhqIgchDEEAIQsDQCACKAIAQQFrIAtMBEBBACEUIBcoAgAiCEEAIAhBAEobIQYgF0EIaiEaQQAhAgNAIAIgBkcEQAJAIBogAkEEdGooAgAiAC0AACIEQY0BRwRAIARBtAFHDQEMBwsgACgCEC0AAEG0AUYNBgsgAkEBaiECIAAoAgQgFHIhFAwBCwsgASgCHCEMDAQLAkAgDCgCEEUNACAJKAIQIg1FDQACQAJAIAktACQiBkEEcQRAIAktACZBBHENASAJKAIsDQFBACEKQQAhBANAIAQgDS4BIk5FBEACQCANKAIEIARBDGxqIgAtAApBAnENACACQQAgCyAAKAIAIghBAEEAQQEQkwdFDQAgAyAKQQAQzgUhAEEAIQogAEUNACADKAIAIAgQWSEKIAAoAgBBA3QgAGogCjYCACAAIQoLIARBAWohBAwBCwsgCgRAIAkgCjYCLCAJIAkvACVBgChyOwAlCyADKAIkDQoLQQFBAiAGQSBxGyEQIAkoAiwhBiAJLQAmQQRxRQ0BIAtBAWohFCAGQQhqIRMgAygCACEEQQAhDwNAIA8gBigCAE4NAwJAIA0gEyAPQQN0aigCACIAENQFIhJBAE4EQCACQQAgCyAAIAVB7AFqIAVB6AFqIAkvACVBDHZBAXEQkwcNAQsgBSAANgKAASADQbQsIAVBgAFqECYMCwsgBCACIAUoAuwBIAUoAugBIgoQkgchCCAHIAUoAuwBQQZ0aiAKEJYEQQAhCgJAIAItACxBwABxRQ0AA0ACQCACIAUoAuwBQQFqIAsgACAFQewBaiAFQegBaiAJLwAlQQx2QQFxEJMHBEAgByAFKALsAUEGdGoiFS0AJkEEcQRAIBUoAiwgABDLAkEATg0CCyAFIAA2ApABIANB+NEBIAVBkAFqECYLIApFDQIgAyADIAogCBBVQbiGA0EAEOEBIQgMAgsgAyAKIAgQVSEKIAQgAiAFKALsASAFKALoASIVEJIHIQggByAFKALsAUEGdGogFRCWBAwACwALIAQgAiAUIBIQkgchCiAJIBIQlgQgA0E1IAggChA0IgAEQCAAIAAoAgQgEHI2AgQgACAKKAIcNgIkCyABIAMgASgCJCAAEMUBNgIkIA9BAWohDwwACwALIAVBADYCoAEgA0HG6AAgBUGgAWoQJgwICyAGRQ0AIAYgCSgCKCAQEPkCIAEgAyABKAIkIAkoAiwQxQE2AiQgCUEANgIsIAkgCS8AJUGAEHI7ACULIAxBQGshDCAJQUBrIQkgC0EBaiELDAALAAsgBSANKAIANgJQIANB78EAIAVB0ABqECYMCAsgEUGAEHEhEiADKAIAKQMgQsQAgyEhQQAhDEEAIRUDQAJAIAggFUoEQCAaIBVBBHRqIgAoAgAiCCgCBCEdQQAhC0EAIRAgCCIELQAAIgJBtAFHBEACQCACQY0BRgRAIAQoAhAiBC0AAEG0AUYNAQsgAyAMIAgQVSIMBEAgDCgCAEEEdCAMaiICQQRrIAAoAgQ2AgAgAiACLwABQfz/A3EgAC8ACUEDcXI7AAEgAEEANgIECyAAQQA2AgAMAwsgCCgCDCgCCCEQCyAEKAIkIRsgHCEGQQAhAANAAn8CQAJAAkAgACAWKAIAIgJODQAgBigCECERIAYoAgwiE0UEQCARKAIAIRMLIA4tAFcNAAJ/IAYtACZBIHEEQCAGKAIUKAIcIQ9BAAwBCwJAIBBFDQAgECATECxFDQAgAEEBagwFC0EAIQ9BrMIBIA4gESgCPBBLIgRBAEgNABogDigCECAEQQR0aigCAAshB0EAIQQgAEEBaiINIAJODQEgBi0AZkEEcUUgEkVyDQEgBigCbCIYQQhqIQlBACECA0AgAiAYKAIATg0DAkAgDkE7IAkgAkEDdGooAgAiGRBwIgpFDQAgCi0ABEEDcQ0AIAogGzYCJAsgAyAMIAoQVSIMBEAgDCgCACAFIBk2AtABQQR0IAxqIgpBBGsgDkGrMiAFQdABahA4NgIAIAogCi8AAUH8/gNxQYIBcjsAAQsgAkEBaiECDAALAAsgCw0FIBAEQCAFIBA2AuABIANB3cEAIAVB4AFqECYMBgsgA0HV/wBBABAmDAULQQAhGAsgES4BIiARLQAdQQJxRSASQQBHcWoiAkEAIAJBAEobIR4gECASckUgAEEAR3EhHyAAQX9zISAgD0EIaiEZA0ACQCAEIB5GDQBBACEAAkACQCARLgEiIARGBEADQCAAQQNGDQMgAEECdEHAhgNqIQpBACECAkADQCACIARGDQEgCigCACARKAIEIAJBDGxqKAIAEF8EQCACQQFqIQIMAQsLIABBAWohACACIARHDQELCyAKKAIAIQkMAQsgESgCBCAEQQxsaiIAKAIAIQkCQCAPRQ0AIBkgBEEEdGoiAi8ACUEDcUEDRg0CIBBFDQAgAkEAIBBBAEEAEIcLRQ0CCyABLQAGQQJxQQEgAC8BCiIAQQJxG0UNASAAQYAIcUUgEHINACASRQ0BCwJAIB9FDQAgBi0AJkEEcUUNAEEBIQsgBigCLCAJEMsCQQBODQELIA5BOyAJEHAhCwJAAkAgFigCACIAQQJOBEAgBi0AJEHAAHFFIBJyDQEgACAgaiEKIAYhAANAIApBAEwNAiAAIgJBQGshACAKQQFrIQogAi0AZkEEcUUNACACKAJsIgJFDQAgAiAJEMsCQQBIDQALCyADLQDcAUECSQ0BCyADQY0BIA5BOyATEHAiACALEDQhCwJAIAMtANwBQQJJDQAgCCgCDCICRQ0AIAMgACACEJsBCyAHRQ0AIANBjQEgDkE7IAcQcCALEDQhCwsCQCALRQ0AIAstAARBA3ENACALIBs2AiQLIAMgDCALEFUiDEUEQEEBIQtBACEMDAILIAwoAgBBBHQgDGpBCGshAAJAAkAgEkUNACADLQDcAUEBSw0AIAACfyAPBEAgDiAZIARBBHRqKAIEEFkMAQsgBSAJNgLIASAFIBM2AsQBIAUgBzYCwAEgDkG0MCAFQcABahA4CzYCBCAAIAAvAAlBfHFBA0ECIAQgES4BIkYbciICOwAJAkAgBi0AJkEEcQRAIAYoAiwgCRDLAkEATg0BCyAYBEAgGCAJEMsCQQBODQELQQEhCyAEIBEuASJODQMgESgCBCAEQQxsai0AC0EEcUUNAwsgACACQYACcjsACQwBCyAhQgRRBEAgBSAJNgK0ASAFIBM2ArABIAAgDkGlMiAFQbABahA4NgIEIAAgAC8ACUH8/wNxOwAJDAELIAAgDiAJEFk2AgQgACAALwAJQfz/A3E7AAkLQQEhCwsgBEEBaiEEDAELCyANCyEAIAZBQGshBgwACwALIA4gFxC4AiABIAw2AhwMAgsgFCAdciEUIBVBAWohFSAXKAIAIQgMAAsAC0EAIQkgDEUNBiAMKAIAIA4oAoABSgRAIANB+xlBABAmDAMLIBRBiICAAnFFDQYgASABKAIEQYCAEHI2AgQMBgsgAyACIAtBImogC0EEahCgBSAQRQRAIA1B0DtB/zkgBigCBEGAwABxGzYCDCAAIAYQZhoLIA1BADYCDCADIAg2ApQCCyAELQAlQQJxRQ0BIAMgBBD/CkUNAQtBAiEJDAMLIARBQGshBCAKQQFqIQoMAQsLIAMgCDYClAILIAVB8AFqJAAgCQvTAgEFfyMAQRBrIgUkAAJAIAEoAjRFDQAgASgCMCIERQ0AIAEhAgNAIAJFDQECQAJAIAItAABBhwFrDgQAAQEAAQsgAigCNCECDAELCyAELwEUDQAgBEEIaiEGIAQoAgAhAgNAIAJBAEwNASAGIAJBAWsiAkEEdGooAgAtAAVBAnFFDQALQQIhAyAAKAIAIgIoAgAiBELMABA5IgBFDQAgBUIANwMIIAJBAEEAQQAgBUEIaiAAQQAQ9wEiBkUNACAAIAFBzAAQJSEAIAEgBjYCICAEQbQBQQAQcCEDIAIoAgAgAxCUASECIAFBADYCJCABQYoBOgAAIAEgAjYCHCAAQQA2AjAgAEIANwIoIAFBADYCSCABQQA2AkAgAUIANwI0IAEgASgCBEH//XtxQYCABHI2AgQgACgCNCAANgI4IABBADYCPEEAIQMLIAVBEGokACADCyAAIAEtAABBqAFGBEAgASABLQACIAAtABhqOgACC0EAC8YBAgZ/An4CQAJAIAEtAABBpwFrDgMAAQABCyAAKAIYIgUoAgQiBARAIAQoAgAhAwsgA0EAIANBAEobIQYgBEEIaiEEA0ACQCACIAZGBEAgBSkDCCIJQgAgCUIAVRshCUECIQMDQCAIIAlRDQIgCKchAiAIQgF8IQggBSgCECACQQJ0aigCACABKAIcRw0ACwwDC0EBIQMgAkEGdCEHIAJBAWohAiABKAIcIAQgB2ooAihHDQELCyAAIAAvARQgA3I7ARQLQQALJQEBfiAAKAIYIgApAwgiAlBFBEAgACACIAEoAiA0AgB9NwMICwueAQICfgJ/AkAgASgCICIBKAIAIgRFDQAgACgCGCIAIAApAwgiAyAErHwiAjcDCCAAKAIAIAAoAhAgAkIChhCcASIERQRAIABCADcDCEECIQUMAQsgACAENgIQIAFBCGohAEIAIQIDQCACIAE0AgBZDQEgBCADp0ECdGogACACp0EGdGooAig2AgAgA0IBfCEDIAJCAXwhAgwACwALIAUL2Q0BDX8jAEFAaiIDJABBASEIAkAgASgCBCICQQRxDQAgACgCACEGIAAoAhghBSACQcAAcUUEQCAGIAEgBRDSAUECQQEgBigCJBshCAwBCyABKAI0IQkgBigCACEKIAEhAgNAIAIEQCACIAIoAgRBBHI2AgQgA0EANgI0IANCADcCLCADQgA3AiQgA0IANwIcIAMgAjYCOCADIAY2AhhBAiEIIANBGGogAigCPBCaAQ0CIAItAAZBAXEEQCACKAIgKAIcIAIoAjA2AjAgAkEANgIwCyAFBEAgBSAFKAIcQQFqNgIcC0EAIQADQCACKAIgIgcoAgAgAEoEQAJAIAcgAEEGdGoiBygCHCIERQ0AIAQtAARBBHENACAFBH8gBSgCEAVBAAshCyAGKAKEAiENIAcoAhAiDgRAIAYgDjYChAILIAYgBCAFEIQLIAYgDTYChAIgBigCJA0FIAVFDQAgByAHLwAtQff/A3EgBSgCECALSkEDdHI7AC0LIABBAWohAAwBCwsCQCAFRQ0AIAUoAhwiAEUNACAFIABBAWs2AhwLIAMgBTYCJCADIAc2AhwgA0GBgAE2AjAgA0EYaiACKAIcEPUBDQICfyACKAIoIgcgAygCMCIAQRBxcgRAIAIgAigCBCAAQYCggMAAcXJBCHI2AgQgAEH//35xDAELIABB7v9+cQshACACKAIcIQQgAyAAQYABciIANgIwIAMgBDYCICADIAIoAiwiBAR/IAItAARBCHFFBEAgBkGyCUEAECYMBAsgA0EYaiAEEJoBDQMgAygCMAUgAAtBgIDAAHI2AjAgA0EYaiACKAIkEJoBDQIgAyADKAIwQf//v39xNgIwQQAhAANAIAIoAiAiBCgCACAASgRAIAQgAEEGdGoiBC0ALUEEcQRAIANBGGogBCgCQBD1AQ0FCyAAQQFqIQAMAQsLAkAgBi0A3AFBAkkNACACQcgAaiEEA0AgBCgCACIARQ0BIANBGGoiDiAAKAIMEPUBDQQgAEEkaiEEIA4gACgCCBD1AUUNAAsMAwsgA0EANgIkIAMgAygCMEGBgAFyNgIwIAItAAZBAXEEQCACIAIoAiAoAhwiACgCMDYCMCAAQQA2AjALIAIoAjAiAEUgDEUgCUEAR3FyRQRAIANBGGogAiAAQZqYARCDCw0DCyAKLQBXDQIgAyADKAIwQf//fnE2AjACQCAHRQ0AIANBGGogAiAHQYKbARCDCw0DIAotAFcNA0EAIQAgBygCACIEQQAgBEEAShshCyAHQQhqIQQDQCAAIAtGDQEgBCgCAC0ABEEQcQRAIAZB+ucAQQAQJgwFBSAEQRBqIQQgAEEBaiEADAELAAsACwJAIAIoAjgiAEUNACACKAIcKAIAIAAoAhwoAgBGDQAgAC0ABUECcQRAIAZB7ChBABAmDAQLIAMgAC0AABC6AzYCECAGQa8nIANBEGoQJgwDCyAMQQFqIQwgAigCNCECDAELC0EBIQggCUUNACABKAIwIgtFDQACQCALKAIAIgAgBigCACIKKAKAAUwEQEEAIQIgAEEAIABBAEobIQUgC0EIaiEHQQAhAANAIAAgBUZFBEAgByAAQQR0aiIIIAgvAAlB+/8DcTsACSAAQQFqIQAMAQsLA0AgASIFIAI2AjggBSICKAI0IgENAAtBASEIA0AgBUEAIAgbRQRAQQAhACALKAIAIgFBACABQQBKGyEBQQEhCANAIAAgAUYNBSAAQQR0IABBAWohACAHai0ACUEEcQ0ACyADIAA2AgAgBkGaGiADECYMAwsgBSgCHCEOQQAhACAHIQJBACEEA0AgACEIAn8CQCALKAIAIARKBEAgA0F/NgI8IAItAAlBBHENASACKAIAEJkBIglFDQECQCAJIANBPGoQogIEQCADKAI8IgFBAEogDigCACIAIAFOcQ0BIAZBmpgBIARBAWogACAJEJQHDAgLIA4gCRCCCyIBRQRAQQAhASAKIAlBABA1IQACQCAKLQBXDQAgBiAFIAAQgQshASAGLQDcAUECSSABQQBMcg0AIAYgBSAJEIELGgsgCiAAEDALQQEgAUEATA0DGgsgBi0A3AFBAU0EQCAKQZsBQQAQcCINRQ0HIA0gATYCCCANIA0oAgRBgBByNgIEIAIhDCAJIAIoAgAiAEcEfwNAIAAiDCgCDCIALQAAQfEARg0ACyAMQQxqBSAMCyANNgIAIAogCRDVASACIAE7AQwLIAIgAi8ACUEEcjsACQwBCyAFKAI4IQUMAwsgCAshACACQRBqIQIgBEEBaiEEDAALAAsACyAGQdjnAEEAECYLQQIhCAsgA0FAayQAIAgLKgACQCABLQAAQawBRw0AIAEtAAdBAXFFDQAgACgCGCABKAIsEIwLC0EACwoAIAAoAhggAUcLtAIBA39BASECAkAgASgCBCIDQQFxDQAgA0ECcQRAIAAvARYNAQsCQAJAAkACQAJAAkAgAS0AACIEQStrDg8BAQYFBQMCBgYEBAQEBAQACyAEQZ0BayIDQRRLDQRBASADdEGBgNMAcQ0FIANBCkcNBCAAKAIYIAEoAhxHDQUgAEEBOwEUQQIPCyAAIAEoAgwgASgCEBCUC0EBDwsgA0GAIHENAyABKAIUKAIAQQBMDQMgACABKAIMEE8aQQEPCyAAIAEoAgwQTxogACABKAIUIgAoAgggACgCGBCUC0EBDwsgASgCECEAAkAgASgCDCIBLQAAQacBRw0AIAEoAiwiAUUNACABLQArQQFGDQILIAAtAABBpwFHDQAgACgCLCIARQ0AIAAtACtBAUYNAQtBACECCyACCzIAAkAgACgCACIAKAKUAkUNACABKAI0DQAgARC6BSgCQCIBRQ0AIAAgASgCCDYClAILCwsAIABBADsBFEECCwkAIAAgARC6BAuGAgEDfyMAQRBrIgMkACAAKAIEKAIIIQUgACgCACgCFCEEAkAgAigCABBDIAQoApgBSgRAIABBsQtBfxBMDAELAkAgAUEDRgRAIAMgAigCCBArIgE2AgggAUUNAiABEJAJQQFHBEAgAEHlyABBfxBMDAMLIANBCGoQpwEiASAFLQAARwRAIAEgBS0AAUcNAgsgAyAFKAAAIgQ2AgwgBEH/AXEgAUYEQCADQQA6AAwLIANBDGohBSABIARBCHZB/wFxRw0BIANBADoADQwBCyAFLQACIQELIAIoAgAQKyEEIAIoAgQQKyICRSAERXINACAAIAQgAiAFIAEQngNFEHYLIANBEGokAAsLrJgE2wIAQYAIC5foATMuNDUuMgB7fQAlcy4legBpbmZpbml0eQBhZmZpbml0eQBSZWFsQWZmaW5pdHkAYnVzeQB0ZW1wX3N0b3JlX2RpcmVjdG9yeQBub3QgYSB3cml0YWJsZSBkaXJlY3RvcnkAb3BlbkRpcmVjdG9yeQBzaHJpbmtfbWVtb3J5AG91dCBvZiBtZW1vcnkAZmFpbGVkIHRvIGFsbG9jYXRlICV1IGJ5dGVzIG9mIG1lbW9yeQBIQVZJTkcgY2xhdXNlIG9uIGEgbm9uLWFnZ3JlZ2F0ZSBxdWVyeQBJbnRDb3B5AFNDb3B5AFZEZXN0cm95AE11bHRpcGx5AHF1ZXJ5X29ubHkAdW5saWtlbHkAdGFibGUgIiVzIiBoYXMgbW9yZSB0aGFuIG9uZSBwcmltYXJ5IGtleQBmb3JlaWduIGtleQBqc29uX2dyb3VwX2FycmF5AGpzb25iX2dyb3VwX2FycmF5AGpzb25fYXJyYXkAanNvbmJfYXJyYXkAanVsaWFuZGF5AGZ0czRhdXgAdW5peABzcWxpdGVfcmVuYW1lX3F1b3RlZml4AHByZWZpeABMSUtFIG9yIEdMT0IgcGF0dGVybiB0b28gY29tcGxleAB1bmhleABjaGFyaW5kZXgAT3BlbkF1dG9pbmRleABhdXRvbWF0aWNfaW5kZXgAYXV0by1pbmRleABvcnBoYW4gaW5kZXgARHJvcEluZGV4AGlkeABSZW9wZW5JZHgAcGN4AG1heABNZW1NYXgAJTAyeAAweAAgRlJPTSAnJXEnLiclcSVzJyBBUyB4AENSRUFURSBUQUJMRSB4AHJ3AHBzb3cAaW1wbGllc19ub25udWxsX3JvdwBub3cAaW50ZWdlciBvdmVyZmxvdwBwYXJzZXIgc3RhY2sgb3ZlcmZsb3cAd2luZG93AHNoYWRvdwBSZXN1bHRSb3cASWZOdWxsUm93AG5ldwBubyBzdWNoIHZpZXcAY2Fubm90IG1vZGlmeSAlcyBiZWNhdXNlIGl0IGlzIGEgdmlldwBDYW5ub3QgYWRkIGEgY29sdW1uIHRvIGEgdmlldwBjYW5ub3QgVVBTRVJUIGEgdmlldwBQcmV2AHN0ZGV2ACAlbGx1ACVjJXUARmFpbGVkIHRvIHJlYWQgcHRybWFwIGtleT0ldQAlLip6OiV1AE9mZnNldCAldSBvdXQgb2YgcmFuZ2UgJXUuLiV1AGludmFsaWQgcGFnZSBudW1iZXIgJXUAZmFpbGVkIHRvIGdldCBwYWdlICV1ADJuZCByZWZlcmVuY2UgdG8gcGFnZSAldQBGcmFnbWVudGF0aW9uIG9mICV1IGJ5dGVzIHJlcG9ydGVkIGFzICV1IG9uIHBhZ2UgJXUAZnJlZWxpc3QgbGVhZiBjb3VudCB0b28gYmlnIG9uIHBhZ2UgJXUATXVsdGlwbGUgdXNlcyBmb3IgYnl0ZSAldSBvZiBwYWdlICV1ACVzIGlzICV1IGJ1dCBzaG91bGQgYmUgJXUAdW5hYmxlIHRvIHVzZSBmdW5jdGlvbiAlcyBpbiB0aGUgcmVxdWVzdGVkIGNvbnRleHQAU29ydGVyTmV4dABWTmV4dABpbmNvbXBsZXRlIGlucHV0AGJ1c3lfdGltZW91dABsb2NhbGhvc3QAY2Fubm90IGRyb3AgY29sdW1uICIlcyI6IG5vIG90aGVyIGNvbHVtbnMgZXhpc3QAcGVyc2lzdABmb3JlaWduX2tleV9saXN0AGluZGV4X2xpc3QAZnVuY3Rpb25fbGlzdABjb2xsYXRpb25fbGlzdABkYXRhYmFzZV9saXN0AG1vZHVsZV9saXN0AFBSQUdNQSB0YWJsZV9saXN0AHByYWdtYV9saXN0AHNldCBsaXN0AFZhbHVlTGlzdABzcWxpdGVfcmVuYW1lX3Rlc3QAUm93U2V0VGVzdABTZXF1ZW5jZVRlc3QAZmFzdABMYXN0AENhc3QAc3FydABTb3J0ZXJTb3J0ACJcL2JmbnJ0AGpzb25faW5zZXJ0AGpzb25iX2luc2VydABJZHhJbnNlcnQAU29ydGVySW5zZXJ0AHJlc3RhcnQAY290AEJpdE5vdABJZk5vdABQYWdlY291bnQAZnJlZWxpc3RfY291bnQAbWF4X3BhZ2VfY291bnQAUmVzZXRDb3VudAB3YWxfYXV0b2NoZWNrcG9pbnQAd2FsX2NoZWNrcG9pbnQAQ2hlY2twb2ludABTYXZlcG9pbnQAYSBDSEVDSyBjb25zdHJhaW50ACVzT04gQ09ORkxJQ1QgY2xhdXNlIGRvZXMgbm90IG1hdGNoIGFueSBQUklNQVJZIEtFWSBvciBVTklRVUUgY29uc3RyYWludABDdXJzb3JIaW50AF9jb250ZW50AHBhcmVudABESVNUSU5DVCBhZ2dyZWdhdGVzIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBhcmd1bWVudABjb21tZW50AEFQSSBjYWxsZWQgd2l0aCBmaW5hbGl6ZWQgcHJlcGFyZWQgc3RhdGVtZW50AEFQSSBjYWxsZWQgd2l0aCBOVUxMIHByZXBhcmVkIHN0YXRlbWVudABNYXhQZ2NudABkZWZhdWx0IHZhbHVlIG9mIGNvbHVtbiBbJXNdIGlzIG5vdCBjb25zdGFudABNdXN0QmVJbnQAQ2Fubm90IGFkZCBhIGNvbHVtbiB3aXRoIG5vbi1jb25zdGFudCBkZWZhdWx0AEhhbHQAbGFub2l0AHN0YXRfaW5pdABJbml0AEF1dG9Db21taXQAYW5hbHlzaXNfbGltaXQAc29mdF9oZWFwX2xpbWl0AGhhcmRfaGVhcF9saW1pdABqb3VybmFsX3NpemVfbGltaXQAT2Zmc2V0TGltaXQAU2Vla0hpdABPTiBjbGF1c2UgcmVmZXJlbmNlcyB0YWJsZXMgdG8gaXRzIHJpZ2h0AFNoaWZ0UmlnaHQAaGdodABTaGlmdExlZnQAT2Zmc2V0AHJlc2V0AGpzb25fc2V0AGpzb25iX3NldAB0b28gbWFueSBjb2x1bW5zIGluIHJlc3VsdCBzZXQAJXIgT1JERVIgQlkgdGVybSBkb2VzIG5vdCBtYXRjaCBhbnkgY29sdW1uIGluIHRoZSByZXN1bHQgc2V0AHNuaXBwZXQAc3RhdF9nZXQAc3FsaXRlX2NvbXBpbGVvcHRpb25fZ2V0AHN0cmljdABOb0NvbmZsaWN0AGpzb25fZ3JvdXBfb2JqZWN0AGpzb25iX2dyb3VwX29iamVjdABqc29uX29iamVjdABqc29uYl9vYmplY3QAanNvbl9leHRyYWN0AGpzb25iX2V4dHJhY3QAU3VidHJhY3QAbHN0YXQAZnN0YXQAJXNfc3RhdAB0YmwsaWR4LHN0YXQAdW5zdXBwb3J0ZWQgZmlsZSBmb3JtYXQAZ3JvdXBfY29uY2F0AENvbmNhdABMdABHdABkZWZlcl9mb3JlaWduX2tleXMAYWx3YXlzAHBhcmFtZXRlcnMgYXJlIG5vdCBhbGxvd2VkIGluIHZpZXdzAGNvbmNhdF93cwBzdGF0dXMAc3luY2hyb25vdXMAaW5kZXggJXMgYWxyZWFkeSBleGlzdHMAb3V0cHV0IGZpbGUgYWxyZWFkeSBleGlzdHMAJXMgJVQgYWxyZWFkeSBleGlzdHMAdHJpZ2dlciAlVCBhbHJlYWR5IGV4aXN0cwBOb3RFeGlzdHMAaWdub3JlX2NoZWNrX2NvbnN0cmFpbnRzAENIRUNLIGNvbnN0cmFpbnRzAGV4cHJlc3Npb25zIHByb2hpYml0ZWQgaW4gUFJJTUFSWSBLRVkgYW5kIFVOSVFVRSBjb25zdHJhaW50cwBqc29uX29iamVjdCgpIHJlcXVpcmVzIGFuIGV2ZW4gbnVtYmVyIG9mIGFyZ3VtZW50cwBqc29uXyVzKCkgbmVlZHMgYW4gb2RkIG51bWJlciBvZiBhcmd1bWVudHMAJXNfc2VnbWVudHMAdW5hYmxlIHRvIGRlbGV0ZS9tb2RpZnkgdXNlci1mdW5jdGlvbiBkdWUgdG8gYWN0aXZlIHN0YXRlbWVudHMAdW5hYmxlIHRvIGRlbGV0ZS9tb2RpZnkgY29sbGF0aW9uIHNlcXVlbmNlIGR1ZSB0byBhY3RpdmUgc3RhdGVtZW50cwBvZmZzZXRzAHJldmVyc2VfdW5vcmRlcmVkX3NlbGVjdHMAaWlzc3Nzc3MAaXNzAHNlc3MAdW5jb21wcmVzcwBjYW5ub3Qgb3BlbiBzYXZlcG9pbnQgLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBjYW5ub3QgcmVsZWFzZSBzYXZlcG9pbnQgLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBjYW5ub3QgY29tbWl0IHRyYW5zYWN0aW9uIC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAY2Fubm90IFZBQ1VVTSAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGFjY2VzcwBwYXJhbWV0ZXJzAHJlY3Vyc2l2ZV90cmlnZ2VycwB0aGUgSU5ERVhFRCBCWSBjbGF1c2UgaXMgbm90IGFsbG93ZWQgb24gVVBEQVRFIG9yIERFTEVURSBzdGF0ZW1lbnRzIHdpdGhpbiB0cmlnZ2VycwB0aGUgTk9UIElOREVYRUQgY2xhdXNlIGlzIG5vdCBhbGxvd2VkIG9uIFVQREFURSBvciBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAcXVhbGlmaWVkIHRhYmxlIG5hbWVzIGFyZSBub3QgYWxsb3dlZCBvbiBJTlNFUlQsIFVQREFURSwgYW5kIERFTEVURSBzdGF0ZW1lbnRzIHdpdGhpbiB0cmlnZ2VycwBDaGlsZCBwYWdlIGRlcHRoIGRpZmZlcnMAdW5hYmxlIHRvIGNsb3NlIGR1ZSB0byB1bmZpbmFsaXplZCBzdGF0ZW1lbnRzIG9yIHVuZmluaXNoZWQgYmFja3VwcwBhY29zAElmUG9zAGNvbXBpbGVfb3B0aW9ucwBESVNUSU5DVCBpcyBub3Qgc3VwcG9ydGVkIGZvciB3aW5kb3cgZnVuY3Rpb25zAEZJTFRFUiBjbGF1c2UgbWF5IG9ubHkgYmUgdXNlZCB3aXRoIGFnZ3JlZ2F0ZSB3aW5kb3cgZnVuY3Rpb25zAG5vbi1kZXRlcm1pbmlzdGljIGZ1bmN0aW9ucwBpbmRleCBleHByZXNzaW9ucwBTRUxFQ1RzIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiAlcyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgcmVzdWx0IGNvbHVtbnMAdmlydHVhbCB0YWJsZXMgY2Fubm90IHVzZSBjb21wdXRlZCBjb2x1bW5zAGdlbmVyYXRlZCBjb2x1bW5zAHRhYmxlICVzIGhhcyAlZCB2YWx1ZXMgZm9yICVkIGNvbHVtbnMAcmFkaWFucwBhbGwgVkFMVUVTIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgdGVybXMAZW1wdHlfcmVzdWx0X2NhbGxiYWNrcwBMb2FkQW5hbHlzaXMAZmxncwBmbGFncwB2ZnMAJWQgY29sdW1ucyBhc3NpZ25lZCAlZCB2YWx1ZXMASlNPTiBjYW5ub3QgaG9sZCBCTE9CIHZhbHVlcwBmYWlsZWQgbWVtb3J5IHJlc2l6ZSAldSB0byAldSBieXRlcwBwYXJ0aWFsIGluZGV4IFdIRVJFIGNsYXVzZXMAc2hvcnRfY29sdW1uX25hbWVzAGZ1bGxfY29sdW1uX25hbWVzAHVuYWJsZSB0byBvcGVuIGEgdGVtcG9yYXJ5IGRhdGFiYXNlIGZpbGUgZm9yIHN0b3JpbmcgdGVtcG9yYXJ5IHRhYmxlcwBjYW5ub3QgY3JlYXRlIHRyaWdnZXJzIG9uIHNoYWRvdyB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiB2aXJ0dWFsIHRhYmxlcwAlcyBSRVRVUk5JTkcgaXMgbm90IGF2YWlsYWJsZSBvbiB2aXJ0dWFsIHRhYmxlcwBjYW5ub3Qgam9pbiB1c2luZyBjb2x1bW4gJXMgLSBjb2x1bW4gbm90IHByZXNlbnQgaW4gYm90aCB0YWJsZXMAQVVUT0lOQ1JFTUVOVCBub3QgYWxsb3dlZCBvbiBXSVRIT1VUIFJPV0lEIHRhYmxlcwAlcyBjYW5ub3QgdXNlIHZhcmlhYmxlcwB0b28gbWFueSBTUUwgdmFyaWFibGVzAHN1YnF1ZXJpZXMAY2Fubm90IHVzZSB3aW5kb3cgZnVuY3Rpb25zIGluIHJlY3Vyc2l2ZSBxdWVyaWVzAGNvdW50X2NoYW5nZXMAdG90YWxfY2hhbmdlcwBkZWdyZWVzAFJFVFVSTklORyBtYXkgbm90IHVzZSAiVEFCTEUuKiIgd2lsZGNhcmRzAHRocmVhZHMAYWJzAC4lLipzAENSRUFURSAlcyAlLipzAENSRUFURSVzIElOREVYICUuKnMAaW52YWxpZCB1cmkgYXV0aG9yaXR5OiAlLipzAHVua25vd24gdGFibGUgb3B0aW9uOiAlLipzACUuKnMlcwAsJXMlcyVzAFNDQU4gJXMlcyVzAHNxbGl0ZV9hbHRlcnRhYl8lcwBTQ0FOICVkIENPTlNUQU5UIFJPVyVzACVRJXMAIFZJUlRVQUwgVEFCTEUgSU5ERVggJWQ6JXMAJXM6ICVzLiVzLiVzAG1pc3NpbmcgZGF0YXR5cGUgZm9yICVzLiVzAGNhbm5vdCBzdG9yZSAlcyB2YWx1ZSBpbiAlcyBjb2x1bW4gJXMuJXMAbm9uLSVzIHZhbHVlIGluICVzLiVzAFRFWFQgdmFsdWUgaW4gJXMuJXMATlVMTCB2YWx1ZSBpbiAlcy4lcwBOVU1FUklDIHZhbHVlIGluICVzLiVzAG1hbGZvcm1lZCBpbnZlcnRlZCBpbmRleCBmb3IgRlRTJWQgdGFibGUgJXMuJXMAJXM6ICVzLiVzAG5vIHN1Y2ggdGFibGUgY29sdW1uOiAlcy4lcwAuLiVzACUuMThzLSVzACBVU0lORyBJTlRFR0VSIFBSSU1BUlkgS0VZICglcwB1c2UgRFJPUCBWSUVXIHRvIGRlbGV0ZSB2aWV3ICVzAHJvdyBub3QgaW4gUFJJTUFSWSBLRVkgb3JkZXIgZm9yICVzAGlsbGVnYWwgZmlyc3QgYXJndW1lbnQgdG8gJXMAbWlzdXNlIG9mIGFsaWFzZWQgd2luZG93IGZ1bmN0aW9uICVzAHRvbyBtYW55IGNvbHVtbnMgb24gJXMAdG9vIG1hbnkgY29sdW1ucyBpbiAlcwAlcyBwcm9oaWJpdGVkIGluICVzAENIRUNLIGNvbnN0cmFpbnQgZmFpbGVkIGluICVzAG5vbi1kZXRlcm1pbmlzdGljIHVzZSBvZiAlcygpIGluICVzAHJlY292ZXJlZCAlZCBwYWdlcyBmcm9tICVzAG1pc3VzZSBvZiBhbGlhc2VkIGFnZ3JlZ2F0ZSAlcwAlcyAlVCBjYW5ub3QgcmVmZXJlbmNlIG9iamVjdHMgaW4gZGF0YWJhc2UgJXMAY2Fubm90IGRldGFjaCBkYXRhYmFzZSAlcwBhIEpPSU4gY2xhdXNlIGlzIHJlcXVpcmVkIGJlZm9yZSAlcwBjYW5ub3Qgb3BlbiB2YWx1ZSBvZiB0eXBlICVzAGNhbm5vdCBmc3RhdCBkYiBmaWxlICVzAHJlY292ZXJlZCAlZCBmcmFtZXMgZnJvbSBXQUwgZmlsZSAlcwBQUklNQVJZIEtFWSBtaXNzaW5nIG9uIHRhYmxlICVzAHVzZSBEUk9QIFRBQkxFIHRvIGRlbGV0ZSB0YWJsZSAlcwBTRUxFQ1QgJXMgT1JERVIgQlkgcm93aWQgJXMAU0VMRUNUICVzIFdIRVJFIHJvd2lkIEJFVFdFRU4gJWxsZCBBTkQgJWxsZCBPUkRFUiBCWSByb3dpZCAlcwB0aGVyZSBpcyBhbHJlYWR5IGFuIGluZGV4IG5hbWVkICVzAHRhYmxlICVTIGhhcyBubyBjb2x1bW4gbmFtZWQgJXMAdGhlcmUgaXMgYWxyZWFkeSBhIHRhYmxlIG5hbWVkICVzAHN0YXRlbWVudCBhYm9ydHMgYXQgJWQ6IFslc10gJXMAQ09WRVJJTkcgSU5ERVggJXMAU0VMRUNUICVzAHVuc3VwcG9ydGVkIHVzZSBvZiBOVUxMUyAlcwBVU0UgVEVNUCBCLVRSRUUgRk9SICVzAC0tIFRSSUdHRVIgJXMAUklHSFQtSk9JTiAlcwA+PyBBTkQgJXMAJXo6ICVzAHJlY3Vyc2l2ZSByZWZlcmVuY2UgaW4gYSBzdWJxdWVyeTogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGNhbGxlZCByZWN1cnNpdmVseTogJXMAbm8gc3VjaCBpbmRleDogJXMAbm8gc3VjaCB3aW5kb3c6ICVzAGNhbm5vdCBvdmVycmlkZSAlcyBvZiB3aW5kb3c6ICVzAGNhbm5vdCBvcGVuIHZpZXc6ICVzAG5vIHN1Y2ggc2F2ZXBvaW50OiAlcwBubyBzdWNoIHZmczogJXMAbXVsdGlwbGUgcmVjdXJzaXZlIHJlZmVyZW5jZXM6ICVzAGVycm9yIGluICVzICVzJXMlczogJXMAdW5hYmxlIHRvIHZhbGlkYXRlIHRoZSBpbnZlcnRlZCBpbmRleCBmb3IgRlRTJWQgdGFibGUgJXMuJXM6ICVzAGVycm9yIGluICVzICVzIGFmdGVyICVzOiAlcwB1bmtub3duIHRva2VuaXplcjogJXMAZXJyb3IgcGFyc2luZyBwcmVmaXggcGFyYW1ldGVyOiAlcwB1bnJlY29nbml6ZWQgcGFyYW1ldGVyOiAlcwB1bnJlY29nbml6ZWQgb3JkZXI6ICVzAHVucmVjb2duaXplZCBtYXRjaGluZm86ICVzAG5vIHN1Y2ggY29sdW1uOiAlcwBmaWxlIHJlbmFtZWQgd2hpbGUgb3BlbjogJXMAZmlsZSB1bmxpbmtlZCB3aGlsZSBvcGVuOiAlcwB1bnN1cHBvcnRlZCBlbmNvZGluZzogJXMAY2Fubm90IGxpbWl0IFdBTCBzaXplOiAlcwBNSiBkZWxldGU6ICVzAHRhcmdldCBvYmplY3QvYWxpYXMgbWF5IG5vdCBhcHBlYXIgaW4gRlJPTSBjbGF1c2U6ICVzAG9iamVjdCBuYW1lIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2U6ICVzAHVua25vd24gZGF0YWJhc2U6ICVzAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlOiAlcwBubyBzdWNoIGRhdGFiYXNlOiAlcwB0aGVyZSBpcyBhbHJlYWR5IGFub3RoZXIgdGFibGUgb3IgaW5kZXggd2l0aCB0aGlzIG5hbWU6ICVzAGR1cGxpY2F0ZSBjb2x1bW4gbmFtZTogJXMAZHVwbGljYXRlIFdJVEggdGFibGUgbmFtZTogJXMAbm8gc3VjaCBtb2R1bGU6ICVzAG11bHRpcGxlIGxpbmtzIHRvIGZpbGU6ICVzAGNhbm5vdCBvcGVuIHZpcnR1YWwgdGFibGU6ICVzAG5vIHN1Y2ggdGFibGU6ICVzAG11bHRpcGxlIHJlZmVyZW5jZXMgdG8gcmVjdXJzaXZlIHRhYmxlOiAlcwBubyBzdWNoICVzIG1vZGU6ICVzAE1KIGNvbGxpZGU6ICVzAG5vIHN1Y2ggY29sbGF0aW9uIHNlcXVlbmNlOiAlcwBjaXJjdWxhciByZWZlcmVuY2U6ICVzAGNhbm5vdCBvcGVuIHRhYmxlIHdpdGhvdXQgcm93aWQ6ICVzACVzIG1vZGUgbm90IGFsbG93ZWQ6ICVzAHZ0YWJsZSBjb25zdHJ1Y3RvciBmYWlsZWQ6ICVzAGF1dG9tYXRpYyBleHRlbnNpb24gbG9hZGluZyBmYWlsZWQ6ICVzAGRhdGFiYXNlIHRhYmxlIGlzIGxvY2tlZDogJXMAZGF0YWJhc2Ugc2NoZW1hIGlzIGxvY2tlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGRpZCBub3QgZGVjbGFyZSBzY2hlbWE6ICVzAGFib3J0IGF0ICVkIGluIFslc106ICVzAC0tICVzACV6IC0gJXMAb3NfdW5peC5jOiVkOiAoJWQpICVzKCVzKSAtICVzAHdyAHJpZ2h0c3RyAGxlZnRzdHIAaW5zdHIAc3Vic3RyAGV4cHJfaW1wbGllc19leHByAGludmFsaWQgYXJndW1lbnRzIHRvIGZ0czRhdXggY29uc3RydWN0b3IAbWlzc2luZyAlcyBwYXJhbWV0ZXIgaW4gZnRzNCBjb25zdHJ1Y3RvcgB0aGUgIi4iIG9wZXJhdG9yAGZ0czNjdXJzb3IAbmVhciAiJVQiOiBzeW50YXggZXJyb3IAdW5rbm93biBlcnJvcgBkb21haW4gZXJyb3IAbm90IGFuIGVycm9yAFNRTCBsb2dpYyBlcnJvcgBkaXNrIEkvTyBlcnJvcgBmbG9vcgBybWRpcgBta2RpcgBzZWdkaXIAZnRzM190b2tlbml6ZXIAdW5rbm93biB0b2tlbml6ZXIAcG93ZXIAbG93ZXIAc3FsaXRlX3RlbXBfbWFzdGVyAHNxbGl0ZV9tYXN0ZXIAcG9ydGVyAFJlc2V0U29ydGVyAEZrQ291bnRlcgBBUEkgY2FsbCB3aXRoICVzIGRhdGFiYXNlIGNvbm5lY3Rpb24gcG9pbnRlcgBzdHJmaWx0ZXIAVkZpbHRlcgBFU0NBUEUgZXhwcmVzc2lvbiBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3RlcgB1cHBlcgBwcm9wZXIASWZTbWFsbGVyAGNhbm5vdCB1c2UgUkVUVVJOSU5HIGluIGEgdHJpZ2dlcgBEcm9wVHJpZ2dlcgBzZWNvbmQgYXJndW1lbnQgdG8gbnRoX3ZhbHVlIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyAGFyZ3VtZW50IG9mIG50aWxlIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyAGZyYW1lIHN0YXJ0aW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIASW50ZWdlcgBSb3dpZCAlbGxkIG91dCBvZiBvcmRlcgBSZW1haW5kZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyAGZyYW1lIGVuZGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAYWRkcgBwYWRyAGNoYXIAeWVhcgBDbGVhcgBCaXRPcgBzZXEAQ29sbFNlcQBFbHNlRXEAcmVnZXhwAE9wZW5EdXAATm9vcABKdW1wAC91c3IvdG1wAC92YXIvdG1wAHRlbXAAY3VycmVudF90aW1lc3RhbXAAQWdnU3RlcABtb2RlU3RlcAB2YXJpYW5jZVN0ZXAAbXVubWFwAG1tYXAAbXJlbWFwAHNxbGl0ZV9yZXR1cm5pbmdfJXAAdnRhYjolcABzc2Vuc3VvAGlsc3VvAGF1dG8AR290bwBpbnRvAGluY3JlbWVudGFsX3ZhY3V1bSBlbmFibGVkIHdpdGggYSBtYXggcm9vdHBhZ2Ugb2YgemVybwBJZk5vdFplcm8ARGVjckp1bXBaZXJvAEZrSWZaZXJvAHNlcW5vAGluZGV4X3hpbmZvAHRhYmxlX3hpbmZvAG1hdGNoaW5mbwBpbmRleF9pbmZvAHRhYmxlX2luZm8AT3BlblBzZXVkbwBmY2hvd24AQmVnaW5TdWJydG4AUmV0dXJuAGpzb24Abm8gcXVlcnkgc29sdXRpb24AaW5kZXggY29ycnVwdGlvbgBkYXRhYmFzZSBjb3JydXB0aW9uAGZyZWUgc3BhY2UgY29ycnVwdGlvbgBqc29uX2Vycm9yX3Bvc2l0aW9uAHVua25vd24gY29sdW1uICIlcyIgaW4gZm9yZWlnbiBrZXkgZGVmaW5pdGlvbgAlcy54QmVzdEluZGV4IG1hbGZ1bmN0aW9uAGF1dGhvcml6ZXIgbWFsZnVuY3Rpb24AJSNUKCkgbWF5IG5vdCBiZSB1c2VkIGFzIGEgd2luZG93IGZ1bmN0aW9uACclcycgaXMgbm90IGEgZnVuY3Rpb24ARnVuY3Rpb24AY2Fubm90IHN0YXJ0IGEgdHJhbnNhY3Rpb24gd2l0aGluIGEgdHJhbnNhY3Rpb24AY2Fubm90IGNoYW5nZSAlcyB3YWwgbW9kZSBmcm9tIHdpdGhpbiBhIHRyYW5zYWN0aW9uAHRlbXBvcmFyeSBzdG9yYWdlIGNhbm5vdCBiZSBjaGFuZ2VkIGZyb20gd2l0aGluIGEgdHJhbnNhY3Rpb24AY2Fubm90IFZBQ1VVTSBmcm9tIHdpdGhpbiBhIHRyYW5zYWN0aW9uAFNhZmV0eSBsZXZlbCBtYXkgbm90IGJlIGNoYW5nZWQgaW5zaWRlIGEgdHJhbnNhY3Rpb24AVHJhbnNhY3Rpb24AUGVybXV0YXRpb24AdW5rbm93biBvcGVyYXRpb24AdW5zdXBwb3J0ZWQgZnJhbWUgc3BlY2lmaWNhdGlvbgBSQU5HRSB3aXRoIG9mZnNldCBQUkVDRURJTkcvRk9MTE9XSU5HIHJlcXVpcmVzIG9uZSBPUkRFUiBCWSBleHByZXNzaW9uAHRvbyBtYW55IGxldmVscyBvZiB0cmlnZ2VyIHJlY3Vyc2lvbgB1c2VyX3ZlcnNpb24Ac3FsaXRlX3ZlcnNpb24AZGF0YV92ZXJzaW9uAHNjaGVtYV92ZXJzaW9uAHNxbGl0ZV9kcm9wX2NvbHVtbgBzcWxpdGVfcmVuYW1lX2NvbHVtbgBhZnRlciBkcm9wIGNvbHVtbgBubyBzdWNoIGNvbHVtbgBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIG5vbi1nZW5lcmF0ZWQgY29sdW1uAGNhbm5vdCB1c2UgREVGQVVMVCBvbiBhIGdlbmVyYXRlZCBjb2x1bW4AYWRkIGNvbHVtbgBDYW5ub3QgYWRkIGEgUFJJTUFSWSBLRVkgY29sdW1uAENhbm5vdCBhZGQgYSBVTklRVUUgY29sdW1uAGNhbm5vdCBhZGQgYSBTVE9SRUQgY29sdW1uAFZDb2x1bW4AYnVpbHRpbgBhc2luAGF0IG1vc3QgJWQgdGFibGVzIGluIGEgam9pbgBtaW4Ab3JpZ2luAFZCZWdpbgBtYWluAEV4cGxhaW4Ac2lnbgBzc2VuAG9wZW4ASWZOb3RPcGVuAFNvcnRlck9wZW4AVk9wZW4AaGlkZGVuAGF0YW4AbWVkaWFuAFNlZWtTY2FuAFZJbml0SW4AYXV0b192YWN1dW0AaW5jcmVtZW50YWxfdmFjdXVtAEluY3JWYWN1dW0Ac3VtAGZsZXhudW0AcG0AZHJvcCBjb2x1bW4gZnJvbQAvZGV2L3VyYW5kb20AQWRkSW1tAHJ0cmltAGx0cmltAHJlYWRvbmx5X3NobQAlcy1zaG0AdG5lbQBSQUlTRSgpIG1heSBvbmx5IGJlIHVzZWQgd2l0aGluIGEgdHJpZ2dlci1wcm9ncmFtAFByb2dyYW0AUGFyYW0AZnVsAGZjbnRsAGlvY3RsAGlnb2wAbG9ja2luZyBwcm90b2NvbABuY29sAG5vdG51bGwAaWZudWxsAC9kZXYvbnVsbABkYXRhYmFzZSBvciBkaXNrIGlzIGZ1bGwATm90TnVsbABTb2Z0TnVsbABJc051bGwAWmVyb09yTnVsbABIYWx0SWZOdWxsAGNvbGwAY2FjaGVfc3BpbGwAUm93Q2VsbABjZWlsAGRldGFpbABwYWRsAHVuaXgtZXhjbAB0YmwAd2FsAHZpcnR1YWwAdG90YWwAaW5jcmVtZW50YWwAT3BlbkVwaGVtZXJhbABBZ2dGaW5hbABub3JtYWwASW5kZXggYWxyZWFkeSBvcHRpbWFsAHBhcnRpYWwAcmVhbABSZWFsAHBrAG9rAHVubGluawByZWFkbGluawBGaW5pc2hTZWVrAERlZmVycmVkU2VlawBub2xvY2sAQ3Vyc29yVW5sb2NrAGJsb2NrACVzLmxvY2sAQ3Vyc29yTG9jawBUYWJsZUxvY2sAaW50ZWdyaXR5X2NoZWNrAGZvcmVpZ25fa2V5X2NoZWNrAHF1aWNrX2NoZWNrAGNlbGxfc2l6ZV9jaGVjawBpbnRlZ3JpdHktY2hlY2sARmtDaGVjawBUeXBlQ2hlY2sAVkNoZWNrAEludGVncml0eUNrAHJlemkAbm9pdGF6aQBpdGl2aQBzc2VuZXZpAGl0aQBpc3Npc2kAaXNpc2kAcGkAbm9pAGduaQBzaXNzaWkAaXNzaXNpaQBzc3NpaWkAc2VpAGl0aWNpAGV0YWNpAGxhY2kAY290aABtb250aABqc29uX2FycmF5X2xlbmd0aABvY3RldF9sZW5ndGgAb3ZlcmZsb3cgbGlzdCBsZW5ndGgAd2R0aABzdGF0X3B1c2gAZmx1c2gAYWNvc2gAYXNpbmgAYXRhbmgAanNvbl9wYXRjaABqc29uYl9wYXRjaABkYXRhdHlwZSBtaXNtYXRjaABhcmd1bWVudCB0eXBlIG1pc21hdGNoAGFiYnJldmlhdGVkIHF1ZXJ5IGFsZ29yaXRobSBzZWFyY2gAdW5peGVwb2NoAHNxbGl0ZV9hdHRhY2gAc3FsaXRlX2RldGFjaABqc29uX2VhY2gAYXZnAG5hcmcAc3FsaXRlX2xvZwBzdGF0ZW1lbnQgdG9vIGxvbmcAY2Fubm90IG9wZW4gJXMgY29sdW1uIGZvciB3cml0aW5nAHN1YnN0cmluZwBTdHJpbmcAZW5jb2RpbmcAc3RyaW5nIG9yIGJsb2IgdG9vIGJpZwBzdHJpbmdfYWdnAFJlbGVhc2VSZWcAJS4xNmcAJSEwLjE1ZwAlIS4xNWcAc3Nlbmx1ZgBwcmludGYAdHlwZW9mAG1vZGVvZgBvdXQgb2YAcmVuYW1lIGNvbHVtbnMgb2YAaW5mAC1JbmYAbnVsbGlmAGlpZgBvZmYAdGltZWRpZmYAMDEyMzQ1Njc4OWFiY2RlZgBJZgAlYyUwNGQtJTAyZC0lMDJkICUwMmQ6JTAyZDolMDYuM2YAJS4zZgA1MGYANDBmACUhLipmAGdldHBhZ2VzaXplAGRvY3NpemUAbW1hcF9zaXplAGRlZmF1bHRfY2FjaGVfc2l6ZQBQUkFHTUEgJVEucGFnZV9zaXplAGZ0czN0b2tlbml6ZQBvcHRpbWl6ZQBqc29uX3JlbW92ZQBqc29uYl9yZW1vdmUATW92ZQBjYW5ub3QgY29tbWl0IC0gbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlAGNhbm5vdCByb2xsYmFjayAtIG5vIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZQBleGNsdXNpdmUAdHJ1ZQBJc1RydWUAdW5pcXVlAGRmbHRfdmFsdWUAQ2Fubm90IGFkZCBhIFJFRkVSRU5DRVMgY29sdW1uIHdpdGggbm9uLU5VTEwgZGVmYXVsdCB2YWx1ZQBBZ2dWYWx1ZQBqc29uX3F1b3RlAHB3cml0ZQBPcGVuV3JpdGUAb25fZGVsZXRlAHNlY3VyZV9kZWxldGUASWR4RGVsZXRlAHByaXZhdGUAYWdncmVnYXRlAFZDcmVhdGUAb25fdXBkYXRlAFZVcGRhdGUAY3VycmVudF9kYXRlAGZhbGxvY2F0ZQBmdHJ1bmNhdGUAcmVwbGljYXRlAGJhZCBwYXJhbWV0ZXIgb3Igb3RoZXIgQVBJIG1pc3VzZQB0b28gbWFueSB0ZXJtcyBpbiAlcyBCWSBjbGF1c2UAdG9vIG1hbnkgdGVybXMgaW4gT1JERVIgQlkgY2xhdXNlAGFnZ3JlZ2F0ZSBmdW5jdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGluIHRoZSBHUk9VUCBCWSBjbGF1c2UAUEFSVElUSU9OIGNsYXVzZQBhIE5BVFVSQUwgam9pbiBtYXkgbm90IGhhdmUgYW4gT04gb3IgVVNJTkcgY2xhdXNlAGRhdGFiYXNlICVzIGlzIGFscmVhZHkgaW4gdXNlAEFnZ0ludmVyc2UAcmV2ZXJzZQBjbG9zZQBDbG9zZQBmYWxzZQBhdHRlbXB0IHRvIHdyaXRlIGEgcmVhZG9ubHkgZGF0YWJhc2UAY29ycnVwdCBkYXRhYmFzZQBhdHRhY2hlZCBkYXRhYmFzZXMgbXVzdCB1c2UgdGhlIHNhbWUgdGV4dCBlbmNvZGluZyBhcyBtYWluIGRhdGFiYXNlAGZpbGUgaXMgbm90IGEgZGF0YWJhc2UAdGVtcF9zdG9yZQAlcyBjbGF1c2Ugc2hvdWxkIGNvbWUgYWZ0ZXIgJXMgbm90IGJlZm9yZQBFeHBpcmUAc3F1YXJlAGV4cHJfY29tcGFyZQBTb3J0ZXJDb21wYXJlAHN1YnR5cGUAU2V0U3VidHlwZQBHZXRTdWJ0eXBlAENsclN1YnR5cGUAanNvbl90eXBlAElzVHlwZQBJZk5vSG9wZQBpbHRuZQB1bml4LW5vbmUASW5pdENvcm91dGluZQBFbmRDb3JvdXRpbmUAaWNuZQBsb2NhbHRpbWUAc3RyZnRpbWUAZGF0ZXRpbWUAY3VycmVudF90aW1lAHRuZW1lAGFmdGVyIHJlbmFtZQBub24tdGV4dCBmaWxlbmFtZQBWUmVuYW1lAGFtYmlndW91cyBjb2x1bW4gbmFtZQB0ZW1wb3JhcnkgdHJpZ2dlciBtYXkgbm90IGhhdmUgcXVhbGlmaWVkIG5hbWUAc2ltcGxlAGxvd2VyX3F1YXJ0aWxlAHVwcGVyX3F1YXJ0aWxlAHVuaXgtZG90ZmlsZQBjYW5ub3Qgb3BlbiBmaWxlAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlIGZpbGUAaW1tdXRhYmxlAEFib3J0YWJsZQBsZWdhY3lfYWx0ZXJfdGFibGUAc3FsaXRlX3JlbmFtZV90YWJsZQBjYW5ub3QgY3JlYXRlIHRyaWdnZXIgb24gc3lzdGVtIHRhYmxlAHZpcnR1YWwgdGFibGUAbm8gc3VjaCB0YWJsZQBudW1iZXIgb2YgY29sdW1ucyBpbiBmb3JlaWduIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHJlZmVyZW5jZWQgdGFibGUAbG9jYWwgdGltZSB1bmF2YWlsYWJsZQBhbm90aGVyIHJvdyBhdmFpbGFibGUAbm8gbW9yZSByb3dzIGF2YWlsYWJsZQBWYXJpYWJsZQBEcm9wVGFibGUAdXRmMTZsZQBVVEYxNmxlAFVURi0xNmxlAGNhc2Vfc2Vuc2l0aXZlX2xpa2UAU2V0Q29va2llAFJlYWRDb29raWUAY2FjaGUAY29sdW1uIGluZGV4IG91dCBvZiByYW5nZQBub3RpZmljYXRpb24gbWVzc2FnZQB3YXJuaW5nIG1lc3NhZ2UAaW52YWxpZCByb290cGFnZQBFeHRlbmRzIG9mZiBlbmQgb2YgcGFnZQBNQVhfUEFHRV9DT1VOVD0weGZmZmZmZmZlAGpzb25fdHJlZQBDcmVhdGVCdHJlZQBkZWUAam91cm5hbF9tb2RlAGxvY2tpbmdfbW9kZQBvcGNvZGUAdW5pY29kZQBKb3VybmFsTW9kZQBEaXZpZGUAY29hbGVzY2UAc3FsaXRlX3NlcXVlbmNlAFNlcXVlbmNlAGRpZmZlcmVuY2UAdmFyaWFuY2UAT25jZQBUcmFjZQBqc29uX3JlcGxhY2UAanNvbmJfcmVwbGFjZQB1dGYxNmJlAFVURjE2YmUAVVRGLTE2YmUATmUATGUAR2UAMjBjOjIwZQAyMGI6MjBlACUhMC4yMGUAZ2V0Y3dkAE1ha2VSZWNvcmQAdGhzdG5kcmQAbGlrZWxpaG9vZABmY2htb2QAcm91bmQATm90Rm91bmQAc3Vic2Vjb25kAFJld2luZABTZWVrRW5kAEJpdEFuZABvbGQAJWxsZCAlbGxkAG5vIHN1Y2ggcm93aWQ6ICVsbGQAcmVidWlsZABZaWVsZABsYXN0X2luc2VydF9yb3dpZAAlcy5yb3dpZABTRUxFQ1QqRlJPTSIldyIuJXMgT1JERVIgQlkgcm93aWQAU0VMRUNUKkZST00iJXciLiVzIFdIRVJFICVzIE9SREVSIEJZIHJvd2lkAElkeFJvd2lkAE5ld1Jvd2lkAFNlZWtSb3dpZABnZXRldWlkAGludmFsaWQAanNvbl92YWxpZABma2lkAF9fbGFuZ2lkACV6LCBsYW5naWQAbGFuZ3VhZ2VpZABkb2NpZABhcHBsaWNhdGlvbl9pZABzcWxpdGVfc291cmNlX2lkAG5vdCBhdXRob3JpemVkAEluZGV4IG9wdGltaXplZABub3RpbmRleGVkAHVuYWJsZSB0byBpZGVudGlmeSB0aGUgb2JqZWN0IHRvIGJlIHJlaW5kZXhlZAB2aWV3cyBtYXkgbm90IGJlIGluZGV4ZWQAdmlydHVhbCB0YWJsZXMgbWF5IG5vdCBiZSBpbmRleGVkAHRhYmxlICVzIG1heSBub3QgYmUgaW5kZXhlZAByZWFkX3VuY29tbWl0dGVkAHJlY3Vyc2l2ZSBhZ2dyZWdhdGUgcXVlcmllcyBub3Qgc3VwcG9ydGVkAHF1ZXJ5IGFib3J0ZWQAcm93cyBpbnNlcnRlZABpbnRlcnJ1cHRlZABjaGVja3BvaW50ZWQAYWNjZXNzIHRvICV6IGlzIHByb2hpYml0ZWQAYWNjZXNzIHRvIHZpZXcgIiVzIiBwcm9oaWJpdGVkAHJvd3MgZGVsZXRlZABnZW5lcmF0ZWQAcm93cyB1cGRhdGVkAG5vdHVzZWQAcm93IHZhbHVlIG1pc3VzZWQAc3FsaXRlX2NvbXBpbGVvcHRpb25fdXNlZABQYWdlICV1OiBuZXZlciB1c2VkAENvbHVtbnNVc2VkAHN0b3JlZAB2aXJ0dWFsIHRhYmxlcyBtYXkgbm90IGJlIGFsdGVyZWQAdmlldyAlcyBtYXkgbm90IGJlIGFsdGVyZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBhbHRlcmVkAHNoYXJlZABpbmRleCBhc3NvY2lhdGVkIHdpdGggVU5JUVVFIG9yIFBSSU1BUlkgS0VZIGNvbnN0cmFpbnQgY2Fubm90IGJlIGRyb3BwZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBkcm9wcGVkAHZpZXcgJXMgaXMgY2lyY3VsYXJseSBkZWZpbmVkAHVub3BlbmVkAGRhdGFiYXNlIGRpc2sgaW1hZ2UgaXMgbWFsZm9ybWVkACVzIGNvbnN0cmFpbnQgZmFpbGVkAEZPUkVJR04gS0VZIGNvbnN0cmFpbnQgZmFpbGVkAGxhcmdlIGZpbGUgc3VwcG9ydCBpcyBkaXNhYmxlZABmdHMzdG9rZW5pemUgZGlzYWJsZWQAZGF0YWJhc2UgJXMgaXMgbG9ja2VkAGRhdGFiYXNlIGlzIGxvY2tlZABkYXRhYmFzZSB0YWJsZSBpcyBsb2NrZWQAYXV0aG9yaXphdGlvbiBkZW5pZWQAYWNjZXNzIHBlcm1pc3Npb24gZGVuaWVkAHRhYmxlICVTIGhhcyAlZCBjb2x1bW5zIGJ1dCAlZCB2YWx1ZXMgd2VyZSBzdXBwbGllZAB0ZW1wb3JhcnkgdGFibGUgbmFtZSBtdXN0IGJlIHVucXVhbGlmaWVkAHRhYmxlICVzIG1heSBub3QgYmUgbW9kaWZpZWQAY29uZmxpY3RpbmcgT04gQ09ORkxJQ1QgY2xhdXNlcyBzcGVjaWZpZWQAbm8gdGFibGVzIHNwZWNpZmllZABkYXRhYmFzZSBpcyBhbHJlYWR5IGF0dGFjaGVkAGRhdGFiYXNlIHNjaGVtYSBoYXMgY2hhbmdlZABleGNsdWRlZABQYWdlICV1OiBwb2ludGVyIG1hcCByZWZlcmVuY2VkAFJvd1NldEFkZABGaWx0ZXJBZGQAcHJlYWQAUm93U2V0UmVhZABPcGVuUmVhZAAlMDRkACUwM2QAJTAyZDolMDJkOiUwMmQAJTA0ZC0lMDJkLSUwMmQAJTJkADQwZi0yMWEtMjFkADUwZi0yMGEtMjBkADQwZi0yMGEtMjBkAHNxbGl0ZV9zdGF0JWQAY29sdW1uJWQAc3FsaXRlX2F1dG9pbmRleF8lc18lZAB2YXJpYWJsZSBudW1iZXIgbXVzdCBiZSBiZXR3ZWVuID8xIGFuZCA/JWQAdW5hYmxlIHRvIGdldCB0aGUgcGFnZS4gZXJyb3IgY29kZT0lZABrKCVkAFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCByb290cGFnZT0lZCBXSEVSRSAjJWQgQU5EIHJvb3RwYWdlPSMlZABVUERBVEUgJVEuc3FsaXRlX21hc3RlciBTRVQgdHlwZT0nJXMnLCBuYW1lPSVRLCB0YmxfbmFtZT0lUSwgcm9vdHBhZ2U9IyVkLCBzcWw9JVEgV0hFUkUgcm93aWQ9IyVkAFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0eXBlPSd0YWJsZScsIG5hbWU9JVEsIHRibF9uYW1lPSVRLCByb290cGFnZT0wLCBzcWw9JVEgV0hFUkUgcm93aWQ9IyVkAHRvbyBtYW55IGF0dGFjaGVkIGRhdGFiYXNlcyAtIG1heCAlZAB0b28gbWFueSBhcmd1bWVudHMgb24gJXMoKSAtIG1heCAlZABleHBlY3RlZCAlZCBjb2x1bW5zIGZvciAnJXMnIGJ1dCBnb3QgJWQAYXR0ZW1wdCB0byBvcGVuICIlcyIgYXMgZmlsZSBkZXNjcmlwdG9yICVkAGJ0cmVlSW5pdFBhZ2UoKSByZXR1cm5zIGVycm9yIGNvZGUgJWQAJXIgJXMgQlkgdGVybSBvdXQgb2YgcmFuZ2UgLSBzaG91bGQgYmUgYmV0d2VlbiAxIGFuZCAlZABzdWItc2VsZWN0IHJldHVybnMgJWQgY29sdW1ucyAtIGV4cGVjdGVkICVkAElOKC4uLikgZWxlbWVudCBoYXMgJWQgdGVybSVzIC0gZXhwZWN0ZWQgJWQAJXNMSVNUIFNVQlFVRVJZICVkAFJFVVNFIExJU1QgU1VCUVVFUlkgJWQAJXNTQ0FMQVIgU1VCUVVFUlkgJWQAUkVVU0UgU1VCUVVFUlkgJWQASU5ERVggJWQAdG9vIG1hbnkgRlJPTSBjbGF1c2UgdGVybXMsIG1heDogJWQAcndjAHV0YwBkZXNjAGFzYwBjaGVja3BvaW50X2Z1bGxmc3luYwBmdWxsX2ZzeW5jAGNoYXJpbmRleEZ1bmMAc3FydEZ1bmMAY290RnVuYwByaWdodEZ1bmMAbGVmdEZ1bmMAYWNvc0Z1bmMAZmxvb3JGdW5jAHBvd2VyRnVuYwBzdHJmaWx0ZXJGdW5jAHByb3BlckZ1bmMAcGFkckZ1bmMAZXhwRnVuYwBhc2luRnVuYwBzaWduRnVuYwBhdGFuRnVuYwBjZWlsRnVuYwBwYWRsRnVuYwBjb3RoRnVuYwBhY29zaEZ1bmMAYXNpbmhGdW5jAGF0YW5oRnVuYwBsb2dGdW5jAHJhZDJkZWdGdW5jAHJldmVyc2VGdW5jAFB1cmVGdW5jAHNxdWFyZUZ1bmMAZGlmZmVyZW5jZUZ1bmMAZGVnMnJhZEZ1bmMAcGFkY0Z1bmMAYXRuMkZ1bmMAbG9nMTBGdW5jAGVuYwBudW1lcmljADE9PWFyZ2MAU3FsRXhlYwBzdWJzZWMAcGFkYwAlLjRjJXMlLjE2YwBzcWxpdGUtc3JjL3NxbGl0ZS1hbWFsZ2FtYXRpb24tMzQ1MDIwMC9leHRlbnNpb24tZnVuY3Rpb25zLmMAJXMvZXRpbHFzXyVsbHglYwB1bnJlY29nbml6ZWQgbWF0Y2hpbmZvIHJlcXVlc3Q6ICVjAEdvc3ViAGdsb2IAemVyb2Jsb2IAcmFuZG9tYmxvYgBCbG9iAGpzb25iAGlsYgBpdGlsaWIAbWVtZGIAQVRUQUNIICVRIEFTIHZhY3V1bV9kYgByb3RhAGV2aXRhAGxhbm9pdGEAZXRhAFJvd0RhdGEAU29ydGVyRGF0YQBpY25hAHNxbGl0ZV90ZW1wX3NjaGVtYQBzcWxpdGVfc2NoZW1hAHdyaXRhYmxlX3NjaGVtYQB0cnVzdGVkX3NjaGVtYQBjb3JydXB0IHNjaGVtYQBQYXJzZVNjaGVtYQBpbGxhAGV6aWxhAGl0aWxhAG1zaWxhAHNxbGl0ZV8AcHJhZ21hXwBTUUxJVEVfAF9ST1dJRF8AJXMgYXQgbGluZSAlZCBvZiBbJS4xMHNdAGJpbmQgb24gYSBidXN5IHByZXBhcmVkIHN0YXRlbWVudDogWyVzXQBtYWxmb3JtZWQgTUFUQ0ggZXhwcmVzc2lvbjogWyVzXQBbJWxsZF0AW10AWwBMRUZULU1PU1QgU1VCUVVFUlkAQ09NUE9VTkQgUVVFUlkAQU5ZAGdlbmVyYXRlZCBjb2x1bW5zIGNhbm5vdCBiZSBwYXJ0IG9mIHRoZSBQUklNQVJZIEtFWQBBVVRPSU5DUkVNRU5UIGlzIG9ubHkgYWxsb3dlZCBvbiBhbiBJTlRFR0VSIFBSSU1BUlkgS0VZAGRvY2lkIElOVEVHRVIgUFJJTUFSWSBLRVkARk9SRUlHTiBLRVkAVVNFIFRFTVAgQi1UUkVFIEZPUiAlc09SREVSIEJZAEdST1VQIEJZAGlpc1gAaXNpWABBVVRPTUFUSUMgUEFSVElBTCBDT1ZFUklORyBJTkRFWABBVVRPTUFUSUMgQ09WRVJJTkcgSU5ERVgALW1qJTA2WDklMDJYAFNDQU4gQ09OU1RBTlQgUk9XAFZJRVcAanNvbl9vYmplY3QoKSBsYWJlbHMgbXVzdCBiZSBURVhUAEZJUlNUAExBU1QARVhDRVBUAE5PVAAgSU5UAElkeExUAFNlZWtMVABTRVQgREVGQVVMVABNVVRFWF9PTUlUAENPTU1JVABMSU1JVABSSUdIVABJZHhHVABTZWVrR1QATEVGVABESVNUSU5DVABSRVNUUklDVABJTlRFUlNFQ1QAdG9vIG1hbnkgdGVybXMgaW4gY29tcG91bmQgU0VMRUNUAHVua25vd24gam9pbiB0eXBlOiAlVCVzJVQlcyVUAC0lVAB0b28gbWFueSBhcmd1bWVudHMgb24gZnVuY3Rpb24gJVQAdW5rbm93biBkYXRhYmFzZSAlVABmb3JlaWduIGtleSBvbiAlcyBzaG91bGQgcmVmZXJlbmNlIG9ubHkgb25lIGNvbHVtbiBvZiB0YWJsZSAlVABDUkVBVEUgVklSVFVBTCBUQUJMRSAlVABoZXggbGl0ZXJhbCB0b28gYmlnOiAlcyUjVABubyBzdWNoIGZ1bmN0aW9uOiAlI1QAbm90IGF1dGhvcml6ZWQgdG8gdXNlIGZ1bmN0aW9uOiAlI1QAREVGQVVMVF9SRUNVUlNJVkVfVFJJR0dFUlMARU5BQkxFX0ZUUzNfUEFSRU5USEVTSVMARElTQUJMRV9MRlMAJXMgJVMAbm8gc3VjaCBpbmRleDogJVMAY2Fubm90IGNyZWF0ZSAlcyB0cmlnZ2VyIG9uIHZpZXc6ICVTAG5vIHN1Y2ggdHJpZ2dlcjogJVMAY2Fubm90IGNyZWF0ZSBJTlNURUFEIE9GIHRyaWdnZXIgb24gdGFibGU6ICVTAE1BVEVSSUFMSVpFICUhUwBDTy1ST1VUSU5FICUhUwBVU0lORyBJTkRFWCAlcyBGT1IgSU4tT1BFUkFUT1IAVVNJTkcgUk9XSUQgU0VBUkNIIE9OIFRBQkxFICVzIEZPUiBJTi1PUEVSQVRPUgBNVUxUSS1JTkRFWCBPUgBTUUxJVEVfVE1QRElSAEFGVEVSAElOVEVHRVIAT1JERVIATkVBUgBERUxFVEUgRlJPTSAlUS4lcyBXSEVSRSAlcz0lUQBuYW1lPSVRIEFORCBzcWw9JVEAREVMRVRFIEZST00gJVEuc3FsaXRlX3NlcXVlbmNlIFdIRVJFIG5hbWU9JVEALCB4LiVRAFNFTEVDVCAqIEZST00gJVEuJVEAVVBEQVRFICIldyIuc3FsaXRlX3NlcXVlbmNlIHNldCBuYW1lID0gJVEgV0hFUkUgbmFtZSA9ICVRAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHByaW50ZignJSUuJWRzLCAnLHNxbCkgfHwgJVEgfHwgc3Vic3RyKHNxbCwxK2xlbmd0aChwcmludGYoJyUlLiVkcycsc3FsKSkpIFdIRVJFIHR5cGUgPSAndGFibGUnIEFORCBuYW1lID0gJVEAYmFkIEpTT04gcGF0aDogJVEAU0VUVVAAR1JPVVAAUkVDVVJTSVZFIFNURVAAU05hTgBRTmFOAG1hbGZvcm1lZCBKU09OAE5PIEFDVElPTgBPTUlUX0xPQURfRVhURU5TSU9OAFVOSU9OACBMRUZULUpPSU4AQkVHSU4ALGFyZyBISURERU4ALHNjaGVtYSBISURERU4AU0NBTgBERUZBVUxUX0FVVE9WQUNVVU0AIE5VTQBQTQBSVFJJTQBBTQBDYW5ub3QgYWRkIGEgTk9UIE5VTEwgY29sdW1uIHdpdGggZGVmYXVsdCB2YWx1ZSBOVUxMAE5PVCBOVUxMAFNFVCBOVUxMAFNFTEVDVCAxIEZST00gJVEuJyVxX3NlZ21lbnRzJyBXSEVSRSBibG9ja2lkPT8gQU5EIGJsb2NrIElTIE5VTEwAVU5JT04gQUxMACBSRUFMAENIRUNLAGFib3J0IGR1ZSB0byBST0xMQkFDSwBNQVRDSABTRUFSQ0gAVVNJTkcARU5BQkxFX05PUk1BTElaRQAgVU5JUVVFAERFTEVURQBVUERBVEUAUkVMRUFTRQBOT0NBU0UAQkVGT1JFAE5PTkUASWR4TEUAU2Vla0xFAFRBQkxFADE2TEUASWR4R0UAU2Vla0dFACVzIFVTSU5HIFRFTVAgQi1UUkVFAENBU0NBREUAMTZCRQBBTkQAUk9XSUQAT0lEAERJUkVDVF9PVkVSRkxPV19SRUFEAERFU0MAU0VMRUNUIGlkeCwgc3RhcnRfYmxvY2ssIGxlYXZlc19lbmRfYmxvY2ssIGVuZF9ibG9jaywgcm9vdCBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPyBPUkRFUiBCWSBpZHggQVNDAFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID9PUkRFUiBCWSBsZXZlbCBERVNDLCBpZHggQVNDAFNFTEVDVCBsZXZlbCwgaWR4LCBlbmRfYmxvY2sgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCBCRVRXRUVOID8gQU5EID8gT1JERVIgQlkgbGV2ZWwgREVTQywgaWR4IEFTQwBTRUxFQ1QgaWR4IEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWw9PyBPUkRFUiBCWSAxIEFTQwBTWVNURU1fTUFMTE9DAEJMT0IAQkJCAEAAVVBEQVRFIE9SIEZBSUwgJVEuJyVxX3NlZ2RpcicgU0VUIGxldmVsPS0xLGlkeD0/IFdIRVJFIGxldmVsPT8gQU5EIGlkeD0/AFVQREFURSAlUS4nJXFfc2VnZGlyJyBTRVQgaWR4ID0gPyBXSEVSRSBsZXZlbD0/IEFORCBpZHg9PwAlcz0/AFNFTEVDVCAlcyBXSEVSRSByb3dpZD0/AFNFTEVDVCBzaXplIEZST00gJVEuJyVxX2RvY3NpemUnIFdIRVJFIGRvY2lkPT8AU0VMRUNUIHZhbHVlIEZST00gJVEuJyVxX3N0YXQnIFdIRVJFIGlkPT8APyw/LD8AREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/AFNFTEVDVCBtYXgobGV2ZWwpIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgQkVUV0VFTiA/IEFORCA/AERFTEVURSBGUk9NICVRLiclcV9zZWdtZW50cycgV0hFUkUgYmxvY2tpZCBCRVRXRUVOID8gQU5EID8AVVBEQVRFICVRLiclcV9zZWdkaXInIFNFVCBzdGFydF9ibG9jayA9ID8sIHJvb3QgPSA/V0hFUkUgbGV2ZWwgPSA/IEFORCBpZHggPSA/AFNFTEVDVCBpZHgsIHN0YXJ0X2Jsb2NrLCBsZWF2ZXNfZW5kX2Jsb2NrLCBlbmRfYmxvY2ssIHJvb3QgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8gQU5EIGlkeCA9ID8AREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicgV0hFUkUgbGV2ZWwgPSA/IEFORCBpZHggPSA/AERFTEVURSBGUk9NICVRLiclcV9zZWdkaXInIFdIRVJFIGxldmVsID0gPwBTRUxFQ1QgY291bnQoKikgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8AU0VMRUNUICVzIFdIRVJFIHJvd2lkID0gPwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcgV0hFUkUgcm93aWQgPSA/AERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJyBXSEVSRSBkb2NpZCA9ID8ALCA/ADxleHByPgA8Yj4APGI+Li4uPC9iPgAtPj4ALT4Ac2VwYXJhdG9ycz0AdG9rZW5jaGFycz0AYXV0b21lcmdlPQA8AElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCdpbmRleCcsJVEsJVEsIyVkLCVRKTsAQ1JFQVRFIFRBQkxFICVRLiclcV9zZWdtZW50cycoYmxvY2tpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBibG9jayBCTE9CKTsAQ1JFQVRFIFRBQkxFICVRLiclcV9kb2NzaXplJyhkb2NpZCBJTlRFR0VSIFBSSU1BUlkgS0VZLCBzaXplIEJMT0IpOwBDUkVBVEUgVEFCTEUgSUYgTk9UIEVYSVNUUyAlUS4nJXFfc3RhdCcoaWQgSU5URUdFUiBQUklNQVJZIEtFWSwgdmFsdWUgQkxPQik7AENSRUFURSBUQUJMRSAlUS4nJXFfc2VnZGlyJyhsZXZlbCBJTlRFR0VSLGlkeCBJTlRFR0VSLHN0YXJ0X2Jsb2NrIElOVEVHRVIsbGVhdmVzX2VuZF9ibG9jayBJTlRFR0VSLGVuZF9ibG9jayBJTlRFR0VSLHJvb3QgQkxPQixQUklNQVJZIEtFWShsZXZlbCwgaWR4KSk7AFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0YmxfbmFtZSA9ICVRLCBuYW1lID0gQ0FTRSBXSEVOIHR5cGU9J3RhYmxlJyBUSEVOICVRIFdIRU4gbmFtZSBMSUtFICdzcWxpdGVYX2F1dG9pbmRleCUlJyBFU0NBUEUgJ1gnICAgICAgQU5EIHR5cGU9J2luZGV4JyBUSEVOICdzcWxpdGVfYXV0b2luZGV4XycgfHwgJVEgfHwgc3Vic3RyKG5hbWUsJWQrMTgpIEVMU0UgbmFtZSBFTkQgV0hFUkUgdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICh0eXBlPSd0YWJsZScgT1IgdHlwZT0naW5kZXgnIE9SIHR5cGU9J3RyaWdnZXInKTsARFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX3NlZ21lbnRzJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfc2VnZGlyJztEUk9QIFRBQkxFIElGIEVYSVNUUyAlUS4nJXFfZG9jc2l6ZSc7RFJPUCBUQUJMRSBJRiBFWElTVFMgJVEuJyVxX3N0YXQnOyVzIERST1AgVEFCTEUgSUYgRVhJU1RTICVRLiclcV9jb250ZW50JzsAQUxURVIgVEFCTEUgJVEuJyVxX2NvbnRlbnQnICBSRU5BTUUgVE8gJyVxX2NvbnRlbnQnOwBBTFRFUiBUQUJMRSAlUS4nJXFfc3RhdCcgIFJFTkFNRSBUTyAnJXFfc3RhdCc7AEFMVEVSIFRBQkxFICVRLiclcV9zZWdtZW50cycgUkVOQU1FIFRPICclcV9zZWdtZW50cyc7AEFMVEVSIFRBQkxFICVRLiclcV9zZWdkaXInICAgUkVOQU1FIFRPICclcV9zZWdkaXInOwBBTFRFUiBUQUJMRSAlUS4nJXFfZG9jc2l6ZScgIFJFTkFNRSBUTyAnJXFfZG9jc2l6ZSc7ADptZW1vcnk6AGZpbGU6AC05ZTk5OQA5LjBlOTk5ACstIAoJMDEyMzQ1Njc4OQBcdTAwMDkAU3RyaW5nOAB1dGY4AFVURjgAVVRGLTgAMjAyNC0wMy0xMiAxMTowNjoyMyBkOGNkNmQ0OWI0NmEzOTViMTM5NTUzODdkMDVlOWUxYTJhNDdlNTRmYjk5ZjNjOWI1OTgzNWJiZWZhZDZhZjc3AE1BWF9GVU5DVElPTl9BUkc9MTI3AERFRkFVTFRfU0VDVE9SX1NJWkU9NDA5NgBERUZBVUxUX1BBR0VfU0laRT00MDk2AE1BWF9WQVJJQUJMRV9OVU1CRVI9MzI3NjYATUFYX1BBR0VfU0laRT02NTUzNgBVVEYxNgBVVEYtMTYAcDUAdG9vIG1hbnkgcmVmZXJlbmNlcyB0byAiJXMiOiBtYXggNjU1MzUARkxBR1MgcGFyYW1ldGVyIHRvIGpzb25fdmFsaWQoKSBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMTUAc3FsaXRlX3N0YXQ0AGZ0czQAcDQAREVGQVVMVF9GSUxFX0ZPUk1BVD00AEludDY0AHB3cml0ZTY0AHByZWFkNjQATUFMTE9DX1NPRlRfTElNSVQ9MTAyNABzcWxpdGVfc3RhdDMAU0FWRVBPSU5UIGZ0czMAUk9MTEJBQ0sgVE8gZnRzMwBSRUxFQVNFIGZ0czMAcDMARU5BQkxFX0ZUUzMAcDIAYXRuMgBhdGFuMgByZW1vdmVfZGlhY3JpdGljcz0yAERFRkFVTFRfU1lOQ0hST05PVVM9MgBERUZBVUxUX1dBTF9TWU5DSFJPTk9VUz0yAGFyZ2M9PTMgfHxhcmdjPT0yAE1BWF9ERUZBVUxUX1BBR0VfU0laRT04MTkyAFNFTEVDVCB0YmwsaWR4LHN0YXQgRlJPTSAlUS5zcWxpdGVfc3RhdDEAQWdnU3RlcDEAcmVtb3ZlX2RpYWNyaXRpY3M9MQBBVE9NSUNfSU5UUklOU0lDUz0xAFRFTVBfU1RPUkU9MQBhcmdjPT0xAHVuaWNvZGU2MQBVUERBVEUgT1IgRkFJTCAlUS4nJXFfc2VnZGlyJyBTRVQgbGV2ZWw9PyBXSEVSRSBsZXZlbD0tMQBERUZBVUxUX0pPVVJOQUxfU0laRV9MSU1JVD0tMQBTRUxFQ1QgbGV2ZWwsIGNvdW50KCopIEFTIGNudCBGUk9NICVRLiclcV9zZWdkaXInICAgR1JPVVAgQlkgbGV2ZWwgSEFWSU5HIGNudD49PyAgT1JERVIgQlkgKGxldmVsICUlIDEwMjQpIEFTQywgMiBERVNDIExJTUlUIDEAU0VMRUNUIChTRUxFQ1QgbWF4KGlkeCkgRlJPTSAlUS4nJXFfc2VnZGlyJyBXSEVSRSBsZXZlbCA9ID8pICsgMQBTRUxFQ1QnSU5TRVJUIElOVE8gdmFjdXVtX2RiLid8fHF1b3RlKG5hbWUpfHwnIFNFTEVDVCpGUk9NIiV3Ii4nfHxxdW90ZShuYW1lKUZST00gdmFjdXVtX2RiLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIGNvYWxlc2NlKHJvb3RwYWdlLDEpPjAAU0VMRUNUIHNxbCBGUk9NICIldyIuc3FsaXRlX3NjaGVtYSBXSEVSRSB0eXBlPSd0YWJsZSdBTkQgbmFtZTw+J3NxbGl0ZV9zZXF1ZW5jZScgQU5EIGNvYWxlc2NlKHJvb3RwYWdlLDEpPjAAcmVtb3ZlX2RpYWNyaXRpY3M9MABNQVhfV09SS0VSX1RIUkVBRFM9MABERUZBVUxUX1dPUktFUl9USFJFQURTPTAATUFYX01NQVBfU0laRT0wAERFRkFVTFRfTU1BUF9TSVpFPTAAVEhSRUFEU0FGRT0wADkyMjMzNzIwMzY4NTQ3NzU4MABERUZBVUxUX1BDQUNIRV9JTklUU1o9MjAAbG9nMTAATUFYX0FUVEFDSEVEPTEwAFx1MDAATUFYX0NPTVBPVU5EX1NFTEVDVD01MDAAPzAwMABNQVhfQ09MVU1OPTIwMDAAREVGQVVMVF9DQUNIRV9TSVpFPS0yMDAwAERFRkFVTFRfV0FMX0FVVE9DSEVDS1BPSU5UPTEwMDAATUFYX0VYUFJfREVQVEg9MTAwMABNQVhfVFJJR0dFUl9ERVBUSD0xMDAwAFx1MDAwMABNQVhfTElLRV9QQVRURVJOX0xFTkdUSD01MDAwMABNQVhfVkRCRV9PUD0yNTAwMDAwMDAATUFYX0xFTkdUSD0xMDAwMDAwMDAwAE1BWF9TUUxfTEVOR1RIPTEwMDAwMDAwMDAAc2Vjb25kIGFyZ3VtZW50IHRvICUjVCgpIG11c3QgYmUgYSBjb25zdGFudCBiZXR3ZWVuIDAuMCBhbmQgMS4wAENPTVBJTEVSPWNsYW5nLTE5LjAuMAAvcHJvYy9zZWxmL2ZkLwAlUS4ATi4ALS0ALABub3NraXBzY2FuKgB1bm9yZGVyZWQqAHN6PVswLTldKgAoc3VicXVlcnktJXUpAChqb2luLSV1KQBCYWQgcHRyIG1hcCBlbnRyeSBrZXk9JXUgZXhwZWN0ZWQ9KCV1LCV1KSBnb3Q9KCV1LCV1KQBtYXggcm9vdHBhZ2UgKCV1KSBkaXNhZ3JlZXMgd2l0aCBoZWFkZXIgKCV1KQBDUkVBVEUgVEFCTEUgeCh0eXBlIHRleHQsbmFtZSB0ZXh0LHRibF9uYW1lIHRleHQscm9vdHBhZ2UgaW50LHNxbCB0ZXh0KQBDUkVBVEUgVEFCTEUgJVEuJXMoJXMpAGF1dG9tYXRpYyBpbmRleCBvbiAlcyglcykAQU5ZKCVzKQBJTlNFUlQgSU5UTyAlUS4nJXFfY29udGVudCcgVkFMVUVTKCVzKQBDUkVBVEUgVEFCTEUgJVEuJyVxX2NvbnRlbnQnKCVzKQBtYWxmb3JtZWQgZGF0YWJhc2Ugc2NoZW1hICglcykATUVSR0UgKCVzKQBDUkVBVEUgVEFCTEUgJVEuc3FsaXRlX3NlcXVlbmNlKG5hbWUsc2VxKQBDUkVBVEUgVEFCTEUgeChpbnB1dCwgdG9rZW4sIHN0YXJ0LCBlbmQsIHBvc2l0aW9uKQBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfZHJvcF9jb2x1bW4oJWQsIHNxbCwgJWQpIFdIRVJFICh0eXBlPT0ndGFibGUnIEFORCB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSkAbWVtZGIoJXAsJWxsZCkAJXMoJWQpAHplcm9ibG9iKCVkKQBGVFMgZXhwcmVzc2lvbiB0cmVlIGlzIHRvbyBsYXJnZSAobWF4aW11bSBkZXB0aCAlZCkARXhwcmVzc2lvbiB0cmVlIGlzIHRvbyBsYXJnZSAobWF4aW11bSBkZXB0aCAlZCkAKGJsb2IpAFVTRSBURU1QIEItVFJFRSBGT1IgJXMoT1JERVIgQlkpAFVTRSBURU1QIEItVFJFRSBGT1IgJXMoRElTVElOQ1QpAFBSQUdNQSAiJXciLmludGVncml0eV9jaGVjayglUSkAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gc3FsaXRlX3JlbmFtZV9jb2x1bW4oc3FsLCB0eXBlLCBuYW1lLCAlUSwgJVEsICVkLCAlUSwgJWQsICVkKSBXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnICBBTkQgKHR5cGUgIT0gJ2luZGV4JyBPUiB0YmxfbmFtZSA9ICVRKQBDUkVBVEUgVEFCTEUgeChrZXksdmFsdWUsdHlwZSxhdG9tLGlkLHBhcmVudCxmdWxsa2V5LHBhdGgsanNvbiBISURERU4scm9vdCBISURERU4pAENSRUFURSBUQUJMRSB4KHRlcm0sIGNvbCwgZG9jdW1lbnRzLCBvY2N1cnJlbmNlcywgbGFuZ3VhZ2VpZCBISURERU4pAENSRUFURSBUQUJMRSB4KCVzICVRIEhJRERFTiwgZG9jaWQgSElEREVOLCAlUSBISURERU4pAChOVUxMKQAlYz8pAFNFTEVDVCBOT1QgRVhJU1RTKFNFTEVDVCBkb2NpZCBGUk9NICVRLiclcV9jb250ZW50JyBXSEVSRSByb3dpZCE9PykAUkVQTEFDRSBJTlRPICVRLiclcV9zZWdkaXInIFZBTFVFUyg/LD8sPyw/LD8sPykAUkVQTEFDRSBJTlRPICVRLiclcV9zdGF0JyBWQUxVRVMoPyw/KQBSRVBMQUNFIElOVE8gJVEuJyVxX2RvY3NpemUnIFZBTFVFUyg/LD8pACwlcyg/KQBSRVBMQUNFIElOVE8gJVEuJyVxX3NlZ21lbnRzJyhibG9ja2lkLCBibG9jaykgVkFMVUVTKD8sID8pAFNFTEVDVCBjb2FsZXNjZSgoU0VMRUNUIG1heChibG9ja2lkKSBGUk9NICVRLiclcV9zZWdtZW50cycpICsgMSwgMSkASU5TRVJUIElOVE8gdmFjdXVtX2RiLnNxbGl0ZV9zY2hlbWEgU0VMRUNUKkZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGUgSU4oJ3ZpZXcnLCd0cmlnZ2VyJykgT1IodHlwZT0ndGFibGUnQU5EIHJvb3RwYWdlPTApAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gc25pcHBldCgpAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICVzKCkAbWlzdXNlIG9mICVzIGZ1bmN0aW9uICUjVCgpAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJSNUKCkAdW5zYWZlIHVzZSBvZiAlI1QoKQBPUkRFUiBCWSBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAEZJTFRFUiBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAHVua25vd24gZnVuY3Rpb246ICUjVCgpAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICUjVCgpAGFtYmlndW91cyByZWZlcmVuY2UgdG8gJXMgaW4gVVNJTkcoKQBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX2NvbHVtbihzcWwsIHR5cGUsIG5hbWUsICVRLCAlUSwgJWQsICVRLCAlZCwgMSkgV0hFUkUgdHlwZSBJTiAoJ3RyaWdnZXInLCAndmlldycpAFVQREFURSBzcWxpdGVfdGVtcF9zY2hlbWEgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfdGFibGUoJVEsIHR5cGUsIG5hbWUsIHNxbCwgJVEsICVRLCAxKSwgdGJsX25hbWUgPSBDQVNFIFdIRU4gdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICAgc3FsaXRlX3JlbmFtZV90ZXN0KCVRLCBzcWwsIHR5cGUsIG5hbWUsIDEsICdhZnRlciByZW5hbWUnLCAwKSBUSEVOICVRIEVMU0UgdGJsX25hbWUgRU5EIFdIRVJFIHR5cGUgSU4gKCd2aWV3JywgJ3RyaWdnZXInKQAsJXMoeC4nYyVkJXEnKQBJTlNFUlQgSU5UTyAlUS5zcWxpdGVfbWFzdGVyIFZBTFVFUygndHJpZ2dlcicsJVEsJVEsMCwnQ1JFQVRFIFRSSUdHRVIgJXEnKQBJTlNFUlQgSU5UTyAlUS4lUSglUSkgVkFMVUVTKCdmbHVzaCcpAFNFTEVDVCAyICogdG90YWwoMSArIGxlYXZlc19lbmRfYmxvY2sgLSBzdGFydF9ibG9jaykgICBGUk9NIChTRUxFQ1QgKiBGUk9NICVRLiclcV9zZWdkaXInICAgICAgICAgV0hFUkUgbGV2ZWwgPSA/IE9SREVSIEJZIGlkeCBBU0MgTElNSVQgPyAgKQAKKQBCTE9PTSBGSUxURVIgT04gJVMgKABTRUxFQ1Qgc3FsIEZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGU9J2luZGV4JwBERUxFVEUgRlJPTSAlUS5zcWxpdGVfbWFzdGVyIFdIRVJFIG5hbWU9JVEgQU5EIHR5cGU9J2luZGV4JwBuYW1lPSclcScgQU5EIHR5cGU9J2luZGV4JwBERUxFVEUgRlJPTSAlUS4nJXFfY29udGVudCcAREVMRVRFIEZST00gJVEuJyVxX3N0YXQnAERFTEVURSBGUk9NICVRLiclcV9zZWdtZW50cycAREVMRVRFIEZST00gJVEuJyVxX3NlZ2RpcicAU0VMRUNUID8gVU5JT04gU0VMRUNUIGxldmVsIC8gKDEwMjQgKiA/KSBGUk9NICVRLiclcV9zZWdkaXInAFNFTEVDVCBtYXgoIGxldmVsICUlIDEwMjQgKSBGUk9NICVRLiclcV9zZWdkaXInAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0ndHJpZ2dlcicAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0lUSBhbmQgdHlwZSE9J3RyaWdnZXInAHRibF9uYW1lPSclcScgQU5EIHR5cGUhPSd0cmlnZ2VyJwAnJS4qcScAJXosICdjJWQlcScAdHlwZT0ndHJpZ2dlcicgQU5EIG5hbWU9JyVxJwAsIHguJyVxJwBpbmRleCAnJXEnAERFTEVURSBGUk9NICVRLiclcV9kb2NzaXplJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3RhYmxlKCVRLCB0eXBlLCBuYW1lLCBzcWwsICVRLCAlUSwgJWQpIFdIRVJFICh0eXBlIT0naW5kZXgnIE9SIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlKUFORCAgIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcAU0VMRUNUIENBU0UgV0hFTiBxdWlja19jaGVjayBHTE9CICdDSEVDSyonIFRIRU4gcmFpc2UoQUJPUlQsJ0NIRUNLIGNvbnN0cmFpbnQgZmFpbGVkJykgV0hFTiBxdWlja19jaGVjayBHTE9CICdub24tKiB2YWx1ZSBpbionIFRIRU4gcmFpc2UoQUJPUlQsJ3R5cGUgbWlzbWF0Y2ggb24gREVGQVVMVCcpIEVMU0UgcmFpc2UoQUJPUlQsJ05PVCBOVUxMIGNvbnN0cmFpbnQgZmFpbGVkJykgRU5EICBGUk9NIHByYWdtYV9xdWlja19jaGVjayglUSwlUSkgV0hFUkUgcXVpY2tfY2hlY2sgR0xPQiAnQ0hFQ0sqJyBPUiBxdWlja19jaGVjayBHTE9CICdOVUxMKicgT1IgcXVpY2tfY2hlY2sgR0xPQiAnbm9uLSogdmFsdWUgaW4qJwBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCVRLCBzcWwpV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyBBTkQgc3FsIE5PVCBMSUtFICdjcmVhdGUgdmlydHVhbCUlJwBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX3F1b3RlZml4KCd0ZW1wJywgc3FsKVdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScAc3FsaXRlXF8lACQAU0VMRUNUKkZST00iJXciAFNFTEVDVCpGUk9NIiV3Ii4iJXciAFNFTEVDVCByYWlzZShBQk9SVCwlUSkgRlJPTSAiJXciLiIldyIAQU5BTFlaRSAiJXciLiIldyIAZm9yZWlnbiBrZXkgbWlzbWF0Y2ggLSAiJXciIHJlZmVyZW5jaW5nICIldyIAZG91YmxlLXF1b3RlZCBzdHJpbmcgbGl0ZXJhbDogIiV3IgAuIiUuKnMiAHN5bnRheCBlcnJvciBhZnRlciBjb2x1bW4gbmFtZSAiJS4qcyIAJWMiJXMiACgiJXMiAGNhbm5vdCAlcyAlcyAiJXMiAGdlbmVyYXRlZCBjb2x1bW4gbG9vcCBvbiAiJXMiAGNhbm5vdCBJTlNFUlQgaW50byBnZW5lcmF0ZWQgY29sdW1uICIlcyIAZXJyb3IgaW4gZ2VuZXJhdGVkIGNvbHVtbiAiJXMiAGNhbm5vdCBVUERBVEUgZ2VuZXJhdGVkIGNvbHVtbiAiJXMiACVzIGluICIlcyIAdHJpZ2dlciAiJXMiIG1heSBub3Qgd3JpdGUgdG8gc2hhZG93IHRhYmxlICIlcyIAVVBTRVJUIG5vdCBpbXBsZW1lbnRlZCBmb3IgdmlydHVhbCB0YWJsZSAiJXMiAHVuc2FmZSB1c2Ugb2YgdmlydHVhbCB0YWJsZSAiJXMiAGNhbm5vdCBjcmVhdGUgYSBURU1QIGluZGV4IG9uIG5vbi1URU1QIHRhYmxlICIlcyIAbm8gc3VjaCBpbmRleDogIiVzIgB1bmtub3duIGRhdGF0eXBlIGZvciAlcy4lczogIiVzIgBjYW5ub3QgZHJvcCAlcyBjb2x1bW46ICIlcyIAbm8gc3VjaCBjb2x1bW46ICIlcyIAXCIAbm8gc3VjaCBjb2x1bW46ICIlVCIAdW5yZWNvZ25pemVkIHRva2VuOiAiJVQiAC4iAHdlZWtkYXkgAG5vbi11bmlxdWUgZW50cnkgaW4gaW5kZXggAHdyb25nICMgb2YgZW50cmllcyBpbiBpbmRleCAAIHZhbHVlcyBkaWZmZXIgZnJvbSBpbmRleCAAIG1pc3NpbmcgZnJvbSBpbmRleCAAIG9mIGluZGV4IAByb3dpZCBub3QgYXQgZW5kLW9mLXJlY29yZCBmb3Igcm93IAAlciAAc3RhcnQgb2YgACVkICVkICVkICVkIAAgVVNJTkcgQ09WRVJJTkcgSU5ERVggAFNFTEVDVCAxIEZST00gIiV3Ii5zcWxpdGVfbWFzdGVyIFdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgQU5EIHNxbCBOT1QgTElLRSAnY3JlYXRlIHZpcnR1YWwlJScgQU5EIHNxbGl0ZV9yZW5hbWVfdGVzdCglUSwgc3FsLCB0eXBlLCBuYW1lLCAlZCwgJVEsICVkKT1OVUxMIABTRUxFQ1QgMSBGUk9NIHRlbXAuc3FsaXRlX21hc3RlciBXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnIEFORCBzcWwgTk9UIExJS0UgJ2NyZWF0ZSB2aXJ0dWFsJSUnIEFORCBzcWxpdGVfcmVuYW1lX3Rlc3QoJVEsIHNxbCwgdHlwZSwgbmFtZSwgMSwgJVEsICVkKT1OVUxMIAAgVVNJTkcgAFJJR0hUIFBBUlQgT0YgAENSRUFURSAAQ1JFQVRFIFRBQkxFIAAgQU5EIABDT1JSRUxBVEVEIABQUkFHTUEgAFRyZWUgJXUgcGFnZSAldSBjZWxsICV1OiAAVHJlZSAldSBwYWdlICV1OiAARnJlZWxpc3Q6IABUcmVlICV1IHBhZ2UgJXUgcmlnaHQgY2hpbGQ6IAAtLSAAJXolUSwgACIldyIgAEAgIAAsCiAgACoqKiBpbiBkYXRhYmFzZSAlcyAqKioKAABkCgEQAABzAAQFAABnAAEDHgB6AAQGAABxAAQJAABRAAQKAAB3AAQOAABjAAAIAABvCAAAAAJ1CgAQAAB4EAAAEAFYEAAAAARmAAEBAABlAAECHgBFAAECDgBHAAEDDgBpCgEQAABuAAAEAAAlAAAHAABwEAANAAFUAAALAABTAAAMAAByCgEPAAAAAAAAAAAwMTIzNDU2Nzg5QUJDREVGMDEyMzQ1Njc4OWFiY2RlZgAteDAAWDAAQaDwAQuQA2V4cGFuZCAzMi1ieXRlIGsAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6W1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4CBgoOEhYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6SlpqeoqaqrrK2ur7CxsrO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09TV1tfY2drb3N3e3+Dh4uPk5ebn6Onq6+zt7u/w8fLz9PX29/j5+vv8/f7/AQAAAQEAAAEAAQABAQABAAABAACEAAAAhQAAAIYAAAAEBQMFAQUBBQIFAgUBBQEFBAUDBQEFAQUCBQIFAQUBBQIFAgUCBQIFAgUCBQIFAgUEBQMFAgUCBQIFAgUCBQIFqQAAAHAAAAAfAAUBXgAAAVQBAABGAAAAKj9bACVfAAEAQbnzAQsFAQEBAQEAQdDzAQv6BgEAgABAAACAAAAAAAAAAAAMDAwMDAwMDAwMAAAAAAAAAAoKCgoKCgICAgICAgICAgICAgICAgICAgICgAAAAECAKioqKioqIiIiIiIiIiIiIiIiIiIiIiIiIiIAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAUkVJTkRFWEVERVNDQVBFQUNIRUNLRVlCRUZPUkVJR05PUkVHRVhQTEFJTlNURUFEREFUQUJBU0VMRUNUQUJMRUZUSEVOREVGRVJSQUJMRUxTRVhDTFVERUxFVEVNUE9SQVJZSVNOVUxMU0FWRVBPSU5URVJTRUNUSUVTTk9UTlVMTElLRVhDRVBUUkFOU0FDVElPTkFUVVJBTFRFUkFJU0VYQ0xVU0lWRVhJU1RTQ09OU1RSQUlOVE9GRlNFVFJJR0dFUkFOR0VORVJBVEVERVRBQ0hBVklOR0xPQkVHSU5ORVJFRkVSRU5DRVNVTklRVUVSWVdJVEhPVVRFUkVMRUFTRUFUVEFDSEJFVFdFRU5PVEhJTkdST1VQU0NBU0NBREVGQVVMVENBU0VDT0xMQVRFQ1JFQVRFQ1VSUkVOVF9EQVRFSU1NRURJQVRFSk9JTlNFUlRNQVRDSFBMQU5BTFlaRVBSQUdNQVRFUklBTElaRURFRkVSUkVESVNUSU5DVFVQREFURVZBTFVFU1ZJUlRVQUxXQVlTV0hFTldIRVJFQ1VSU0lWRUFCT1JUQUZURVJFTkFNRUFORFJPUEFSVElUSU9OQVVUT0lOQ1JFTUVOVENBU1RDT0xVTU5DT01NSVRDT05GTElDVENST1NTQ1VSUkVOVF9USU1FU1RBTVBSRUNFRElOR0ZBSUxBU1RGSUxURVJFUExBQ0VGSVJTVEZPTExPV0lOR0ZST01GVUxMSU1JVElGT1JERVJFU1RSSUNUT1RIRVJTT1ZFUkVUVVJOSU5HUklHSFRST0xMQkFDS1JPV1NVTkJPVU5ERURVTklPTlVTSU5HVkFDVVVNVklFV0lORE9XQllJTklUSUFMTFlQUklNQVJZAEHU+gELpAICAAIACAAJAA4AEAAUABcAGQAZAB0AIQAkACkALgAwADUANgA7AD4AQQBDAEUATgBRAFYAWgBaAF4AYwBlAGkAbwB3AHsAewB7AH4AgQCEAIkAjgCSAJMAmACcAKAAqACuALUAuAC4ALsAvQDDAMYAzgDTANgA2wDeAOIA7ADvAPQA9AD4APwAAwEJAQ8BFQEVARsBHAEgAScBKwEyATgBRAFNAU8BVQFaAVwBYwFnAXIBeQF6AYEBhwGNAZIBmAGcAZ8BqAGtAbEBtwG5AbwBxQHHAckB0gHWAdwB4gHqAe8B7wHvAf8BCAILAg8CFAIbAiAC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/P4A9/z//fz//f/+//f2/Pv//wAA+/37/gAA/v4A+/r4+voA/v/9//37/f/+/fz+/AAA/f4A/fv9//8A/v4AAP0A/gD+/Pz6AP4A/v789/v5/fv5+AD+9Pf7+P7+/wD9/f/9//37//////36+/j8+vf7//v9/f39/f39/f79+/79/fz6+/7+/v3//vv//vv9+/v8+/v8/gAAAP3/AP30/wAA/fv9AP78/v3+AP37+vv6/v779f/+AP///QD+/f79/f73+Pr9/Pr////8+v0A/v/9//36+fr/+P/8+AD//f/+/f/+/fr//f37+/r8+/4A/fr///7//v7+AP7+/v/+/v///P77//7///79AP/+/wD+//z+/////////gD+/P7+/f8A//////7//wD/////////////AP3/AP8AAP///f4A/P4A//8AQcCmAguGCXAGxQX4BEIBQgEBACcFxgXTBS0HLQctB9cBAAAAANYARQQtBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HDwEPAcMEwwTYAFgAAQABAAEAAQABACgAbwACAWkB1QEAAkcCbgK1AtwCIwNKA5EDMQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRFBEUERQRZBEUEwAS9A70DYwZ+BvEGLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQctBy0HLQeJALUAtQC1ALUAtQC1ALUAXgCuAUIAQQBwAG4BFQIVAuQC6QQVAhUCTwBPABUCnAGcAZwBTQCcAXsAcQBxAHEAFgAWADQINAhIAUgBSAHvANQB1AHUAdQB9wP3A5kBbgGjBNAEFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAskDbQJtAhUCggIUAxQDbQRtBDYDNgNDAKkENAg0CDQINAg0CDQINAgbBboDugNJAtgBgAKDAbcCGgIdArwCFQIVAhUCFQIVAhUCFQIVAhUCFQLeABUCFQIVAhUCFQIVAhUCFQIVAhUCFQIVAr0EvQS9BBUCFQIVAjUCFQIVAhUClAN7BBUCFQIIBRUCFQIVAhUCFQIVAhUCFQJ/AgAF0QBpBGkEaQRpBEQC0QDRALkEAAOVA4kCIwU2BZUBNgVnBfkAIwUjBfkAIwWVAWcFoQXQAd0EiQWJBYkFKwUrBSsFKwW4ALgANwXEBVgDygXQBtAGgQaBBu0G7QaBBoUGhwYKB/YGEQcRBxEHEQeBBhkHmgaHBocGmgYKB/YGmgb2BpoGgQYZB50G/waBBhkHKAeBBhkHgQYZBygH2AbYBtgGDQc6BzoHKAfYBtUG2AYNB9gG2AaxBkIH7wbvBigHgQYHBwcHHwcfB+EG5QZiB4EG3QbhBusG7gaaBmYHeQd5B4kHiQeJBzQINAg0CDQINAg0CDQINAg0CDQINAg0CDQINAg0CM8AxARLAWwCxwMmAzIE2wWYBbcFxwWLBY4FFQboBT4GPwZsBm0GdgZ8BhMG4QWUBrYFhgYbBlMGOQaMBo8GTQaQBhIGFgaZBpwGRQY1BqMHpweVBwsHngefB5kHmgcnBxwHMgecB5wHoAcpB6IHKgepB7oHLgc7B5wHPAeCB5sHnAcsB4wHjweQB5YHSgdZB6wHQwfOB8wHvAdgBzMHkQe9B5MHjQewB00HaAfEB8kHywdcB2MHzQehB88H0AfKB9EHpQeuB9IHiwfGB9YHqgfTB9cH1AdaB9oH2wfcB9gH3QffB5gHagfjB+QHiAfeB+cHbwfmB+AH4QfiB+UHrQe2B7IH6Ae7B68H6QfyB/QH9Qf2B/cH7AeDB4QH/AfmB/4H/wcACAEIAggDCAYIDggHCAgICQgKCAwIDQgLCKQHkgedB6YHDwgQCBYIJQgoCABB0K8CC9lNwQDBAMEAEgETARQBwQASARMBFAHBAN8A2wDhAM4A0gDTANQAwQATANsA6QDYANgA2QDYANkAwQAnAdgA2QAfAMEA2ADZAMEA5ADVAOYAJwDOANgA2QArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQDBABMAuQC6ALsAvAC9AL4A/QASARMBFAHDAMEAxQDBAAUBEgETARQB/QDMAO4AzABRACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABIBEwEUAQYBZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA7wDwAO8A8ADSANMA1AA6ATsBOgE7ADwBVgD8AFgA/AATADoBOwEAAQEBcQAZAEgAKAGKAIsACgFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQBRACQBOwAkASoBbABtAG4AbwBwAHEARQB0AHUAdgBIAGoAawDBAG8AcABxADYANwA4ADkAOgBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQB4ABkA2ADZAJEAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA5wCKAIsAdAB1AHYApACZABMAmwA2ADcAOAA5AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAIAAgQAuAC8AMAAxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ANgAwQAZADsAwQATAKUApgDBAEMAGABmAGcAaABpAGoAawBsAG0AbgBvAHAAcQBJANgA2QA7ANgA2QArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQB5AJEAOwDBAHQAdQB2AHcAEQHMAHoAewB8ABMAFACGABYAiACJABMAhAB/AIAAgQAYABYAFwB0AHUAdgAkAMEAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA7wDwADcBOAHXAGoAawDxABMAOwDYANkA3wD8AHMAdAB1AHYAlwB4ABoARwDBADQBNQHBAJUAgAA5AdgADQFRACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AP0A2ADZAGQAXwCZADsAmwAFAWoAawAZAMEAZQDBAMEA5wByABkAdAB1AHYAcQAwAXkAwQDMADsAdwB4AHkAegB7AHwAfQDYANkAwQDYANkAgwCKAIsA5gBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQCZAJoAmwCcAJ0A7wDwAHQAdQB2AEwAwQAXABMAGQAWAP0AFwD8AP0AbABXAMwAWQAFAcYAXAAFAXQAdQB2AMEAMgEzAdgA2QCWACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADsAwQDYANkAEwDvAPAAGwEXAGoAawBsAG0AbgBvAHAAcQBJAPwA/QCOADQBNQGKAIsAUQA5AZEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAMwFmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAZAXQAdQB2AB0BFwDBABkAdwA7AMEAegB7AHwAOwB/AMsAOwDNABMADAGEABkAFwAWAMEAigCLAPkAzAD7AGYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABMAFgAXADsAFwAZAO8A8AB0AHUAdgDBAAsAdAB1AHYAdAB1AHYA/AANARYAwQAPACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ABEBjwDBAHYAjwBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQBMAHYAOwDxAHQAdQB2ADAB2ADZACQBjwA8AFkA8QATAFwAwQDBABcAFgA3ATgB5wBlABYAjwBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQATAMEAwQA7ABcAdAB1AHYAOwDJABUA8QAwAcEAzgB/AIAAgQDBAIAAgQDrAOwAMAErACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAWAMEA2ADZAMEAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEA5wDBAMEAwQB0AHUAdgDYANkAdAB1AHYA4gBQAMEAEwDrAOwAMAEXANMA1ADnAMwA2ADZAM0AZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAEwDBAHsATADvAPAAwQD9AO8A8ADvAPAA9ABqAGsAwQBZAPwAwQBcADsA/AD+APwAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAHAGhANgA2QDBAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAOcAwQD0ALsAvAC9AL4ABwAIAAkANQHDAP4AxQA5ARMAfwCAAIEABgHMABYAdQAYANgA2QARAWYAZwBoAGkAagBrAGwAbQBuAG8AcABxACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AMEA7wDwAMEAOwATALwA/QC+AMEANwE4ARAAwwD8AMUAwQATAC0BLgGHAMEAzADYANkAjADYANkACgHMAJ8ALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAMAO8A8ADBACoB7gB1AP0A7wDwAO4AAwEEAcEA/AAbAMEATQDBAE8AzAD8AAYBwQArASwBwQBkAAoBFgEqAMwAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAdQCfANgA2QB5ANgA2QA/AMEAwQDBAO8A8ABzAHQAwQAqAUkA8ADuAOcAEwDvAPAA/AAWABgA0wDUAAcB/ADYANkA2ADZAPwAmQCaAJsA/QDBABMAkADVAAwBKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAwQATADsA2ADZACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AMEAEwAYANgA2QArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQAcAcEA0ADRAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAB4BOwDBAOgAdQAjAcEAwQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQDBAMwAFgAXAMEAGQBCAMEAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAwQDBAMEA2ADZAFUAwQDuABMAEADYANkA7gDBAF4AwQDvAPAA5wB1AAwBIwB0ANgA2QDYANkAFgAXAPwAGQDQANEALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5AMEAwQATAAUAOwBCAMEABwEKAAsADAANAA4ASgBlABEAwQAuAMEAkgDBAEwA1QBNAAcBTwAMAAQBHgAuACAACAFXAMEAWQAdAAcBXAAoACEA6AAbAMEAbABmAGcAaABpAGoAawBsAG0AbgBvAHAAcQAqAIoAiwBlAMEAdAB1AHYAEwAUAP8AFgBGAIIAhwBBAAABAQHBAIwATgA/AMEAUQDBACQAwQDYANkAwQBzAMEABwHBAJEADAE7ADAAwQDBAGIAwQBzAMEAIwHYANkAwQA7ANgA2QChANgA2QDYANkA2ADZAIMAwQBHAMEA2ADZANgA2QDYANkAwQAEAdgA2QATAAgBVQCFAPQAZADBAFoAigCLANgA2QDYANkA/gD0AMEAZADBANgA2QB0AHUAagBrAP4AeQDBAHMA2ADZAHIAogB0AHUAdgBzAPQAeQDYANkA2ADZAMEANQHBAB8A/gA5ATUB2ADZADUBOQEnAMEAOQE1AZkAmgCbADkBwQCWABkAkADYANkA2ADZAJkAmgCbAJwAnQAAAAEAAgDYANkABQCVAJYAFgDBAAoACwAMAA0ADgDBAJ4AEQCgAMEAEwAUAHQAFgAZAMEAGAAWAMEAGAAeAOIAIAATABQA4gAWACQAwQA1ACgAwQDYANkAwQAXAMEAGQDYANkAJADYANkAwQBjAMEAwQAWAMEAwQA7ANgA2QDBANgA2QDBANgA2QDBAEYAgQBHADsAgQDBANgA2QBOANgA2QBRANgA2QDBAEcAVQDBAIUAwQB+AFoA2ADZAJgAAgE9AJgAYgBVAMEAZADBABcAWgAZAHkAagBrABcA2ADZANgA2QBkAHIAgwB0AHUAdgBqAGsAeQDYANkA2ADZAMEAcgDBAHQAdQB2AIUAFgB5AMEAOwCKAIsAwQCOAMEAjQAXABcAGQAZAHgAeQDYANkA2ADZAJkAmgCbAJwAnQDYANkAEwCiANgA2QDYANkAmQCaAJsAnACdAAEAAgDBADsABQATABQAPgEWAAoACwAMAA0ADgDBADsAEQDBABcAFwAZABkAJAB1AMEA2ADZAMEAFwAeABkAIAATABQAFwAWABkA2ADZACgA2ADZAAcACAAXADsAGQBTAFQAJAAXAMEAGQAXABcAGQAZAEcAmQCRAJsAdQCZABcAmwAZABcAYQAZAEYAwQDBADsAdQDsAMEAwQBOAMEAwQBRAI0AwQDBAEcAwQBkACABHwHyAP8A/wBqAGsAbAD/AP8AYgDzACkBcgDWAHQAdQB2APUAvwB5AA8BJQELAQsB9gBkAPYA9QAPAQ8BJQFqAGsA3AAPAeUA4QD5ANsAcgADAXQAdQB2AIUAAwF5ANsA2wCKAIsAmQCaAJsAnACdABgB+QDzABMAFAD1ABYAxAADAYwAAwE8ACkBjQApAcgAyACiACYAyAAkACYBmQCaAJsAnACdAJcAlgAmARsBFgArAOoAEgDtAMgADgEQAe0A7QDtABIAOwDHAA4BlQD2ABABEAHIAOoA6gD2APYARwD2AMcAngAiAT4AFgDIABMAFADHABYAIQHdAN0AyADIAMcAxwBzANoAQADaANoAFgAkAOMAfgDjAGQApQDdAOAA4AAYAGoAawA4AdoAMQFxABoBWwByANwAdAB1AHYAOwAaAXkA2gDaANoAyAA9AT0BUgDdAAkBRwCUAJEACQEWABUByACeABcBjACTABkAkgDKAPgA+gD5APcADQD6AMIAwgCZAJoAmwCcAJ0ABgAvAWQAwADAAPYA1QDAAGoAawDPANUAzwDeANUA1QByAN4AdAB1AHYA1gDWAHkABADPANUAAwAWAC8BDwCjABAAFwAXAIsAlwCCABkAFACOABgAEACQAAEAjgCCAIIAPQAlADUALAGXADUANQCZAJoAmwCcAJ0ANQCCAHQAIgABAI0ABQAWAHMAoQBEABkARABLACkAjQBzABgAFAATAIMAfQAXABwAFgBDABYAFgAWAEMAOwAYAGAAFgBDABcAlQAWABkAFwAXABcAFgAiAI0AJQBhABcAFwB0ABYAjwAZACIASwAiACIAIgBYAEsAIgBWABcAFgAiAF0AGAAiABkAGQCOAI4AFwAsABcAFwAXABcACwAXABkAFgAWABYAjQAXABcAFgAWABkADwABABcAGQABAI0AhwA/AT8BPwE/AT8BPwE/AY0APwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AT8BPwE/AQAAAAAAADwC0gA8AncAdADnADwCdwB0AOcAPAIlBXsBEAWaATYCNgI2AjwCmwF8ASUF/wQqACoAKgAqANIA+QVIAEgAzgOlASoAKgDvATEBGQExAc8DjwFIAEgAfgB/AFEAwQTBBB4EIQQUBBQEfAB8AH0AfQB9AH0A4AGbAdwEAQABAEICAgDgBCoCdwB0AOcAPwHkAZMA5AEQAncAdADnABUCMgWjAQ8CjwB+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQB3AHQA5wBJAXsAewB7AHsAegB6AHkAeQB5AHgAdQDAAR4BHgEeAR4BvgG+Ab4BIAZ6ASIGqQR5AYwEOQKMBDkCmwEgBh0CBQHkAMABZgCSAMUBPgEzAvIAewB7AHsAewB6AHoAeQB5AHkAeAB1AMABfgB/AFEAwQTBBB4EIQQUBBQEfAB8AH0AfQB9AH0AjwAoAakEVQHEAXkAeQB5AHgAdQDAAYAAqQSqBKkElQC9AbwBPAJ4AHUAwAF9AH0AfQB9AHYAewB7AHsAewB6AHoAeQB5AHkAeAB1AMABygFyAA0ADQAmAnsAewB7AHsAegB6AHkAeQB5AHgAdQDAAagBPgEzAqkEqgSpBJYAyQSbAckEfQB9AH0AfQB7AHsAewB7AHoAegB5AHkAeQB4AHUAwAHVAVgBEQQRBB8EIgR+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQACBQ4C4ACpBDwCmwHiAAcCsQBTAFQAewB7AHsAewB6AHoAeQB5AHkAeAB1AMAB8gMQABAAqQSGAIYAfgB/AFEAwQTBBB4EIQQUBBQEfAB8AH0AfQB9AH0AewB7AHsAewB6AHoAeQB5AHkAeAB1AMABFQQmAqkEdwGpBKoEqQT+AJ4FkQH8AfkB+AFwADQCOgIEAKEDoQOzAfcBVgHQAUoBagGMAdYEqQSqBKkENwI8AnsAewB7AHsAegB6AHkAeQB5AHgAdQDAAR4BHgFzAS0GRwa9AbwBmwCbAcEBSABIAAkFOQLGBKkEqgSpBFYAyAQRATECIwIIAggCPAJjAMcEBgABBdwBjwB+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQAqAg0ADQAHBP8ByQSpBMkEKQJuAG4A4AA8AtcEsQA8Aq0BbwDHAMEBPQLBAbABEwb7A0cBKwKpBBABIQFyAQICbQEBAgMBSABIACMCSABIAGkBPgEzAk0GewB7AHsAewB6AHoAeQB5AHkAeAB1AMAB+wP7A/0D/gMcAB4BHgGpBKoEqQSHBDwCTAabAYgDwAAqAmYBOQIqAqwDGQIJAocEtQGfAYcELAKpBKoEqQQ8AiQCJAI0ADQA2AB+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQCpBN4BiACIAJsBHgEeAdUF/QF6AHoAeQB5AHkAeAB1AMAB8gM5AgoC2wAhAiECPgEzAo8ABgAYAn4AfwBRAMEEwQQeBCEEFAQUBHwAfAB9AH0AfQB9ABUGewB7AHsAewB6AHoAeQB5AHkAeAB1AMAB6QGpBKoEqQTmARsB9gTAA/4AqQR3AfwB+QH4AakEVgE+AqkEPgKbASYB9wHAA28DwQDkAT4BMwKCASQBfgF7AHsAewB7AHoAegB5AHkAeQB4AHUAwAF+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQCbAYwBcwSpBGgDZQAeAR4BqQSqBKkEdwFIBKkEqgSpBKkEqgSpBDkCywEhAHcB6wB+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQCdBcIDPALmAMEDewB7AHsAewB6AHoAeQB5AHkAeAB1AMABhwTmAKkEngCpBKoEqQQUBg0ADQAvAcAD0QSHBJoAmwGHBHcBMAaZBAUAcwEtBq8B1wQDAMADewB7AHsAewB6AHoAeQB5AHkAeAB1AMABfgB/AFEAwQTBBB4EIQQUBBQEfAB8AH0AfQB9AH0AmwHSADsCqQQIBKkEqgSpBKkEhgFXA5wAEwZ4AZQBTQRNBOwBPALVAVgBKgUqBRMGfgB/AFEAwQTBBB4EIQQUBBQEfAB8AH0AfQB9AH0AggA8Ag0ADQAUAnsAewB7AHsAegB6AHkAeQB5AHgAdQDAATABPALJAeUAqQSqBKkEDQANAKkEqgSpBBQF0wH2BJsBKAUoBRMG9wPJAcgBtAEtAUgASAD0BHsAewB7AHsAegB6AHkAeQB5AHgAdQDAAX4AfwBRAMEEwQQeBCEEFAQUBHwAfAB9AH0AfQB9AJsBgAE0BIcEHgEeAaUBOgEYARgBHwEfAc0BmAGXAQMGhwQ5AjwChwSsBDkCmQE5An4AfwBRAMEEwQQeBCEEFAQUBHwAfAB9AH0AfQB9AMkBzQUNAA0ABQZ7AHsAewB7AHoAegB5AHkAeQB4AHUAwAHKADwCzgEzBkICAgDgBEsDTANNAxsGPwGZAZMABgCbAQEBAAH/ANAAMgUJAKwECAFIAEgAnAV7AHsAewB7AHoAegB5AHkAeQB4AHUAwAF+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQA8Ah4BHgE8Ar0EmwFBAjsB4ASlAXMBLQZkAT8BOQKTAO8BEQJsBo0BpwPvATIFRwBHAKYDSABIAPIAMAVpAFEAwQTBBB4EIQQUBBQEfAB8AH0AfQB9AH0AewB7AHsAewB6AHoAeQB5AHkAeAB1AMABXQQeAR4BjgXEAfgFvQS7AR4BHgHUBUsFOQHeATkCXgTGAV8B7wFiAfIEOQLRADwCogGzADwCBwTyAIEBXwQLAnsAewB7AHsAegB6AHkAeQB5AHgAdQDAAfwDbABIAEgA+wMNAA0AkwM8AtoFPAIeAR4BYgASAgEGxAGUAzYFMQXLAJsBHgEeATkCmADTANoF3AWqATkCOAA4ADkAOQA5AvsD+wP9A78BPAKbARMCDAApAX4AfwBRAMEEwQQeBCEEFAQUBHwAfAB9AH0AfQB9ADwCmwFjAw8ADwB+AH8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQB1ARECCAEsACwAfgBzAFEAwQTBBB4EIQQUBBQEfAB8AH0AfQB9AH0A2gXeAfcEoQF7AHsAewB7AHoAegB5AHkAeQB4AHUAwAHNAL0E7wGuAWMD1AFCAe8BewB7AHsAewB6AHoAeQB5AHkAeAB1AMABPAItAnQEagaOBWoGHwI8AnsAewB7AHsAegB6AHkAeQB5AHgAdQDAATwCjgU8Ag0ADQAeAkMBLQWbAU4BOgA6AF0BjgWSBEYBHgEeASUCvQQsAX8DEgItAC0AOwA7AHQEawY5AmsGNQKhAX8AUQDBBMEEHgQhBBQEFAR8AHwAfQB9AH0AfQBXBXUB9AEiAakEAAJWBasBigGKAYkBEwGHAYADcgRUA94BAgGOBZIEzwGHBAwASwGsAU0BXQTMAewAAgFFAcwBIAIIBocESgTrAYcERAFKBLgBXgRPAQQCewB7AHsAewB6AHoAeQB5AHkAeAB1AMABXwQ+ATMCcgQ8AqkEqgSpBHAANALJAAQA7gCxAacD6gEdAeQA7QWmA6oAMAI8Ao4A7AU3AjwCPAA8ADwCoAE8ArkBPAIXAi4BawMIAOcBPALtADwCoAE8AuUBPQA9ADwCwQE+AD4ATAE/AD8ALgAuAC8ALwBpATwCMQI8AjAAMAAyADIAMwAzADwCJwFAAEAA4gEnARsCnAHXAQcEPAIaAj4BMwJBAEEAQgBCAJkB2wE8AgcEPAIOAA4AawP8A24AbgCZAfsDPALaAUMAQwBvAMcBwQE9AsEBYgA9AfsDhACEAIUAhQA8AhkGPALOA5kBBgAaBkQARAAYBgYAzwM8AgYAFwb7A/sD/QMGAFoB2gBlABMCNQA1AEUARQD7A/sD/QP+AxwAMgadBMMBRgBGACIBVwDXAB8AUwWKAYoBiQETAYcBXgFtAFQDawA8AnAANALjAQQAvAQ8Au8AmQA8AicA7AATBUUBcAA0AhIFBAA3AjwCIABEATwCNgA2ADwCbwRhAY4BpQClADcCpgCmADwCIwFjATwCEQBlATwCwQFNAE0AIQU3ADcAEQVJAEkAPALuANYBMQLBAdgBbAGHAIcAqgBKAEoAjgCjAKMAdgExAhsCPAJBATwCdgMcAokAiQBTAUkFpgEqAe0AGwI8AgcEPAJUARoCZQBxAW4AbgCiAIMAgwCkAKQABwRvAHABwQE9AsEBbgBuAPsDnQCdAI0AjQA8Am8APALBAT0CwQGcASAB+wM8AnIDPgEzAjwC2wA8AvEA9APdAQcBBwF+A30DjACMAIoAigD7A/sD/QP+AxwAiwCLAA0CxwFMAEwATgBOAPsD+wP9A/4DHACdBMMBPAI7BCIBcAA0AicGBACKAYoBiQETAYcBPAL/A1QDPALfAVkBBwFlADcCcgNgBUsASwCNBfUB7AAEAUUBcAA0AmcBBABlACsAKwBEATEAMQCFA4YDoQDBAWUA0QPSAzcCNwRFBQQBxQOkAwcBcgAxAkcEBQJHBDsERgRhA0YElwClA3gEcgDuAFEFLgLBAf8DLwKSBf4EqgD1BOkEjgBBBugE6gQxAjoGBwTwARYB1QBCBTYBbgBuAKsDNwE4Ae0ACwDqAG8A3QDBAT0CwQElAYsB+wOABVEBewV0BVIBBwQrAVcBhQWEBeEBbgBuAPoBkgHhABAFzgBvAW8ATgXBAT0CwQGcAU8F+wPRBdAFPgEzAvsD+wP9A/4DHAAyAs8A3ABQADQChQEEAD0GTQUoAkwF0QS1AAsB6AAABv4FxwHOBKQBNwJSAPsD+wP9A/4DHABWANkAVQDWBb4ArwC3ANEBuQDSASQAgQW6ALsAvADzAcEB9AAlAGMAkAGHBYYF6AGJBcIA2QGTATECywX4AFwA4QXuAcYAFwFwADQC+gAEAFwB8QGVAWAB6wT7APwAAwIkBbIBIwUiBV4ANwIbBXYDGgUHBOIAlgFLBkoGtgFuAG4ALAYGBQwCtwE0AQoBbwAFBcEBPQLBAcEBNQH7A24BBAVJBgkBHgYdBroBdAFlBTECgQAmAmQFCgC+BX8BagA8AScCZAAjABYCPwLUADsFfQGDAaMEOgUSARQB+wP7A/0D/gMcABUBnQEHBEAC5gSEAfEF4QRuAG4ApwDyBagAlADwBe8FbwAyAcEBPQLBAd4A3wD7A0cDqQBPAMIB1gCeAekAQAGRAEUEQwRIAbYAqwC8BJYDuADwAFAB8wBTBL0ArACtAKcBqQFYALQAvwBZAFoA+wP7A/0D/gMcAFsArgBWBPUAUgT2AJ8AEgD3AFsBSwQHAcMAywTtAfkAxAAmAFYD8gFwAf0AaAGBA8UA9gFdABMAFAD7AXQDawH+AV8AMwGgAGAABgJhAJcEJAR6BCgAFQDjALAAeQQaARwByQPIAMMDcgAGAY0EFgAXABgAiQSRBBkAiwR+BCIAGgCQBCICGwDMAGUAZwBoADIEBwAlBCMEJwRcBCgEWwQMAQ0BHQApAA4BAARiA3EAHgA4AogBnwSQALIAngQPAaAD3QTdBN0E3QTdBN0E3QRCBgAAAAAAAAAAcAZwBnAGxgXbBEoF2wTbBNsExgXGBcYF2wRoBWgF+wX8BNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTFBdsE2wTbBNsEHAYcBtsE2wTbBNsE2wTbBNsE2wRxBdsEeAXbBNsE2wTbBNsExwXIBdsE2wTbBPoF/AXXBX8FfgV9BXwF6QVcBXYFbwVzBcIFwwXBBVoGyAXHBdsEcgWiBbIFoQXbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBKoFsQWwBa8FuAWuBasFpAWjBaUFpgXbBNsE8wTbBNsE8AQmBdsE2wTbBNsE2wQOBg0G2wSnBdsE/ASbBZoFmQW1BagFtAWzBQIGQAY/BtgF2wTbBNsE2wTbBNsEHAbbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsEXgUcBhwG2wT8BBwGHAZfBV8F+AT4BGIF2wQJBkEFQQVBBUEFSgVBBdsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBP8F/QXbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wRGBdsE2wTbBNsE2wTbBNsE2wTbBNsE2wQ5BtsE5AU0BUYFRgVGBUYFSAU1BTMFQAX9BOIEaAaCBXcFRwV3BWUGdQWCBYIFdQWCBUcFZQYNBU8GCAVoBWgFaAVeBV4FXgVeBWIFYgXEBUcFQAXbBGgGaAZQBVAFZwZnBlAF2AVXBosFKQUvBS8FLwUvBVAF7QR1BVcGVwZ1BYsFKQV1BSkFdQVQBe0E6AViBlAF7QTOBVAF7QRQBe0EzgUnBScFJwUcBdsE2wTOBScFDQUnBRwFJwUnBS4G2wTSBdIFzgVQBSYGJgZrBWsFcAViBckFUAXbBHAFbgVsBXUFHwU8BjwGOAY4BjgGbQZtBgkGSAb8BPwE/AT8BEgGDwUPBf0E/QT8BEgG2wTbBNsE2wTbBNsEQwbbBAQG2QVUBdsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsEDwbbBNsE2wTbBNsE2wTbBNsE2wTbBJAF2wTeBAYG2wTbBNsE2wTbBNsE2wTbBHkFegVVBdsE2wTbBNsE2wTbBNsEiAXbBNsE2wSDBdsE2wTbBNsE2wTbBNsE2wRkBtsE2wTbBNsE2wTbBOcF5gXbBNsEUgXbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBAsF2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBG0F2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBCsGYwXbBNsE2wTbBFsG2wTbBNsE2wTbBNsE2wTbBNsE2wTbBNsE2wTbBFMGNwWRBdsElAXxBNsE5wTbBNsEAAAJAEHQ/QILlAq9AL0AvAC+AL8AvwC/AL8AvgC+AL4AvgC+AMMAxQDHAMcAxgDGAMQAxADLAMsAzQDNAM4A0ADQANAA0QDVANYA1wDXANcA1wDXANcA1wDXANcA1wDXANcA1wDgAOAA3ADcAN4A3gDhAOEA4QDhAOIA4gDiAOIA4gDfAN8A4wDjAOMAygDlAOYA5gDmAOYA5gDpANoA2gDqAOoA6wDrAL4A7QDtAL4AvgC+AMwAzADMAO8A8gDyAPIA8ADwAPwA/ADzAPMA8wD+APQA9AD0AP8A/wD1APUAAQEBAQABAAEAAQABAAHIAMgA7gDuAAYBBgEGAQYBAgEC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AGxgAAA4YAAAKF8AAPk4AACuWgAAgmAAABpgAACUWgAAVmAAAPpeAABSSQAAuk0AAD5RAACtXAAATF8AALFOAAApSQAAlEkAAItJAABnTgAARkkAAGxPAEGgvQMLvgT4EgAAAQABALEBAADZKwAAAQABALIBAABKLAAAAQABALMBAADXWwAAAgABALQBAADcWwAAAgABALQBAADfLwAAAQABALUBAADlLwAAAQABALYBAADrLwAAAQABALcBAACLOQAAAgABALgBAAAtFwAAAQABALkBAABkFAAAAQABALoBAAD5EgAAAQABALsBAADaKwAAAQABALwBAABLLAAAAQABAL0BAAAsCgAAAQABAL4BAADgLwAAAQABAL8BAADmLwAAAQABAMABAADsLwAAAQABAMEBAACLLwAAAQABAMIBAABqJgAAAQABAMMBAACUMAAAAQABAMQBAACFXwAAAQABAMUBAADcIwAAAgABAMYBAAAZLAAAAQABAMcBAADbCQAAAQABAMgBAACINQAAAQABAMkBAADOLQAAAQABAMoBAACiIwAAAQABAMsBAABVLwAAAAABAcwBAACNMwAAAgABAM0BAADYBQAAAgABAM4BAADYBQAAAwABAM4BAACuIgAAAgABAM8BAAClIgAAAgABANABAAChNAAAAQABANEBAACYJAAAAQABANIBAADaLQAAAgABANMBAAA5JgAAAgABANQBAACxRQAAAgABANUBAABTJAAAAgABANYBAABFBwAAAQAAANcBAADYAQAAljkAAAEAAADXAQAA2QEAAEI5AAABAAAA2gEAANsBAABPLAAAAQAAANoBAADcAQAAvjYAAAEAAADaAQAA3QEAAM02AAABAAAA2gEAAN4BAEGiwgMLOQECAwABAgAAAgIEBQUAAQIGAgMAAQACAAIAAAAAAAAAAQIDAAECAAACAgQFBQABAgYCAwABAAIAAgBB4MMDC8ABBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgICAgICAgICAgICAgICAgMDAwMDAwMDBAQEBAQEBAQAAAAAgDAAAIAgDgCAIMgDAAAAAID///8A+P//AAD/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c3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZh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lt1hABY2AgDEOp8Ag6KhAHLtbQA5jXoAgripAGsyXABGJ1sAADTtANIAdwD89FUAAVlNAOBxgABBw/4DC6cBQPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNQL/AARkACAAAAT//xAAAQABAAEA//8B/wH//////wH/Af8B/wH/Af8B/wH/Af//////Cv8gAP//A/8B/wT/HgAAAQX//////2MAAAhjAOgDAgAAAP//////AAAAAf8B//////////////8AQfn/AwsBBABBhoAEC0QB/wH//////wABIAAEAIAAAAj//wH/Af////////8B/wb/B/8I/wn//////7wCvAIBAP//AQABAP//AAD//////////wBB2oAECwEUAEH6gAQLHv//AQAK////////////Af8B/wAAAAAAAAH/Af8B/wBBqoEEC0gB/wAAAAAAAAH/Af8BAAAAAQAAAAH//////wAAAAAB////AAAAAP////////////8oAAr//////wEACv////8A//////////8AQdaCBAsgAf8B////AQD//////////////////wr//////wz/Df8AQYCDBAsfAQAAAAEAAAEAAQEA/v//fwAAAACwBAAAKAAAAAAAAQBBwIQECwEUAEHMhAQLAfoAQfuEBAsBQABBjIUECwj+//9/////fwBBrIUECykHAAAAAwAAADQAAAAAAgAAAAAAAI4FAABEeQAAeAAAAHkAAAB6AAAAewBB6IUEC0V8AAAAfQAAAH4AAAB/AAAAgAAAAIEAAACCAAAAgwAAAAMAAAA0AAAAAAIAAAAAAADzNQAASHkAAHgAAAB5AAAAegAAAHsAQcCGBAtFfAAAAH0AAAB+AAAAfwAAAIAAAACBAAAAggAAAIMAAAADAAAANAAAAAACAAAAAAAA3DYAAEx5AAB4AAAAeQAAAHoAAAB7AEGYhwQLRXwAAAB9AAAAfgAAAH8AAACAAAAAgQAAAIIAAACDAAAAAwAAADQAAAAAAgAAAAAAAN8tAABEeQAAeAAAAHkAAAB6AAAAewBB8IcECyR8AAAAfQAAAH4AAAB/AAAAgAAAAIEAAACCAAAAgwAAAAAAAEAAQaCIBAtuIywAAJkAAAAAAAAAqTQAAJoAAAAA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"}</script>
                <script type="application/json" data-app="store">{}</script>
            </body>
        </html>
    